signal triggered: rwsh.raw_command ( .function rwsh.raw_command {.echo $1; .echo $nl} ) 
.function # {.nop}
.global last_command_return -10
.global A \
.global N \

# tests multi-line commands within a sourced script
# .function rwsh.run_logic {
  # .return $last_command_return
  # .signal_handler &{.internal_functions}$ {&&* {rwsh.argfunction}}
  # rwsh.mapped_argfunction {&&* {rwsh.argfunction}}
  &&* {rwsh.argfunction}
  # .set last_command_return $?
  # .echo $nl
  # .echo $last_command_return
  # .echo $nl}
.function rwsh.before_command {.return $last_command_return}
.function rwsh.after_command {
  .set last_command_return $?
  .echo $nl; .echo $last_command_return; .echo $nl}
.function rwsh.prompt {.echo \$}
.function rwsh.shutdown {.echo $nl; .echo now terminating normally; .echo $nl}
.function rwsh.vars {.internal_vars}
.else_if .test_string_equal $2 -c {
  rwsh.mapped_argfunction &3 {.source /etc/rwshrc-basic; $1$; .exit}}
.else {
  .echo unexpected command line: &* (
)
  .source /etc/rwshrc-default}
rwsh.help not defined 
$.which_executable rwsh.argfunction {
  .function  x  { &&{ .which_path  echo  $PATH }  something } }
{
  .function x { &{ .which_path echo $PATH} something}}
0
$.which_executable rwsh.argfunction {{{{{{{{{{{}  }} }}}}}}}}
{{{{{{{{{{{}}}}}}}}}}}
0
$.function w { .which_executable  $1  {rwsh.argfunction} }
0
$.which_executable w
.function w { .which_executable $1 {rwsh.argfunction}}
0
$w w
.function w { .which_executable $1 {rwsh.argfunction}}
0
$
now terminating normally
