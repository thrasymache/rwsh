init file /non-existent/file/to/test/failure does not exist
call stack .source rwsh.mapped_argfunction
.for ${.echo rwsh.sigterm rwsh.multiple_argfunctions}$ {.nop
  .function_all_flags $1 {.echo signal triggered: $0 \( \); .combine $nl; .return -1}}
.global last_command_return -10
.global A \
.global N \
.nop $N

.nop .function_all_flags rwsh.run_logic -- cmd [args ...] {
  .return $last_command_return
  .signal_handler &{.internal_functions}$ {&&* {rwsh.argfunction}}
  rwsh.mapped_argfunction {&&* {rwsh.argfunction}}
  &&* {rwsh.argfunction}
  .set last_command_return $?
  .echo $nl
  .echo $last_command_return
  .echo $nl}
.function_all_flags rwsh.before_command -- args ... {
  .nop $args
  .return $last_command_return}
.function_all_flags rwsh.after_command -- args ... {
  .nop $args
  .set last_command_return $?
  .combine $nl $last_command_return $nl}
.function_all_flags rwsh.prompt {.echo \$}
.function_all_flags rwsh.vars {.internal_vars}
.source /etc/rwshrc-basic
.function_all_flags # -- [ignored ...] {.nop $ignored$}

# set up environment
.set_max_collectible_exceptions 10
.set_max_extra_exceptions 5
.global nl (
)

# internal functions
.function_all_flags rwsh.ambiguous_prototype_dash_dash prototype stack ... {
  .echo $prototype is an ambiguous location for a prototype --
  .combine ( (it requests reading the user's mind) ) \( stack: $stack \) $nl}
.function_all_flags rwsh.arguments_for_argfunction name {
  echo cannot specify arguments for $name directly}
.function_all_flags rwsh.bad_argc required needed optional [stack ...] {
  .echo unacceptable argument count: received $required non-optional
  echo , but needed $needed \(with $optional optional\) for $stack$}
.function_all_flags rwsh.bad_argfunction_style style {
  echo $style is neither an argfunction nor a substitution}
.function_all_flags rwsh.bad_args -- proto assigned needed excess call_stack ... {
  .combine (unacceptable arguments: for prototype ) $proto , $nl
  if_only .test_not_empty $assigned {
    .combine ( assigned )
    .for $assigned$ {.combine $1$0 = ${paren_if_words $1$1} ( )}
    .combine , $nl ( but)}
  if_only .test_not_empty $needed {
    .combine ( needed \() $needed \), $nl
    if_only .test_not_empty $excess {.combine ( and)}}
  if_only .test_not_empty $excess {
    .combine ( found \() $excess (\) excess) $nl}
  echo \ call stack:  $call_stack}
.function_all_flags rwsh.bad_if_nest stack ... {
  echo nested .if without .else with call stack: $stack$}
.function_all_flags rwsh.binary_does_not_exist name [stack ...] {
  echo $name : binary does not exist
  if_only .var_exists stack {echo call stack: $stack}}
.function_all_flags rwsh.binary_not_found name path stack ... {
  echo $name : binary not found in $path
  echo call stack: $stack$}
.function_all_flags rwsh.dash_dash_argument args stack ... {
  echo optional -- parameter cannot take arguments \( $args \) with call stack: $stack$}
.function_all_flags rwsh.dash_star_argument args stack ... {
  echo optional -* parameter cannot take arguments \( $args \) with call stack: $stack$}
.function_all_flags rwsh.directory_not_found -- dir stack ... {
  .combine $dir ( directory does not exist) $nl
  echo call stack $stack}
.function_all_flags rwsh.divide_by_zero numerator stack ... {
  echo attempt to divide $numerator by 0 with call stack: $stack$}
.function_all_flags rwsh.double_redirection first second [stack ...] {
  echo double redirection is not supported at this time: $first and $second
  if_only .var_exists stack {echo call stack: $stack$}}
.function_all_flags rwsh.duplicate_parameter -- parameter stack ... {
  echo duplicated parameter in function definition: $parameter
  echo call stack: $stack$}
.function_all_flags rwsh.elipsis_first_arg -- elipsis stack ... {
  echo $elipsis elipsis cannot be the first argument in a prototype
  echo call stack: $stack$}
.function_all_flags rwsh.elipsis_out_of_option_group -- group stack ... {
  echo $group for elipsis to apply to option it must occur within the brackets
  echo call stack: $stack$}
.function_all_flags rwsh.else_without_if stack ... {
  echo else without if with call stack: $stack$}
.function_all_flags rwsh.excess_argfunction cmd [stack ...] {
  echo $cmd does not accept an argfunction with call stack: $cmd $stack$}
.function_all_flags rwsh.excessive_exceptions_collected max stack ... {
  echo exceeded maximum number of exceptions \( $max \) in collect_errors.
  echo call stack: $stack$}
.function_all_flags rwsh.excessive_exceptions_in_catch max stack ... {
  echo exceeded maximum number of exceptions \( $max \) in try_catch.
  echo call stack: $stack$}
.function_all_flags rwsh.excessive_nesting stack ... {
  echo function exceeded max nesting \( ${.get_max_nesting} \). call stack: $stack}
.function_all_flags rwsh.exec_failed binary errno stack ... {
  .combine (.exec failed for ) $binary ( with errno ) $errno $nl
  echo call stack $stack}
.function_all_flags rwsh.executable_already_exists -- binary stack ... {
  echo $binary is already an executable in the hash table $nl
  echo call stack $stack}
.function_all_flags rwsh.failed_substitution substitution [stack ...] {
  echo substitution $substitution failed
  echo call stack $stack$}
.function_all_flags rwsh.file_not_found -- file stack ... {
  echo could not find file $file
  echo call stack $stack}
.function_all_flags rwsh.file_open_failure -- file stack ... {
  echo could not open file $file
  echo call stack $stack}
.function_all_flags rwsh.flag_in_elipsis -- flag stack ... {
  echo found flag $flag while collecting arguments for elipsis
  echo call stack $stack$}
.function_all_flags rwsh.function_not_found -- cmd [stack ...] {
  echo $cmd : command not found \( $cmd $stack$ \)}
.function_all_flags rwsh.help [args ...] {
  .nop $args$
  .echo this is the default configuration for rwsh \(or something copied from it
  echo \), documentation should be available at rwsh.sf.net or rwsh.org}
.function_all_flags rwsh.if_before_else stack ... {
  echo two .if commands without a .else between them with call stack : $stack$}
.function_all_flags rwsh.illegal_function_name name stack ... {
  .combine \$ $name ( cannot be a function) $nl
  echo call stack $stack}
.function_all_flags rwsh.illegal_variable_name name stack ... {
  .combine \$ $name ( cannot be set) $nl
  echo call stack $stack}
.function_all_flags rwsh.input_range -- value stack ... {
  echo value $value is out of usable numeric range
  echo call stack $stack$}
.function_all_flags rwsh.internal_error -- [args ...] {
  echo internal error: $args$
  .return -1}
.function_all_flags rwsh.invalid_word_selection selection [stack ...] {
  echo $selection is not a valid word selection
  echo call stack $stack$}
.function_all_flags rwsh.mismatched_brace context [stack ...] {
  echo mismatched brace: $context $stack$}
.function_all_flags rwsh.mismatched_bracket context stack ... {
  echo mismatched bracket: $context
  echo call stack: $stack$}
.function rwsh.mismatched_parenthesis {
  .echo signal triggered: $0 \( $* \); .combine $nl
  echo mismatched parenthesis: $1
  echo call stack: $*2
  .return -1}
.function_all_flags rwsh.missing_argfunction cmd [add_stack ...] {
  echo $cmd requires an argfunction
  if_only .var_exists add_stack {echo stack $add_stack$}}
.function_all_flags rwsh.multiple_argfunctions {
  echo multiple argfunctions not supported at this time}
.function_all_flags rwsh.not_a_directory file stack ... {
  .combine $file ( is not a directory) $nl
  echo call stack $stack}
.function_all_flags rwsh.not_a_function executable stack ... {
  .combine $executable ( is not a function) $nl
  echo call stack $stack}
.function_all_flags rwsh.not_a_number -- nan stack ... {
  echo $nan is not a number
  echo call stack: $stack$}
.function_all_flags rwsh.not_executable file stack ... {
  echo $file is not executable
  echo call stack: $stack$}
.function_all_flags rwsh.not_soon_enough too_late [stack ...] {
  echo $too_late attempts to substitute after the command has been run
  if_only .var_exists stack {echo call stack $stack}}
.function_all_flags rwsh.post_elipsis_option -- flag stack ... {
  echo option $flag coming after an elipsis has no meaning
  echo call stack: $stack$}
.function_all_flags rwsh.post_dash_dash_flag -- flag stack ... {
  echo flag option $flag occurs after -- in the prototype
  echo call stack: $stack$}
.function_all_flags rwsh.result_range -- lhs rhs op [stack ...] {
  echo result of $op with arguments $lhs and $rhs is out of range
  echo call stack: $op $stack$}
.function_all_flags rwsh.return_code code cmd [add_stack ...] {
  echo $cmd returned $code : call stack $cmd $add_stack$}
.function_all_flags rwsh.selection_not_found not_found selection [stack ...] {
  .echo no file matching pattern $not_found
  if_only .test_string_unequal $not_found $selection {
    .echo () for selection $selection}
  .echo $nl
  if_only .var_exists stack {echo call stack: $stack$}
  .return -1}
.function_all_flags rwsh.sigcont [args ...] {
  echo received SIGCONT: $args$; .return -1}
.function_all_flags rwsh.sigchld [args ...] {
  echo received SIGCHLD: $args$; .return -1}
.function_all_flags rwsh.sighup [args ...] {
  echo received SIGHUP: $args$; .return -1}
.function_all_flags rwsh.sigint [args ...] {
  echo received SIGINT: $args$; .return -1}
.function_all_flags rwsh.sigquit [args ...] {
  echo received SIGQUIT: $args$; .return -1}
.function_all_flags rwsh.sigpipe [args ...] {
  echo received SIGPIPE: $args$; .return -1}
.function_all_flags rwsh.sigterm [args ...] {
  echo received SIGTERM: $args$; .return -1}
.function_all_flags rwsh.sigtstp [args ...] {
  echo received SIGTSTP: $args$; .return -1}
.function_all_flags rwsh.siginfo [args ...] {
  echo received SIGINFO: $args$; .return -1}
.function_all_flags rwsh.sigusr1 [args ...] {
  echo received SIGUSR1: $args$; .return -1}
.function_all_flags rwsh.sigusr2 [args ...] {
  echo received SIGUSR2: $args$; .return -1}
.function_all_flags rwsh.sigunknown [args ...] {
  echo received unknown unix signal: $args$; .return -1}
.function_all_flags rwsh.shutdown -- args ... {
  .nop $args
  .combine $nl (now terminating normally) $nl}
.function_all_flags rwsh.tardy_flag -- flag stack ... {
  echo $flag flag comes too late in command
  echo call stack: $stack$}
.function_all_flags rwsh.unchecked_variable -- var [stack ...] {
  echo $var was not checked with call stack $stack$}
.function_all_flags rwsh.undeclared_variable -- name [stack ...] {
  echo $name was not declared
  echo call stack: $stack$}
.function_all_flags rwsh.undefined_variable -- name [stack ...] {
  echo optional variable $name was not defined
  echo call stack: $stack$}
.function_all_flags rwsh.unreadable_dir dir errno [stack ...] {
  .combine (cannot read directory ) $dir \ \(errno\  $errno \) $nl
  echo call stack: $stack$
  .return -1}
.function_all_flags rwsh.unrecognized_flag -- flag cmd [add_stack ...] {
  echo $flag flag is unrecognized for $cmd
  echo call stack: $cmd $add_stack$}
.function_all_flags rwsh.unused_before_set -- var [stack ...] {
  echo attempt to set $var before making use of its initial value
  echo call stack $stack$}
.function_all_flags rwsh.unused_variable -- var [stack ...] {
  echo $var was unused with call stack $stack$}
.function_all_flags rwsh.version_incompatible version stack ... {
  echo this shell is not compatible with requested version $version
  echo call stack: $stack$}

# ability of functions to act as builtin wrappers
.function_all_flags ! args ... {.if $args$ {.return 1}; .else {.return 0}}
.function_all_flags af -- [argv ...] {rwsh.argfunction}
.function_all_flags c -- text ... {.combine $text$}
.function_all_flags e -- text ... {.echo $text}
.function_all_flags echo -- text ... {.echo $text; .combine $nl}
.function_all_flags echo-comments cmd ... {
  .stepwise $cmd$ {if_only .test_in $1 .nop # #! ## {echo &&&*}}}
.function_all_flags exec -- argv ... {.exec $argv$}
.function_all_flags elif command ... {.else_if $command$ {rwsh.argfunction}}
.function_all_flags else {.else {rwsh.argfunction}}
.function_all_flags fn -- prototype ... {
  .function_all_flags $prototype$ {rwsh.argfunction}}
.function_all_flags fni -- name args ... {
  .function_all_flags $name -- $args$ {rwsh.argfunction}}
.function_all_flags fns -- name args ... {
  .function_all_flags $name [-*] $args$ {rwsh.argfunction}}
.function_all_flags if_only -- args ... {
  .if $args$ {rwsh.argfunction}; .else {.nop}}
.function_all_flags if_only_not -- args ... {
  .if $args$ {.nop}; .else {rwsh.argfunction}}
fn ntimes n {
  .while test_var_greater n 0 {
    rwsh.mapped_argfunction {rwsh.argfunction}
    .var_subtract n 1}}
.function_all_flags setf var value {
  .if .var_exists $var {.set $var $value}
  .else {.global $var $value}}
fn single -- args ... {.scope ${$args$}$ result {echo $result}}
fn test_var_not_equal var value {.test_string_unequal $$var $value}
fn test_var_greater -- var value {.test_greater $$var $value}
fn type [-t] args ... {
  .for $args$ {
    .try_catch_recursive rwsh.function_not_found {
      if_only_not .var_exists -t {.echo &&&1 is ()}
      .combine &&&&{.type &&&1 {rwsh.argfunction}} $nl}}}
fn whence command {
  .try_catch_recursive rwsh.function_not_found {
    .combine ${.whence_function $command {rwsh.argfunction}} $nl}}
fn whichp binary {.which_path $binary $PATH}
.function_all_flags var_exists -- var {.var_exists $var}
.function_all_flags var_val -- [var ...] {
  .if .var_exists var {.for $var$ {.combine $1 \( $$1 \) \ }}
  .else {.nop}}
.function_all_flags paren_if_words -- value {
  .if .test_number_equal ${.argc $value$} 1 {.combine $value}
  .else {.combine \( $value \)}}
fn polish -- operator builtin {
  fn &&operator -- lhs rhs ... {
    if_only .test_in $lhs + - / {
      .scope ${$lhs $rhs$}$ (-- l r ...) {
        .set lhs $l
        .set rhs $r}}
    .scope $rhs$ (rhs [extra ...]) {
      .if .test_in $rhs + - / {
        .scope ${$rhs $extra$}$ (rhs [extra ...]) {
          &&builtin lhs $rhs
          echo $lhs $extra$}}
      .else {
        &&builtin lhs $rhs
        echo $lhs $extra$}}}}
polish - .var_subtract
polish + .var_add
polish / .var_divide
.else_if .test_string_equal $2 -c {
  .for ${.list_environment}$ {
    .scope $1$ (-- var val) {
      .global $var $val
      .nop $$var}}
  .source /etc/rwshrc-basic
  .function_all_flags rwsh.if_before_else stack ... {.nop $stack}
  .function_all_flags rwsh.shutdown -- args ... {.nop $args; .return 0}
  .collect_errors_except .nop {
    rwsh.mapped_argfunction &3 {$1$}
    .exit}}
.else {
  .echo unexpected command line: &* (
)
  .source /etc/rwshrc-default}
$.function_all_flags a [-*] [-x b ...] c {
  .for &&{.list_locals}$ {.combine $1 \( $$1 \) \ }}

0
$.nop $A $FIGNORE

0
$.whence_function a
.function_all_flags a [-?] [-x b ...] c {
  .for &{.list_locals}$ {.combine $1 \( $$1 \) ( )}}
0
$a first
-*() -?() c(first) 
0
$a -x first
unacceptable arguments: for prototype [-?] [-x b ...] c,
 assigned -*=(-x first) -?=() -x=(-x first) b=first ,
 but needed (c),
( call) stack: a

-1
$a -x (fi rst) second
-*(-x (fi rst)) -?() -x(-x (fi rst)) b((fi rst)) c(second) 
0
$a -x first (sec ond) third
-*(-x first (sec ond)) -?() -x(-x first (sec ond)) b(first (sec ond)) c(third) 
0
$a -x (fi rst) (sec ond) third fourth
-*(-x (fi rst) (sec ond) third) -?() -x(-x (fi rst) (sec ond) third) b((fi rst) (sec ond) third) c(fourth) 
0
$.function_all_flags a [-*] [-x ... b] c {
  .for &&{.list_locals}$ {.combine $1 \( $$1 \) \ }
  .combine $nl
  # if_only .test_not_empty $-* {c (-*: ) $-*$ $nl}
  # if_only .var_exists -x {c (-x: ) $-x$ $nl}
  # if_only .var_exists b {c (b: ) $b$ $nl}
  # if_only .var_exists c {c (c: ) $c$ $nl}
}

0
$.whence_function a
.function_all_flags a [-?] [-x ... b] c {
  .for &{.list_locals}$ {.combine $1 \( $$1 \) ( )}
  .combine $nl
  # if_only .test_not_empty $-* {c (-*: ) $-*$ $nl}
  # if_only .var_exists -x {c (-x: ) $-x$ $nl}
  # if_only .var_exists b {c (b: ) $b$ $nl}
  # if_only .var_exists c {c (c: ) $c$ $nl}
}
0
$a first
-*() -?() c(first) 

0
$a -x first
unacceptable arguments: for prototype [-?] [-x ... b] c,
 assigned -*=(-x first) -?=() -x=(-x first) b=first ,
 but needed (c),
( call) stack: a

-1
$a -x (fi rst) second
-*(-x (fi rst)) -?() -x(-x (fi rst)) b((fi rst)) c(second) 

0
$a -x first (sec ond) third
-*(-x first (sec ond)) -?() -x(-x first (sec ond)) b((sec ond)) c(third) 

0
$a -x (fi rst) (sec ond) third fourth
-*(-x (fi rst) (sec ond) third) -?() -x(-x (fi rst) (sec ond) third) b(third) c(fourth) 

0
$
now terminating normally
