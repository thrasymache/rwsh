signal triggered: rwsh.raw_command ( .function rwsh.raw_command {.echo $1; .echo $nl} ) 
.global last_command_return -10
.global A \
.global N \
.nop $N

.nop tests multi-line commands within a sourced script
.nop .function rwsh.run_logic {
  .return $last_command_return
  .signal_handler &{.internal_functions}$ {&&* {rwsh.argfunction}}
  rwsh.mapped_argfunction {&&* {rwsh.argfunction}}
  &&* {rwsh.argfunction}
  .set last_command_return $?
  .echo $nl
  .echo $last_command_return
  .echo $nl}
.function rwsh.before_command {.return $last_command_return}
.function rwsh.after_command {
  .set last_command_return $?
  .echo $nl; .echo $last_command_return; .echo $nl}
.function rwsh.prompt {.echo \$}
.function rwsh.shutdown {.echo $nl; .echo now terminating normally; .echo $nl}
.function rwsh.vars {.internal_vars}
.else_if .test_string_equal $2 -c {
  .function rwsh.autofunction {
    .function $1 {&&&{.which_path &&&1 $PATH} $*}}
  .function rwsh.if_before_else {}
  .function rwsh.shutdown {.nop}
  .for ${.list_environment}$ {
    .scope $1$ (var val) {
      .global $var $val
      .nop $$var}}
  .source /etc/rwshrc-basic
  rwsh.mapped_argfunction &3 {$1$}
  .exit}
.else {
  .echo unexpected command line: &* (
)
  .source /etc/rwshrc-default}
rwsh.help not defined 
$/bin/cat /tmp/lcl
/etc/rwshrc ./rwsh test_init.sh 

0
$.nop .init is tested by having test_init.sh define rwsh.before_command etc.

0
$.source /etc/rwshrc-basic
.function_all_flags # -- [ignored ...] {
  .local ret $?
  .if .var_exists ignored {.nop $ignored}
  .else {.nop}
  .nop $ret $?
  .return 0
  .return $ret}
.function_all_flags #! -- [ignored ...] {# $ignored}

# set up environment
.global nl (
)

# internal functions
.function rwsh.unused_variable {echo $1 was unused with call stack $*2}
.function rwsh.unchecked_variable {echo $1 was not checked with call stack $*2}

# ability of functions to act as builtin wrappers
.function_all_flags af -- [argv ...] {rwsh.argfunction}
.function_all_flags c -- text ... {.combine $text$}
.function_all_flags e -- text ... {.echo $text}
.function_all_flags echo -- text ... {.echo $text $nl}
.function_all_flags elif command ... {.else_if $command$ {rwsh.argfunction}}
.function_all_flags else {.else {rwsh.argfunction}}
.function_all_flags fn -- prototype ... {
  .function_all_flags $prototype$ {rwsh.argfunction}
  .local ret $?
  .if .test_number_equal $ret 1 {echo cannot set paths as functions}
  .else_if .test_number_equal $ret 2 {echo cannot set builtins as functions}
  .else_if .test_number_equal $ret 3 {echo cannot set argfunctions in executable map}
  .else_if .test_number_equal $ret 4 {echo function &&1 did not exist to be erased}
  .else {.return $ret}}
.function_all_flags fni -- name args ... {
  .function_all_flags $name -- $args$ {rwsh.argfunction}
  .local ret $?
  .if .test_number_equal $ret 1 {echo cannot set paths as functions}
  .else_if .test_number_equal $ret 2 {echo cannot set builtins as functions}
  .else_if .test_number_equal $ret 3 {echo cannot set argfunctions in executable map}
  .else_if .test_number_equal $ret 4 {echo function &&1 did not exist to be erased}
  .else {.return $ret}}
.function_all_flags fns -- name args ... {
  .function_all_flags $name [-*] $args$ {rwsh.argfunction}
  .local ret $?
  .if .test_number_equal $ret 1 {echo cannot set paths as functions}
  .else_if .test_number_equal $ret 2 {echo cannot set builtins as functions}
  .else_if .test_number_equal $ret 3 {echo cannot set argfunctions in executable map}
  .else_if .test_number_equal $ret 4 {echo function &&1 did not exist to be erased}
  .else {.return $ret}}
.function_all_flags iee var {
  .if .var_exists $var {.echo $$var}
  .else {.nop}}
.function_all_flags ien var {
  .if .var_exists $var {.nop $$var}
  .else {.nop}}
.function if {.if $* {rwsh.argfunction}}
.function_all_flags if_only -- args ... {
  .if $args$ {rwsh.argfunction}; .else {.nop}}
.function if_only_not {.if $* {.nop}; .else {rwsh.argfunction}}
.function timings {
  .echo last time (); .which_last_execution_time $*; c $nl
  .echo total time (); .which_total_execution_time $*; c $nl
  .echo execution count (); .which_execution_count $*; c $nl}
.function set {.set $1 $2 $*3}
.function setf {
  .if .var_exists $1 {.set &&1 &&2}
  .else {.global &&1 &&2}}
.function_all_flags set_if_undefined -- var [value] {
  .if .var_exists $var {ien value}
  .else_if .var_exists value {.global $var $value}
  .else {.global $var ()}}
fn test_var_not_equal var value {.test_string_unequal $$var $value}
.function_all_flags test_var_greater -- var value {.test_greater $$var $value}
fn ntimes n {
  .while test_var_greater n 0 {
    rwsh.mapped_argfunction {rwsh.argfunction}
    .var_subtract n 1}}
fn mark {ntimes 4 {.echo ####################}}
.function unset {.unset $1}
fn which command {
  .if .which_test $command {
    .combine ${.which_executable $command {rwsh.argfunction}} $nl}
  .else {echo no $command}}
fn whichp binary {
  .which_path $binary $PATH
  .if .test_number_equal $? 0 {.nop}
  .else {echo &&binary not found in $PATH; .return 1}}
.function while {.while $* {rwsh.argfunction}}
.function_all_flags var_exists -- var {.var_exists $var}
.function_all_flags var_val -- [var ...] {
  .if .var_exists var {.for $var$ {.combine $1 \( $$1 \) \ }}
  .else {.nop}}
.function_all_flags paren_if_words -- value {
  .if .test_number_equal ${.argc $value$} 1 {.combine $value}
  .else {.combine \( $value \)}}
.function_all_flags rwsh.bad_args -- proto assigned needed excess call_stack ... {
  .combine (unacceptable arguments: for prototype ) $proto , $nl
  if_only .test_not_empty $assigned {
    .combine ( assigned )
    .for $assigned$ {.combine $1$0 = ${paren_if_words $1$1} ( )}
    .combine , $nl ( but)}
  if_only .test_not_empty $needed {
    .combine ( needed \() $needed \), $nl
    if_only .test_not_empty $excess {.combine ( and)}}
  if_only .test_not_empty $excess {
    .combine ( found \() $excess (\) excess) $nl}
  .echo \ call stack:  $call_stack $nl
  .return -1}

0
$.function_all_flags ## [args ...] {.nop $args}

0
$

0
$## argm

0
$.nop

0
$     .nop

0
$.nop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

0
$.echo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
0
$.echo  ()    1                2       $#
 1 2 5
0
$.echo \escaped internal\ space $#
escaped internal space 4
0
$.echo now \ external\  $#
now  external  4
0
$.echo a \  space $#
a   space 5
0
$.echo \$tokens \} \{ \; \\ \) \(
$tokens } { ; \ ) (
0
$.echo a \
a 
0
$line continuation
signal triggered: rwsh.executable_not_found ( rwsh.autofunction line continuation ) 
signal triggered: rwsh.executable_not_found ( line continuation ) 

-1
$ .echo ignore leading space
ignore leading space
0
$	.echo ignore leading tab
ignore leading tab
0
$rwsh.mapped_argfunction {	   .echo ignore leading tab in argfunction}
ignore leading tab in argfunction
0
$.which_executable rwsh.mapped_argfunction {.nop}
{.nop}
0
$.which_executable rwsh.argfunction {
  multiple line argfunction }
{
  multiple line argfunction}
0
$.nop rwsh.argfunction rwsh.mismatched_brace } 
signal triggered: rwsh.mismatched_brace ( .nop rwsh.argfunction rwsh.mismatched_brace } ) 

-1
$.source test_files/unclosed_brace_newline.rwsh
fn bar {echo baz

signal triggered: rwsh.mismatched_brace ( fn bar ) 

-1
$.source test_files/unclosed_brace.rwsh
fn bar {echo baz

signal triggered: rwsh.mismatched_brace ( fn bar ) 

-1
$.source test_files/unclosed_parenthesis_newline.rwsh
echo bar (baz

signal triggered: rwsh.mismatched_parenthesis ( echo bar ( ) 

-1
$.source test_files/unclosed_parenthesis.rwsh
echo bar (baz

signal triggered: rwsh.mismatched_parenthesis ( echo bar ( ) 

-1
$.nop multiple statements \; on a line

-1
$.which_executable rwsh.argfunction {rwsh.multiple_argfunctions} {}
signal triggered: rwsh.multiple_argfunctions ( ) 

-1
$.which_executable rwsh.argfunction {rwsh.argfunction with text args}
signal triggered: rwsh.arguments_for_argfunction ( rwsh.argfunction ) 

-1
$.which_executable rwsh.argfunction {rwsh.argfunction {with a function arg}}
signal triggered: rwsh.arguments_for_argfunction ( rwsh.argfunction ) 

-1
$.which_executable rwsh.argfunction {{{{{{{{{{{}}}}}}}}}}}
{{{{{{{{{{{}}}}}}}}}}}
0
$.which_executable rwsh.argfunction {
  .function  x  { ${ .which_path  echo  $PATH }  something } }
{
  .function x { ${ .which_path echo $PATH} something}}
0
$

0
$## ability of functions to perform custom control flow

0
$# rwshrc-basic

0
$.function f {.function $1 {rwsh.argfunction}}

0
$fni w command {.which_executable $command {rwsh.argfunction}}

0
$f e {.echo $*}

0
$f m {rwsh.argfunction}

0
$.which_executable f
.function f {.function $1 {rwsh.argfunction}}
0
$.which_executable w
.function_all_flags w -- command {.which_executable $command {rwsh.argfunction}}
0
$.which_executable e
.function e {.echo $*}
0
$.which_executable m
.function m {rwsh.argfunction}
0
$which e
.function e {.echo $*}

0
$which ee
no ee 

0
$which () {}
.function () {.nop}

0
$e text that does not have a prompt appended
text that does not have a prompt appended
0
$m {e again}
again
0
$if_only .return 1 {e not printed}

0
$if_only .return 0 {e printed without error}
printed without error
0
$.function for {
  .if .test_greater $# 1 {.for &&*1$ {rwsh.argfunction}}; .else {.nop}}

0
$for {e skipped without error}

0
$for 1 2 3 {e loop $* $nl}
loop 1 
loop 2 
loop 3 

0
$

0
$## arg_script.cc and arg_spec.cc

0
$# Arg_spec::FIXED, Arg_script::add_quote

0
$e 5 4 3 2 1
5 4 3 2 1
0
$e a (tight string created by parentheses $#) $#
a tight string created by parentheses $# 4
0
$e a ( spaced string created by parentheses $# ) $#
a  spaced string created by parentheses $#  4
0
$e some escaped \) \(parentheses $#
some escaped ) (parentheses 6
0
$e some (nested (parentheses) $#) $#
some nested (parentheses) $# 4
0
$e some ((((((((((repeated))))) parentheses))))) $#
some (((((((((repeated))))) parentheses)))) 4
0
$e a (multi-line parenthesis
  enclosed string) $#
a multi-line parenthesis
  enclosed string 4
0
$e a )mismatched parenthesis
signal triggered: rwsh.mismatched_parenthesis ( e a ) ) 

-1
$e a (multi-line parenthesis
  mismatch))
signal triggered: rwsh.mismatched_parenthesis ( e a (multi-line parenthesis
  mismatch)) ) 

-1
$e (internal \)parenthesis \\ escape ( \))) $#
internal )parenthesis \ escape ( )) 3
0
$

0
$# star_var (argm_star_var)

0
$e 1 2 $* 3 4
1 2 1 2 $* 3 4 3 4
0
$e $*2 1 2
1 2 1 2
0
$

0
$# star_soon

0
$.if .nop 1 2 3 {e &*}
.nop 1 2 3
0
$.else {}

0
$.if .nop 1 2 3 {e &*0}
.if .nop 1 2 3
0
$.else {}

0
$

0
$# selection_read read_dir()

0
$e @/etc
/etc
0
$e @test_files/i*xx
test_files/ixxx
0
$e @test_files/i*xx/f*
signal triggered: rwsh.unreadable_dir ( test_files/ixxx// 20 ) 

-1
$e @/*selection_not_found*
signal triggered: rwsh.selection_not_found ( /*selection_not_found* /*selection_not_found* ) 

-1
$e @test_main.cc
signal triggered: rwsh.selection_not_found ( test_main.cc test_main.cc ) 

-1
$m {m {.for @e*c {e $1 $nl}} >test_files/tmp}

0
$.global LC_ALL C

0
$.nop $LC_ALL

0
$f sort {&{.which_path sort /bin:/usr/bin} $*}

0
$sort test_files/tmp
executable.cc 
executable_map.cc 

0
$e @test_files/*xx
test_files/ixxx
0
$e @test_files/*x*x*x*x
signal triggered: rwsh.selection_not_found ( test_files/*x*x*x*x test_files/*x*x*x*x ) 

-1
$e @test_files/*xyxy
test_files/ixyxyxy
0
$e @/bin
/bin
0
$m {m {.for @/usr/*bin {e $1 $nl}} >test_files/tmp}

0
$sort test_files/tmp
/usr/bin 
/usr/sbin 

0
$m {m {.for @/etc/rwsh* {e $1 $nl}} >test_files/tmp}

0
$sort test_files/tmp
/etc/rwshrc 
/etc/rwshrc-basic 
/etc/rwshrc-default 

0
$e @/etc/rw*ic
/etc/rwshrc-basic
0
$e @/etc/rwsh*a*
/etc/rwshrc-basic /etc/rwshrc-default
0
$.set FIGNORE *de*

0
$e @/etc/rwsh*a*
/etc/rwshrc-basic
0
$e @test_files/*i*x*y*y*x*
test_files/ixyxyxy
0
$e @test_main.sh
test_main.sh
0
$m {m {.for @test_files/*x* {e $1 $nl}} >test_files/tmp}

0
$sort test_files/tmp
test_files/ixxx 
test_files/ixyxyxy 

0
$.scope r*h.cc sel*.h (A ...) {e @$A}
rwsh.cc selection.h
0
$

0
$# Arg_spec::REFERENCE, interpret(), evaluate_expansion(), evaluate_var()

0
$.set A /bin

0
$.global B ((zero zero) ((one one) one) two three)

0
$e $A $0 @$A
/bin e /bin
0
$e A $1 1 $$3 $$$3
A A 1 A /bin
0
$e A 1 2 3 4 5 6 7 $$$$$$$$$8
A 1 2 3 4 5 6 7 /bin
0
$m $FOO {}
signal triggered: rwsh.undefined_variable ( FOO ) 

-1
$m {e $FOO}
signal triggered: rwsh.undefined_variable ( FOO rwsh.mapped_argfunction m ) 

-1
$m $B$$1x {e $# $*}
signal triggered: rwsh.invalid_word_selection ( $$1x ) 

-1
$m $B$$1$ {e $# $*}
signal triggered: rwsh.invalid_word_selection ( $$1$ ) 

-1
$m $B {e $# $*}
2 (zero zero) ((one one) one) two three
0
$m $B$ {e $# $*}
5 zero zero (one one) one two three
0
$m $B$$ {e $# $*}
7 zero zero one one one two three
0
$m $B$$$$ {e $# $*}
8 zero zero one one one two three
0
$m {m $B$$$$ {e $# $*}}
8 zero zero one one one two three
0
$m $B$10 {e $# $*}
signal triggered: rwsh.undefined_variable ( $B$10 ) 

-1
$m $B$1 {e $# $*}
2 (one one) one
0
$m $B$$1 {e $# $*}
2 zero
0
$

0
$# Arg_spec::SOON, apply()

0
$e A &1 1 &$3 &$$3
A A 1 A /bin
0
$e &&A
signal triggered: rwsh.not_soon_enough ( &&A ) 

-1
$m {e &&&A}
signal triggered: rwsh.not_soon_enough ( &&&A ) 

-1
$e &{e &&A}
signal triggered: rwsh.not_soon_enough ( &&A ) 

-1
$e &&{e &A}
signal triggered: rwsh.not_soon_enough ( &&{e &A} ) 

-1
$e &A
/bin
0
$.scope not_bin A {e &A &&A $A $nl; .scope otherwise A {e &A &&A &&&A $A}}
/bin not_bin not_bin 
/bin not_bin otherwise otherwise
0
$m {m &B$10 {e $# $*}}
signal triggered: rwsh.undefined_variable ( &B$10 ) 

-1
$m {m &B$$$$ {e $# $*}}
8 zero zero one one one two three
0
$m {m &B$1 {e $# $*}}
2 (one one) one
0
$m {m &B$$1 {e $# $*}}
2 zero
0
$

0
$# Arg_spec::SUBSTITUTION and Arg_spec::SOON_SUBSTITUTION, apply(), interpret(),

0
$# evaluate_substitution()

0
$e ${e $A}
/bin
0
$w rwsh.argfunction {e ${e $A}}
{e ${e $A}}
0
$.scope not_bin A {
   e &{.echo $A} &&{.echo $A} $A $nl
   .scope otherwise A {
      e &{.echo $A} &&{.echo $A} &&&{.echo $A} ${.echo $A} $A}}
/bin not_bin not_bin 
/bin not_bin otherwise otherwise otherwise
0
$.scope not_bin A {e &{.echo &A $A} &&{.echo &A &&A} ${.echo &A $A}}
/bin /bin /bin not_bin /bin not_bin
0
$m &{.echo $A} {e $1 &1}
/bin &{.echo $A}
0
$m &{.return 1} {}
signal triggered: rwsh.failed_substitution ( &{.return 1} ) 

-1
$m ${.return 1} {}
signal triggered: rwsh.failed_substitution ( ${.return 1} ) 

-1
$m {e &{.return 1}}
signal triggered: rwsh.failed_substitution ( &{.return 1} ) 

-1
$m {e &&{.return 1}; e after}
signal triggered: rwsh.failed_substitution ( &{.return 1} rwsh.mapped_argfunction m ) 

-1
$f rwsh.failed_substitution {e $Z}

0
$.throw m {echo even from $* 7 is a number}
even from .throw 7 is a number 

-1
$.fallback_handler m {echo even from $* 7 is a number}
Exception for failed handler. Original exception with call stack:
m

0
$.throw rwsh.failed_substitution m {echo even from $* 7 is a number}
Exception for failed handler. Original exception with call stack:
rwsh.failed_substitution m .throw
signal triggered: rwsh.undefined_variable ( Z rwsh.failed_substitution ) 

-1
$m {e &&{.return 1}; e after}
Exception for failed handler. Original exception with call stack:
rwsh.failed_substitution &{.return 1} rwsh.mapped_argfunction m
signal triggered: rwsh.undefined_variable ( Z rwsh.failed_substitution ) 

-1
$f rwsh.failed_substitution {.echo signal triggered: $0 \( $* \) $nl; .return -1}

0
$e x{e bad argfunction style}
signal triggered: rwsh.bad_argfunction_style ( x ) 

-1
$e x&&&{e x}
signal triggered: rwsh.bad_argfunction_style ( x&&& ) 

-1
$e $+{e x}
signal triggered: rwsh.bad_argfunction_style ( $+ ) 

-1
$e &+{e x}
signal triggered: rwsh.bad_argfunction_style ( &+ ) 

-1
$e &&${e x}
signal triggered: rwsh.bad_argfunction_style ( &&$ ) 

-1
$.return &{.return 0}
signal triggered: rwsh.not_a_number (  .return ) 

-1
$.return ${e 0 $nl}
signal triggered: rwsh.not_a_number ( 0 
 .return ) 

-1
$.return &{.echo 0}

0
$e nevermore &{/bin/echo quoth the raven} 
nevermore quoth the raven

0
$m ${e $B}@ {e $# $*}
signal triggered: rwsh.invalid_word_selection ( @ ) 

-1
$m ${e $B} {e $# $*}
2 (zero zero) ((one one) one) two three
0
$m &{e $B} {e $# $*}
2 (zero zero) ((one one) one) two three
0
$m ${e $B}$ {e $# $*}
5 zero zero (one one) one two three
0
$m &{e $B}$ {e $# $*}
5 zero zero (one one) one two three
0
$e $# &{e $B}$
3 zero zero (one one) one two three
0
$m {e $# &{e $B}$}
1 zero zero (one one) one two three
0
$m &{e $B}$$ {e $# $*}
7 zero zero one one one two three
0
$m ${e $B}$$ {e $# $*}
7 zero zero one one one two three
0
$m {m ${e $B}$1 {e $# $*}}
2 (one one) one
0
$m {m &{e $B}$1 {e $# $*}}
2 (one one) one
0
$m {m ${e $B}$$$1 {e $# $*}}
2 zero
0
$m {m &{e $B}$$$1 {e $# $*}}
2 zero
0
$.unset A

0
$.unset B

0
$m &{e ((zero zero) (one one) two three)}$10 {e $# $*}
signal triggered: rwsh.undefined_variable ( &{e ((zero zero) (one one) two three)}$10 ) 

-1
$m ${e (zero zero) \)one one two three}$1 {e $# $*}
signal triggered: rwsh.mismatched_parenthesis ( zero zero ) ) 

-1
$m &{e (zero zero) \(one one two three}$1 {e $# $*}
signal triggered: rwsh.mismatched_parenthesis ( zero zero (one one two three ) 

-1
$m ${e (zero zero) \)one one two three} {e $# $*}
2 zero zero )one one two three
0
$c x &{.echo (y y)}$ x
xyyx
0
$c x ${.echo ( y y )}$ x
xyyx
0
$c x &{.echo (( y) (y ))}$ x
x yy x
0
$c x ${.echo (    )}$ x
xx
0
$c x &{.echo (
y
y
)}$ x
xyyx
0
$

0
$# file redirection (but don't overwrite files that exist)

0
$# .for_each_line

0
$.if .ls dummy_file {.exit}

0
$.else {}

0
$/bin/cat <dummy_file
signal triggered: rwsh.file_open_failure ( dummy_file /bin/cat ) 

-1
$.for_each_line <dummy_file {e line of $# \( $* \)}
signal triggered: rwsh.file_open_failure ( dummy_file .for_each_line ) 

-1
$m {e hi >dummy_file >another}
signal triggered: rwsh.double_redirection ( >dummy_file >another ) 

-1
$m {e hi >dummy_file}

0
$/bin/cat dummy_file
hi
0
$.if .return 0 {>dummy_file /bin/echo there}

0
$.else {.nop}

0
$/bin/cat dummy_file
there

0
$m {m >dummy_file {e line 1 $nl; e line 2 longer $nl; .echo $nl; e ending}}

0
$/bin/cat <dummy_file
line 1 
line 2 longer 

ending
0
$.for_each_line x {}
signal triggered: rwsh.bad_argc ( 1 0 0 .for_each_line ) 

-1
$.for_each_line <dummy_file
signal triggered: rwsh.missing_argfunction ( .for_each_line ) 

-1
$.for_each_line <dummy_file <another {}
signal triggered: rwsh.double_redirection ( <dummy_file <another ) 

-1
$.for_each_line <dummy_file {e line of $# \( $* \) $nl}
line of 3 ( line 1 ) 
line of 4 ( line 2 longer ) 
line of 1 ( ) 
line of 2 ( ending ) 

0
$/bin/rm dummy_file

0
$

0
$# soon level promotion

0
$.global A 0

0
$.global OLD_NESTING ${.get_max_nesting}

0
$.set_max_nesting 46

0
$f x {.var_add A 1
     m {.var_add A 1
        m {.var_add A 1
           m {.var_add A 1
              m {.var_add A 1
                 m {rwsh.argfunction}}}}}}

0
$.scope 00 A {x {e &A &&A &&&A $A}}
0 00 5 5
0
$.scope 00 A {x {x {x {x {e &A &&A &&&A &&&&A &&&&&A &&&&&&A $A}}}}}
0 00 5 10 15 20 20
0
$.scope 00 A {
  x {e &{.echo &A $A} . &&{.echo &A &&A $A} . &&&{.echo &A &&A &&&A $A} . ${
  .echo &A &&A &&&A $A} . $A}}
0 0 . 0 00 00 . 0 00 5 5 . 0 00 5 5 . 5
0
$.set A 0

0
$x {x {x {x {
  e &{.echo &A $A} . &&{.echo &A &&A $A} . &&&{.echo &A &&A &&&A $A} . &&&&{
  .echo &A &&A &&&A &&&&A $A} . &&&&&{.echo &A &&A &&&A &&&&A &&&&&A $A} . ${
  .echo &A &&A &&&A &&&&A &&&&&A $A} . $A}}}}
0 0 . 0 5 5 . 0 5 10 10 . 0 5 10 15 15 . 0 5 10 15 20 20 . 0 5 10 15 20 20 . 20
0
$f x

0
$.set_max_nesting $OLD_NESTING

0
$.unset A

0
$.unset OLD_NESTING

0
$

0
$## builtin tests

0
$# .argc

0
$.argc {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .argc ) 

-1
$.argc
0
0
$.argc ()
1
0
$.argc (1 a) (2 b (c d)) (3 ((e () f)))
3
0
$

0
$# .cd

0
$.cd
signal triggered: rwsh.bad_argc ( 0 1 0 .cd ) 

-1
$.cd /bin {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .cd ) 

-1
$.cd /bin /
signal triggered: rwsh.bad_argc ( 2 1 0 .cd ) 

-1
$.cd /bin

0
$/bin/pwd
/bin

0
$

0
$# .combine

0
$.combine
signal triggered: rwsh.bad_argc ( 0 1 0 .combine ) 

-1
$.combine something {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .combine ) 

-1
$.combine on () e \ two ( ) $#
one two 7
0
$

0
$# .echo

0
$.echo
signal triggered: rwsh.bad_argc ( 0 1 0 .echo ) 

-1
$.echo something {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .echo ) 

-1
$.echo these are fixed strings
these are fixed strings
0
$

0
$# .exec .fork

0
$.fork
signal triggered: rwsh.bad_argc ( 0 1 0 .fork ) 

-1
$.fork e text
text
0
$.fork .return 1

256
$.exec
signal triggered: rwsh.bad_argc ( 0 1 0 .exec ) 

-1
$.exec something {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .exec ) 

-1
$.fork m {.exec /bin/echo something; /bin/echo else}
something

0
$

0
$# .fallback_handler .get_fallback_message .set_fallback_message

0
$.fallback_handler
signal triggered: rwsh.bad_argc ( 0 1 0 .fallback_handler ) 

-1
$.fallback_handler something {excess argfunc}
Exception for failed handler. Original exception with call stack:
something

0
$.get_fallback_message something 
signal triggered: rwsh.bad_argc ( 1 0 0 .get_fallback_message ) 

-1
$.get_fallback_message {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .get_fallback_message ) 

-1
$.set_fallback_message
signal triggered: rwsh.bad_argc ( 0 1 0 .set_fallback_message ) 

-1
$.set_fallback_message something {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .set_fallback_message ) 

-1
$.fallback_handler pretend_error
Exception for failed handler. Original exception with call stack:
pretend_error

0
$.local original_message &{.get_fallback_message}

0
$.set_fallback_message spaceless fallback message

0
$.fallback_handler second pretend error
spaceless fallback messagesecond pretend error

0
$.set_fallback_message (alternate fallback message: )

0
$.fallback_handler a third
alternate fallback message: a third

0
$.set_fallback_message $original_message

0
$

0
$# .for

0
$.for {e no arguments $1}
signal triggered: rwsh.bad_argc ( 0 1 0 .for ) 

-1
$.for no_argfunction
signal triggered: rwsh.missing_argfunction ( .for ) 

-1
$.for 1 {e one argument $1}
one argument 1
0
$.for 1 2 3 4 {e four arguments $1 $nl}
four arguments 1 
four arguments 2 
four arguments 3 
four arguments 4 

0
$

0
$# .function

0
$.function
signal triggered: rwsh.bad_argc ( 0 1 0 .function ) 

-1
$.function /bin/echo {.echo $* $nl}

1
$.function .exit {.nop}

2
$.function rwsh.escaped_argfunction {.nop}

3
$.function a

4
$.function a {.nop}

0
$.which_executable a
.function a {.nop}
0
$a 1 2 3

0
$.function a

0
$.which_executable a

1
$.global A \

0
$.echo () A () A () $#
 A  A  7
0
$.function a {e 9 $A $1 @/usr}

0
$.which_executable a
.function a {e 9 $A $1 @/usr}
0
$a \
9   /usr
0
$a 1
9  1 /usr
0
$a 1 2
9  1 /usr
0
$.function a {e $*5 $* $*0 $nl}

0
$a
a 

0
$a 1
1 a 1 

0
$a 1 2
1 2 a 1 2 

0
$f g {.function $1 {.function $1 {rwsh.argfunction}}}

0
$g a {e 3 2 1 $nl}

0
$w a
.function a {.function $1 {e 3 2 1 $nl}}
0
$a b

0
$b
3 2 1 

0
$# a function redefining itself doesn't seg fault

0
$f g {e hi $nl; f g {e there $nl}; f h {e nothing here}; g}

0
$g
hi 
there 

0
$

0
$# .function_all_flags

0
$.function_all_flags
signal triggered: rwsh.bad_argc ( 0 1 0 .function_all_flags ) 

-1
$.function_all_flags /bin/echo {e cannot define a path to be a function}

1
$.function_all_flags .exit {e cannot redefine a builtin as a function}

2
$.function_all_flags .a {can define a function for non-existant builtin}

0
$.function_all_flags rwsh.argfunction {e cannot define rwsh.argfunction}

3
$.function_all_flags a y y {e illegal duplicate required parameter}
signal triggered: rwsh.duplicate_parameter ( y .function_all_flags ) 

-1
$.function_all_flags a [-x] [-x] {e illegal duplicate flag parameter}
signal triggered: rwsh.duplicate_parameter ( -x .function_all_flags ) 

-1
$.function_all_flags a [x x] {e illegal duplicate optional parameter}
signal triggered: rwsh.duplicate_parameter ( x .function_all_flags ) 

-1
$.function_all_flags a [-x arg bar] [-y arg] {e illegal duplicate flag argument}
signal triggered: rwsh.duplicate_parameter ( arg .function_all_flags ) 

-1
$.function_all_flags a -x [-x] {e evil duplication between flags positional}
signal triggered: rwsh.duplicate_parameter ( -x .function_all_flags ) 

-1
$.function_all_flags a -- -- {e -- cannot be a duplicate parameter}
signal triggered: rwsh.duplicate_parameter ( -- .function_all_flags ) 

-1
$.function_all_flags a [--] [--] {e [--] cannot be a duplicate parameter}
signal triggered: rwsh.duplicate_parameter ( -- .function_all_flags ) 

-1
$.function_all_flags a [--] -- {e -- and [--] cannot both be parameters}
signal triggered: rwsh.duplicate_parameter ( -- .function_all_flags ) 

-1
$.function_all_flags a [-- arg] {e -- cannot take arguments}
signal triggered: rwsh.dash_dash_argument ( [-- arg] .function_all_flags ) 

-1
$.function_all_flags a [arg -- foo] {e -- cannot take arguments}
signal triggered: rwsh.dash_dash_argument ( [arg -- foo] .function_all_flags ) 

-1
$.function_all_flags nonsense

4
$w test_var_greater
.function_all_flags test_var_greater -- var value {.test_greater $$var $value}
0
$.scope 5 n {test_var_greater n}
unacceptable arguments: for prototype -- var value,
 assigned var=n ,
 but needed (value),
 call stack: test_var_greater .scope 
n was unused with call stack .scope 

-1
$.scope 5 n {test_var_greater n 3 12}
unacceptable arguments: for prototype -- var value,
 assigned value=3 var=n ,
 but found (12) excess
 call stack: test_var_greater .scope 
n was unused with call stack .scope 

-1
$.scope 5 n {test_var_greater n 3}

0
$w ntimes
.function_all_flags ntimes n {
  .while test_var_greater n 0 {
    rwsh.mapped_argfunction {rwsh.argfunction}
    .var_subtract n 1}}
0
$ntimes -- 3 {e $n remaining $nl}
3 remaining 
2 remaining 
1 remaining 

0
$ntimes 2 {ntimes 3 {e &&n and $n remaining $nl}}
2 and 3 remaining 
2 and 2 remaining 
2 and 1 remaining 
1 and 3 remaining 
1 and 2 remaining 
1 and 1 remaining 

0
$.function_all_flags a [-x] [-] [--long-opt y second {
  e mismatched bracket (i.e. missing close brakcet)}
signal triggered: rwsh.mismatched_bracket ( [--long-opt y second .function_all_flags ) 

-1
$.function_all_flags a [-?] [--] {.list_locals}
signal triggered: rwsh.ambiguous_prototype_dash_dash ( [-?] [--] .function_all_flags ) 

-1
$.function_all_flags a [-x] [--] foo {.list_locals}
signal triggered: rwsh.ambiguous_prototype_dash_dash ( [-x] [--] .function_all_flags ) 

-1
$.function_all_flags a [-?] -- foo {.list_locals}
signal triggered: rwsh.ambiguous_prototype_dash_dash ( [-?] -- .function_all_flags ) 

-1
$.function_all_flags a [-x] -- {.list_locals}
signal triggered: rwsh.ambiguous_prototype_dash_dash ( [-x] -- .function_all_flags ) 

-1
$.function_all_flags a [--] {.list_locals}

0
$w a
.function_all_flags a [--] {.list_locals}
0
$a

0
$a --
--
0
$a foo
unacceptable arguments: for prototype [--],
 found (foo) excess
 call stack: a 

-1
$.function_all_flags a [-x] [--long-opt y] second {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }}

0
$w a
.function_all_flags a [--long-opt y] [-x] second {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}}
0
$a
unacceptable arguments: for prototype [--long-opt y] [-x] second,
 assigned -*=() ,
 but needed (second),
 call stack: a 

-1
$a single
-*() second(single) 
0
$a -x single
-*(-x) -x(-x) second(single) 
0
$a --long-opt arg single
-*(--long-opt arg) --long-opt(--long-opt arg) second(single) y(arg) 
0
$a --long-opt single
unacceptable arguments: for prototype [--long-opt y] [-x] second,
 assigned -*=(--long-opt single) --long-opt=(--long-opt single) y=single ,
 but needed (second),
 call stack: a 

-1
$a --long-opt first -x --long-opt second single
-*(--long-opt first -x --long-opt second) --long-opt(--long-opt first --long-opt second) -x(-x) second(single) y(first second) 
0
$.function_all_flags a [-q option1 option2] [-x o1 o2 o3 o4] required {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }}

0
$w a
.function_all_flags a [-q option1 option2] [-x o1 o2 o3 o4] required {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}}
0
$a
unacceptable arguments: for prototype [-q option1 option2] [-x o1 o2 o3 o4] required,
 assigned -*=() ,
 but needed (required),
 call stack: a 

-1
$a single
-*() required(single) 
0
$a -q one two
unacceptable arguments: for prototype [-q option1 option2] [-x o1 o2 o3 o4] required,
 assigned -*=(-q one two) -q=(-q one two) option1=one option2=two ,
 but needed (required),
 call stack: a 

-1
$a -q opt and req
-*(-q opt and) -q(-q opt and) option1(opt) option2(and) required(req) 
0
$a -x opt and
unacceptable arguments: for prototype [-q option1 option2] [-x o1 o2 o3 o4] required,
 assigned -*=(-x opt and) -x=(-x opt and) o1=opt o2=and ,
 but needed (o3 o4 required),
 call stack: a 

-1
$a -x first second third fourth req
-*(-x first second third fourth) -x(-x first second third fourth) o1(first) o2(second) o3(third) o4(fourth) required(req) 
0
$a -q one two -q three four five
-*(-q one two -q three four) -q(-q one two -q three four) option1(one three) option2(two four) required(five) 
0
$a -x one two three four -q five six seven
-*(-x one two three four -q five six) -q(-q five six) -x(-x one two three four) o1(one) o2(two) o3(three) o4(four) option1(five) option2(six) required(seven) 
0
$a -x one two three four five -q six seven
-*(-x one two three four -q six seven) -q(-q six seven) -x(-x one two three four) o1(one) o2(two) o3(three) o4(four) option1(six) option2(seven) required(five) 
0
$a one -x two three four five -q six seven
-*(-x two three four five -q six seven) -q(-q six seven) -x(-x two three four five) o1(two) o2(three) o3(four) o4(five) option1(six) option2(seven) required(one) 
0
$.function_all_flags a [optional0] -- [optional1 optional2 optional3] required {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }}

0
$w a
.function_all_flags a [optional0] -- [optional1 optional2 optional3] required {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}}
0
$a
unacceptable arguments: for prototype [optional0] -- [optional1 optional2 optional3] required,
 needed (required),
 call stack: a 

-1
$a single
required(single) 
0
$a one two
optional0(one) required(two) 
0
$a one two three
unacceptable arguments: for prototype [optional0] -- [optional1 optional2 optional3] required,
 assigned optional0=one optional1=two optional2=three ,
 but needed (optional3 required),
 call stack: a 

-1
$a one two three four five
optional0(one) optional1(two) optional2(three) optional3(four) required(five) 
0
$a one two three four five six seven eight nine
unacceptable arguments: for prototype [optional0] -- [optional1 optional2 optional3] required,
 assigned optional0=one optional1=two optional2=three optional3=four required=five ,
 but found (six seven eight nine) excess
 call stack: a 

-1
$.function_all_flags a -y [second] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }}

0
$w a
.function_all_flags a -y [second] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}}
0
$a
unacceptable arguments: for prototype -y [second],
 needed (-y),
 call stack: a 

-1
$a 1
-y(1) 
0
$a 1 2
-y(1) second(2) 
0
$a 1 2 3
unacceptable arguments: for prototype -y [second],
 assigned -y=1 second=2 ,
 but found (3) excess
 call stack: a 

-1
$.function_all_flags a [-x] -y [--long-opt] second [--] [-] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }}

0
$w a
.function_all_flags a [--long-opt] [-x] -y second [--] [-] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}}
0
$a --long-opt -xx over-long flag
signal triggered: rwsh.unrecognized_flag ( -xx a ) 

-1
$a -xx --long-opt over-long flag
signal triggered: rwsh.unrecognized_flag ( -xx a ) 

-1
$a --long-op short flag
signal triggered: rwsh.unrecognized_flag ( --long-op a ) 

-1
$a - --long-op short flag
signal triggered: rwsh.unrecognized_flag ( --long-op a ) 

-1
$a no flags
-*() -y(no) second(flags) 
0
$a deficient
unacceptable arguments: for prototype [--long-opt] [-x] -y second [--] [-],
 assigned -*=() -y=deficient ,
 but needed (second),
 call stack: a 

-1
$a flagless but_has excess argument
unacceptable arguments: for prototype [--long-opt] [-x] -y second [--] [-],
 assigned -=excess -*=() -y=flagless second=but_has ,
 but found (argument) excess
 call stack: a 

-1
$a -x with flag
-*(-x) -x(-x) -y(with) second(flag) 
0
$a -x -x doubled flag
-*(-x -x) -x(-x -x) -y(doubled) second(flag) 
0
$a accepted -x interlaced_flag -
-(-) -*(-x) -x(-x) -y(accepted) second(interlaced_flag) 
0
$a tardy flags_last - -x
signal triggered: rwsh.tardy_flag ( -x a ) 

-1
$a -x -- - flag_made_fixed_argument
-*(-x --) --(--) -x(-x) -y(-) second(flag_made_fixed_argument) 
0
$a -- - flag_again_made_fixed_argument
-*(--) --(--) -y(-) second(flag_again_made_fixed_argument) 
0
$a -x -- flag_and_fixed-x -x
-*(-x --) --(--) -x(-x) -y(flag_and_fixed-x) second(-x) 
0
$a -x just flags-x --long-opt
signal triggered: rwsh.tardy_flag ( --long-opt a ) 

-1
$a -x just flags-x -- --long-opt
-(--long-opt) -*(-x --) --(--) -x(-x) -y(just) second(flags-x) 
0
$a -x just flags-x --other
signal triggered: rwsh.tardy_flag ( --other a ) 

-1
$a -x just flags-x -- --other
-(--other) -*(-x --) --(--) -x(-x) -y(just) second(flags-x) 
0
$a -x with one excess argument
unacceptable arguments: for prototype [--long-opt] [-x] -y second [--] [-],
 assigned -=excess -*=-x -x=-x -y=with second=one ,
 but found (argument) excess
 call stack: a 

-1
$a - with flag
-(flag) -*() -y(-) second(with) 
0
$a --long-opt with flag
-*(--long-opt) --long-opt(--long-opt) -y(with) second(flag) 
0
$a --long-opt -x - some_flags in_order
-(in_order) -*(--long-opt -x) --long-opt(--long-opt) -x(-x) -y(-) second(some_flags) 
0
$a - -x --long-opt some_flags reversed
-(reversed) -*(-x --long-opt) --long-opt(--long-opt) -x(-x) -y(-) second(some_flags) 
0
$a - --long-opt some_flags in_order
-(in_order) -*(--long-opt) --long-opt(--long-opt) -y(-) second(some_flags) 
0
$a --long-opt - some_flags reversed
-(reversed) -*(--long-opt) --long-opt(--long-opt) -y(-) second(some_flags) 
0
$a -x --long-opt some_flags in_order
-*(-x --long-opt) --long-opt(--long-opt) -x(-x) -y(some_flags) second(in_order) 
0
$a --long-opt -x some_flags reversed
-*(--long-opt -x) --long-opt(--long-opt) -x(-x) -y(some_flags) second(reversed) 
0
$a -x --long-opt deficient
unacceptable arguments: for prototype [--long-opt] [-x] -y second [--] [-],
 assigned -*=(-x --long-opt) --long-opt=--long-opt -x=-x -y=deficient ,
 but needed (second),
 call stack: a 

-1
$a -x - --long-opt all_flags in_order
-(in_order) -*(-x --long-opt) --long-opt(--long-opt) -x(-x) -y(-) second(all_flags) 
0
$a --long-opt - -x all_flags reversed
-(reversed) -*(--long-opt -x) --long-opt(--long-opt) -x(-x) -y(-) second(all_flags) 
0
$a - --long-opt -x all_flags shuffled
-(shuffled) -*(--long-opt -x) --long-opt(--long-opt) -x(-x) -y(-) second(all_flags) 
0
$a - --long-opt -x -x some_flags doubled
-(doubled) -*(--long-opt -x -x) --long-opt(--long-opt) -x(-x -x) -y(-) second(some_flags) 
0
$a -x --long-opt -x --long-opt -x one_doubled one_tripled
-*(-x --long-opt -x --long-opt -x) --long-opt(--long-opt --long-opt) -x(-x -x -x) -y(one_doubled) second(one_tripled) 
0
$a --long-opt -x -x - --long-opt all_flags doubled
-(doubled) -*(--long-opt -x -x --long-opt) --long-opt(--long-opt --long-opt) -x(-x -x) -y(-) second(all_flags) 
0
$.function_all_flags a [-first] [-to] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }
  e nothing_required}

0
$w a
.function_all_flags a [-first] [-to] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}
  e nothing_required}
0
$a
-*() nothing_required
0
$a excess
unacceptable arguments: for prototype [-first] [-to],
 assigned -*=() ,
 but found (excess) excess
 call stack: a 

-1
$a -to
-*(-to) -to(-to) nothing_required
0
$a -first --
-*(-first --) --(--) -first(-first) nothing_required
0
$a -first excess
unacceptable arguments: for prototype [-first] [-to],
 assigned -*=-first -first=-first ,
 but found (excess) excess
 call stack: a 

-1
$a -to -- -first -- stops flag parsing rather than being a flag
unacceptable arguments: for prototype [-first] [-to],
 assigned -*=(-to --) --=-- -to=-to ,
 but found (-first -- stops flag parsing rather than being a flag) excess
 call stack: a 

-1
$a -to -first
-*(-to -first) -first(-first) -to(-to) nothing_required
0
$.function_all_flags a [-?] [-first] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }
  e nothing_required}

0
$w a
.function_all_flags a [-?] [-first] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}
  e nothing_required}
0
$a
-*() -?() nothing_required
0
$a excess
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=() -?=() ,
 but found (excess) excess
 call stack: a 

-1
$a -to
-*(-to) -?(-to) nothing_required
0
$a -first --
-*(-first --) --(--) -?() -first(-first) nothing_required
0
$a -first excess
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=-first -?=() -first=-first ,
 but found (excess) excess
 call stack: a 

-1
$a -to -- -first
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=(-to --) --=-- -?=-to ,
 but found (-first) excess
 call stack: a 

-1
$a -to -first
-*(-to -first) -?(-to) -first(-first) nothing_required
0
$.function_all_flags a [-*] [-first] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }
  e nothing_required}

0
$w a
.function_all_flags a [-?] [-first] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}
  e nothing_required}
0
$a
-*() -?() nothing_required
0
$a -to -- -first
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=(-to --) --=-- -?=-to ,
 but found (-first) excess
 call stack: a 

-1
$a -to -first
-*(-to -first) -?(-to) -first(-first) nothing_required
0
$.function_all_flags a [-?] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }
  e nothing_required}

0
$w a
.function_all_flags a [-?] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}
  e nothing_required}
0
$a
-*() -?() nothing_required
0
$.function_all_flags a ... y {}
signal triggered: rwsh.elipsis_first_arg ( ... .function_all_flags ) 

-1
$.function_all_flags a [-x] [--file file] ... y {}
signal triggered: rwsh.elipsis_first_arg ( ... .function_all_flags ) 

-1
$.function_all_flags a [...] x {}
signal triggered: rwsh.elipsis_first_arg ( [...] .function_all_flags ) 

-1
$.function_all_flags a [... y] x {}
signal triggered: rwsh.elipsis_first_arg ( [... y] .function_all_flags ) 

-1
$.function_all_flags a x ... [y z] {}
signal triggered: rwsh.post_elipsis_option ( [y z] .function_all_flags ) 

-1
$.function_all_flags a x [... y] z ... {}
signal triggered: rwsh.duplicate_parameter ( ... .function_all_flags ) 

-1
$.function_all_flags a [y z] ... x {}
signal triggered: rwsh.elipsis_out_of_option_group ( [y z] .function_all_flags ) 

-1
$.function_all_flags a [y] ... x {}

0
$w a
.function_all_flags a [y ...] x {}
0
$.function_all_flags a x ... y ... {}
signal triggered: rwsh.duplicate_parameter ( ... .function_all_flags ) 

-1
$.function_all_flags a [x ...] [y z] {}
signal triggered: rwsh.post_elipsis_option ( [y z] .function_all_flags ) 

-1
$.function_all_flags a [x ...] y ... {}
signal triggered: rwsh.duplicate_parameter ( ... .function_all_flags ) 

-1
$.function_all_flags a [x ... a] [y] {}
signal triggered: rwsh.post_elipsis_option ( [y] .function_all_flags ) 

-1
$.function_all_flags a [x ... a] y ... {}
signal triggered: rwsh.duplicate_parameter ( ... .function_all_flags ) 

-1
$.function_all_flags a [x ... a ...] {}
signal triggered: rwsh.duplicate_parameter ( ... .function_all_flags ) 

-1
$.function_all_flags a [x ... a ... b] {}
signal triggered: rwsh.duplicate_parameter ( ... .function_all_flags ) 

-1
$.function_all_flags a [-x ...] b [c] {}
signal triggered: rwsh.post_elipsis_option ( [c] .function_all_flags ) 

-1
$.function_all_flags a -? x ... y {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }}

0
$w a
.function_all_flags a [-?] x ... y {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}}
0
$a -c -a -b first second third
-*(-c -a -b) -?(-c -a -b) x(first second) y(third) 
0
$a -c first -a second -b third
signal triggered: rwsh.flag_in_elipsis ( -a a ) 

-1
$.function_all_flags a -* x ... y {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }}

0
$w a
.function_all_flags a [-?] x ... y {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}}
0
$a -c -a -b first second third
-*(-c -a -b) -?(-c -a -b) x(first second) y(third) 
0
$a -c first -a second -b third
signal triggered: rwsh.flag_in_elipsis ( -a a ) 

-1
$.function_all_flags a [-?] x ... y {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }}

0
$w a
.function_all_flags a [-?] x ... y {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}}
0
$a 
unacceptable arguments: for prototype [-?] x ... y,
 assigned -*=() -?=() ,
 but needed (x y),
 call stack: a 

-1
$a first
unacceptable arguments: for prototype [-?] x ... y,
 assigned -*=() -?=() x=first ,
 but needed (y),
 call stack: a 

-1
$a first (se cond)
-*() -?() x(first) y(se cond) 
0
$a first (se cond) third
-*() -?() x(first (se cond)) y(third) 
0
$a first (se cond) third fourth (fi fth)
-*() -?() x(first (se cond) third fourth) y(fi fth) 
0
$.function_all_flags a [-?] x [...] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }}

0
$w a
.function_all_flags a [-?] x ... {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}}
0
$a
unacceptable arguments: for prototype [-?] x ...,
 assigned -*=() -?=() ,
 but needed (x),
 call stack: a 

-1
$a first second third fourth fifth
-*() -?() x(first second third fourth fifth) 
0
$.function_all_flags a [-?] x [--] [y ...] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }}

0
$w a
.function_all_flags a [-?] x [--] [y ...] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}}
0
$a
unacceptable arguments: for prototype [-?] x [--] [y ...],
 assigned -*=() -?=() ,
 but needed (x),
 call stack: a 

-1
$a first
-*() -?() x(first) 
0
$a first second
-*() -?() x(first) y(second) 
0
$a first second third
-*() -?() x(first) y(second third) 
0
$a first second third fourth fifth
-*() -?() x(first) y(second third fourth fifth) 
0
$.function_all_flags a [-?] a [b ... c] d {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }}

0
$w a
.function_all_flags a [-?] a [b ... c] d {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}}
0
$a first
unacceptable arguments: for prototype [-?] a [b ... c] d,
 assigned -*=() -?=() a=first ,
 but needed (d),
 call stack: a 

-1
$a first second
-*() -?() a(first) d(second) 
0
$a first second third
unacceptable arguments: for prototype [-?] a [b ... c] d,
 assigned -*=() -?=() a=first b=second c=third ,
 but needed (d),
 call stack: a 

-1
$a first second third fourth
-*() -?() a(first) b(second) c(third) d(fourth) 
0
$a first second third fourth fifth
-*() -?() a(first) b(second third) c(fourth) d(fifth) 
0
$a first second third fourth fifth sixth
-*() -?() a(first) b(second third fourth) c(fifth) d(sixth) 
0
$.function_all_flags a [-x ...] b c {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }}

0
$w a
.function_all_flags a [-x ...] b c {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}}
0
$a first second
-*() b(first) c(second) 
0
$a -x first
unacceptable arguments: for prototype [-x ...] b c,
 assigned -*=-x -x=-x b=first ,
 but needed (c),
 call stack: a 

-1
$a -x first second
-*(-x) -x(-x) b(first) c(second) 
0
$a -x first second third
-*(-x first) -x(-x first) b(second) c(third) 
0
$a -x first second third fourth
-*(-x first second) -x(-x first second) b(third) c(fourth) 
0
$.function_all_flags a [-x b ...] c {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }}

0
$w a
.function_all_flags a [-x b ...] c {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}}
0
$a first
-*() c(first) 
0
$a -x first
unacceptable arguments: for prototype [-x b ...] c,
 assigned -*=(-x first) -x=(-x first) b=first ,
 but needed (c),
 call stack: a 

-1
$a -x (fi rst) second
-*(-x (fi rst)) -x(-x (fi rst)) b((fi rst)) c(second) 
0
$a -x first (sec ond) third
-*(-x first (sec ond)) -x(-x first (sec ond)) b(first (sec ond)) c(third) 
0
$a -x first -x (sec ond) third
signal triggered: rwsh.flag_in_elipsis ( -x a ) 

-1
$a -x first -y (sec ond) third
signal triggered: rwsh.flag_in_elipsis ( -y a ) 

-1
$a -x (fi rst) (sec ond) third fourth
-*(-x (fi rst) (sec ond) third) -x(-x (fi rst) (sec ond) third) b((fi rst) (sec ond) third) c(fourth) 
0
$.function_all_flags a [-x ... b] c {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }
  .combine $nl
  if_only .test_not_empty $-* {c (-*: ) $-*$ $nl}
  if_only .var_exists -x {c (-x: ) $-x$ $nl}
  if_only .var_exists b {c (b: ) $b$ $nl}
  if_only .var_exists c {c (c: ) $c$ $nl}
}

0
$w a
.function_all_flags a [-x ... b] c {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}
  .combine $nl
  if_only .test_not_empty $-* {c (-*: ) $-*$ $nl}
  if_only .var_exists -x {c (-x: ) $-x$ $nl}
  if_only .var_exists b {c (b: ) $b$ $nl}
  if_only .var_exists c {c (c: ) $c$ $nl}
}
0
$a first
-*() c(first) 
c: first

0
$a -x first
unacceptable arguments: for prototype [-x ... b] c,
 assigned -*=(-x first) -x=(-x first) b=first ,
 but needed (c),
 call stack: a 

-1
$a -x (fi rst) second
-*(-x (fi rst)) -x(-x (fi rst)) b((fi rst)) c(second) 
-*: -xfi rst
-x: -xfi rst
b: fi rst
c: second

0
$a -x () (fi rst) second
-*(-x () (fi rst)) -x(-x () (fi rst)) b((fi rst)) c(second) 
-*: -xfi rst
-x: -xfi rst
b: fi rst
c: second

0
$a -x first (sec ond) third
-*(-x first (sec ond)) -x(-x first (sec ond)) b((sec ond)) c(third) 
-*: -xfirstsec ond
-x: -xfirstsec ond
b: sec ond
c: third

0
$a -x (fi rst) (sec ond) third fourth
-*(-x (fi rst) (sec ond) third) -x(-x (fi rst) (sec ond) third) b(third) c(fourth) 
-*: -xfi rstsec ondthird
-x: -xfi rstsec ondthird
b: third
c: fourth

0
$.function_all_flags a x [-?] [... y z] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }
  .combine $nl
  if_only .var_exists x {c (x: ) $x$ $nl}}

0
$w a
.function_all_flags a [-?] x [... y z] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}
  .combine $nl
  if_only .var_exists x {c (x: ) $x$ $nl}}
0
$a
unacceptable arguments: for prototype [-?] x [... y z],
 assigned -*=() -?=() ,
 but needed (x),
 call stack: a 

-1
$a (fi rst)
-*() -?() x((fi rst)) 
x: fi rst

0
$a (fi rst) second
unacceptable arguments: for prototype [-?] x [... y z],
 assigned -*=() -?=() x=(fi rst) y=second ,
 but needed (z),
 call stack: a 

-1
$a first (sec ond) third
-*() -?() x(first) y(sec ond) z(third) 
x: first

0
$a (fi rst) (sec ond) third fourth
-*() -?() x((fi rst) (sec ond)) y(third) z(fourth) 
x: fi rstsec ond

0
$a () (sec ond) third fourth
-*() -?() x(() (sec ond)) y(third) z(fourth) 
x: sec ond

0
$a (fi rst) (sec ond) (thi rd) (fou rth) (fi fth)
-*() -?() x((fi rst) (sec ond) (thi rd)) y(fou rth) z(fi fth) 
x: fi rstsec ondthi rd

0
$.function_all_flags a [-?] [x] [... y] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }}

0
$w a
.function_all_flags a [-?] [x] [... y] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}}
0
$a
-*() -?() 
0
$a (fi rst)
-*() -?() x((fi rst)) 
0
$a (fi rst) second
-*() -?() x((fi rst)) y(second) 
0
$a first (sec ond) third
-*() -?() x(first (sec ond)) y(third) 
0
$a (fi rst) (sec ond) third fourth
-*() -?() x((fi rst) (sec ond) third) y(fourth) 
0
$a (fi rst) (sec ond) (thi rd) (fou rth) (fi fth)
-*() -?() x((fi rst) (sec ond) (thi rd) (fou rth)) y(fi fth) 
0
$.function_all_flags a [-?] [x y] [... z] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }
  .combine $nl
  if_only .var_exists x {c (x: ) $x $nl}
  if_only .var_exists y {c (y: ) $y$ $nl}
  if_only .var_exists z {c (z: ) $z$ $nl}}

0
$w a
.function_all_flags a [-?] [x y] [... z] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}
  .combine $nl
  if_only .var_exists x {c (x: ) $x $nl}
  if_only .var_exists y {c (y: ) $y$ $nl}
  if_only .var_exists z {c (z: ) $z$ $nl}}
0
$a
-*() -?() 

0
$a (fi rst)
unacceptable arguments: for prototype [-?] [x y] [... z],
 assigned -*=() -?=() x=(fi rst) ,
 but needed (y),
 call stack: a 

-1
$a (fi rst) second
-*() -?() x(fi rst) y(second) 
x: fi rst
y: second

0
$a (fi rst) (sec ond) (thi rd)
-*() -?() x(fi rst) y((sec ond)) z(thi rd) 
x: fi rst
y: sec ond
z: third

0
$a (fi rst) (sec ond) third (fou rth)
-*() -?() x(fi rst) y((sec ond) third) z(fou rth) 
x: fi rst
y: sec ondthird
z: fourth

0
$a (fi rst) (sec ond) (thi rd) (fou rth) (fi fth)
-*() -?() x(fi rst) y((sec ond) (thi rd) (fou rth)) z(fi fth) 
x: fi rst
y: sec ondthi rdfou rth
z: fifth

0
$.function_all_flags a -- [-x] y z {}
signal triggered: rwsh.post_dash_dash_flag ( [-x] .function_all_flags ) 

-1
$.function_all_flags a -- [x y] z {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }}

0
$w a
.function_all_flags a -- [x y] z {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}}
0
$a
unacceptable arguments: for prototype -- [x y] z,
 needed (z),
 call stack: a 

-1
$a --file
z(--file) 
0
$a first second third
x(first) y(second) z(third) 
0
$a -x second -
x(-x) y(second) z(-) 
0
$

0
$# .global .local .unset .var_exists 

0
$.global
signal triggered: rwsh.bad_argc ( 0 2 0 .global ) 

-1
$.global x y z
signal triggered: rwsh.bad_argc ( 3 2 0 .global ) 

-1
$.global x y {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .global ) 

-1
$.local
signal triggered: rwsh.bad_argc ( 0 2 0 .local ) 

-1
$.local x y z
signal triggered: rwsh.bad_argc ( 3 2 0 .local ) 

-1
$.local x y {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .local ) 

-1
$.unset
signal triggered: rwsh.bad_argc ( 0 1 0 .unset ) 

-1
$.unset x {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .unset ) 

-1
$.unset x y
signal triggered: rwsh.bad_argc ( 2 1 0 .unset ) 

-1
$.var_exists
signal triggered: rwsh.bad_argc ( 0 1 0 .var_exists ) 

-1
$.var_exists x {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .var_exists ) 

-1
$.global 100 nihilism

2
$.unset #

3
$.unset *

3
$.unset 1

3
$.unset MAX_NESTING

1
$.var_exists #

0
$.var_exists *

0
$.var_exists 0

0
$.var_exists 2

1
$.var_exists x

1
$.var_exists x y

1
$.var_exists # y

0
$.var_exists y x

1
$.unset x

1
$.global x nihilism

0
$.var_exists x

0
$.var_exists x y

0
$e $x
nihilism
0
$.global x nihilism

1
$.function a {if_only .var_exists x {e in a x \( $x \) $nl}
             if_only .var_exists y {e in a y \( $y \) $nl}
             .local x (first level not global)
             .local y (level one not global)
             b
             if_only .var_exists x {e out a x \( $x \) $nl}
             if_only .var_exists y {e out a y \( $y \) $nl}}

0
$.function b {if_only .var_exists x {e in b x \( $x \) $nl}
             if_only .var_exists y {e in b y \( $y \) $nl}
             .local x (second level masks first)
             .set y   (level two overwrites one)
             c
             if_only .var_exists x {e out b x \( $x \) $nl}
             if_only .var_exists y {e out b y \( $y \) $nl}}

0
$.function c {if_only .var_exists x {e in c x \( $x \) $nl}
             if_only .var_exists y {e in c y \( $y \) $nl}
             # can unset a local, but only one at a time
             .unset x
             .global y (attempting to create global masked by local)
             e $? $nl
             .set x (third level overwrites first)
             .local x (third level masks first)
             .set y (level three overwrites one)
             if_only .var_exists x {e out c x \( $x \) $nl}
             if_only .var_exists y {e out c y \( $y \) $nl}}

0
$a
in a x ( nihilism ) 
in b x ( first level not global ) 
in b y ( level one not global ) 
in c x ( second level masks first ) 
in c y ( level two overwrites one ) 
3 
out c x ( third level masks first ) 
out c y ( level three overwrites one ) 
out b x ( third level overwrites first ) 
out b y ( level three overwrites one ) 
out a x ( third level overwrites first ) 
out a y ( level three overwrites one ) 

0
$# demonstrating that final values are not retained

0
$a
in a x ( nihilism ) 
in b x ( first level not global ) 
in b y ( level one not global ) 
in c x ( second level masks first ) 
in c y ( level two overwrites one ) 
3 
out c x ( third level masks first ) 
out c y ( level three overwrites one ) 
out b x ( third level overwrites first ) 
out b y ( level three overwrites one ) 
out a x ( third level overwrites first ) 
out a y ( level three overwrites one ) 

0
$e $x
nihilism
0
$.var_exists y

1
$.unset x

0
$.var_exists x

1
$.return 0

0
$

0
$# .store_output

0
$.store_output x
signal triggered: rwsh.missing_argfunction ( .store_output ) 

-1
$.store_output {e some text}
signal triggered: rwsh.bad_argc ( 0 1 0 .store_output ) 

-1
$.store_output x {e some text}
signal triggered: rwsh.undefined_variable ( x .store_output ) 

-1
$.global x ()

0
$.store_output x {e some text; .return 1}

1
$e $x

0
$.store_output x {e some text}

0
$e $x
some text
0
$.unset x

0
$

0
$# if_core

0
$.if .return 1 {e nor this; .return 8}

0
$.else_if .return 1 {e nor this; .return 9}

0
$.else_if .return 0 {e but this; .return 10}
but this
10
$.else_if .return 0 {e this should be skipped; .return 11}

10
$.else_if .return 1 {e and certainly this; .return 12}

10
$.else {e nor this; .return 13}

10
$.if .return 1 {e nor this; .return 14}

0
$.else_if_not .return 0 {e nor this; .return 15}

0
$.else_if_not .return 1 {e but this; .return 16}
but this
16
$.else_if_not .return 1 {e this should be skipped; .return 17}

16
$.else_if_not .return 0 {e and certainly this; .return 18}

16
$.else {e nor this; .return 19}

16
$.if .nop {e set up}

0
$.if .nop {e if before else}
signal triggered: rwsh.if_before_else ( .if ) 

-1
$.if .return 0 {.else_if .return 0 {e nested syntax; .return 20}}
signal triggered: rwsh.else_without_if ( .else_if rwsh.mapped_argfunction .if ) 

-1
$.else {e already tested; .return 21}

0
$.if .return 0 {.if .return 1 {
	   not to be printed; .return 22}
       .else_if .return 0 {
	   e nested else_if; .return 23}
       .else {
	   e nested else not printed; .return 24}}
nested else_if
23
$.else {e still not printed; .return 25}

23
$.if .return 0 {.if .return 1 {
	   not to be printed; .return 22}
       .else_if .return 0 {
	   e about to trigger bad_if_nest $nl; .return 23}}
about to trigger bad_if_nest 
signal triggered: rwsh.bad_if_nest ( .if ) 

-1
$.else {e else_if failed to appropriately set IF_TEST on exit; .return 24}

0
$.if .return 1 {}

0
$.else {
  .if .return 1 {e about to trigger bad_if_nest $nl}}
signal triggered: rwsh.bad_if_nest ( .else ) 

-1
$.if .return 0 {.if .return 0 {
	   /bin/false should nest properly; .return 22}
       .else {
	   e nested else not printed; .return 24}}
signal triggered: rwsh.return_code ( 256 /bin/false rwsh.mapped_argfunction .if rwsh.mapped_argfunction .if ) 

-1
$

-1
$# .if .else_if .else_if_not .else

-1
$.if
signal triggered: rwsh.bad_argc ( 0 1 0 .if ) 

-1
$.else_if .return 0 {e do not run after an exception}

0
$.else_if_not .return 1 {e do not run after an exception}

0
$.else_if
signal triggered: rwsh.bad_argc ( 0 1 0 .else_if ) 

-1
$.else_if_not
signal triggered: rwsh.bad_argc ( 0 1 0 .else_if_not ) 

-1
$.else {e do not run after an exception}

0
$.if missing argfunction
signal triggered: rwsh.missing_argfunction ( .if ) 

-1
$.else_if missing argfunction
signal triggered: rwsh.missing_argfunction ( .else_if ) 

-1
$.else_if_not missing argfunction
signal triggered: rwsh.missing_argfunction ( .else_if_not ) 

-1
$.else
signal triggered: rwsh.missing_argfunction ( .else ) 

-1
$.if .return 1 {}

0
$.else
signal triggered: rwsh.missing_argfunction ( .else ) 

-1
$.else {e second else for if}
signal triggered: rwsh.else_without_if ( .else ) 

-1
$.if .return 0 {e if true; .return 1}
if true
1
$.else {e else true; .return 3}

1
$.if .return 1 {e if false; .return 4}

0
$.else {e else false; .return 5}
else false
5
$.else {}
signal triggered: rwsh.else_without_if ( .else ) 

-1
$.else_if .return 0 {e not this one; .return 6}
signal triggered: rwsh.else_without_if ( .else_if ) 

-1
$.else {}

0
$.else_if_not .return 1 {e not this one; .return 7}
signal triggered: rwsh.else_without_if ( .else_if_not ) 

-1
$.else {}

0
$

0
$# .internal_features .internal_functions .internal_vars

0
$.internal_features 1
wrong argument count
-1
$.internal_functions 1
signal triggered: rwsh.bad_argc ( 1 0 0 .internal_functions ) 

-1
$.internal_functions {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .internal_functions ) 

-1
$.internal_vars 1
wrong argument count
-1
$.internal_features
rwsh.after_command rwsh.before_command rwsh.run_logic
0
$.internal_functions
rwsh.ambiguous_prototype_dash_dash
rwsh.arguments_for_argfunction
rwsh.bad_argc
rwsh.bad_argfunction_style
rwsh.bad_args
rwsh.bad_if_nest
rwsh.binary_not_found
rwsh.dash_dash_argument
rwsh.dash_star_argument
rwsh.divide_by_zero
rwsh.double_redirection
rwsh.duplicate_parameter
rwsh.elipsis_first_arg
rwsh.elipsis_out_of_option_group
rwsh.else_without_if
rwsh.excess_argfunction
rwsh.excessive_exceptions_collected
rwsh.excessive_exceptions_in_catch
rwsh.excessive_nesting
rwsh.executable_not_found
rwsh.failed_substitution
rwsh.file_open_failure
rwsh.flag_in_elipsis
rwsh.if_before_else
rwsh.input_range
rwsh.internal_error
rwsh.invalid_word_selection
rwsh.mismatched_brace
rwsh.mismatched_bracket
rwsh.mismatched_parenthesis
rwsh.missing_argfunction
rwsh.multiple_argfunctions
rwsh.not_a_number
rwsh.not_executable
rwsh.not_soon_enough
rwsh.raw_command
rwsh.return_code
rwsh.result_range
rwsh.post_elipsis_option
rwsh.post_dash_dash_flag
rwsh.prompt
rwsh.selection_not_found
rwsh.shutdown
rwsh.sighup
rwsh.sigint
rwsh.sigquit
rwsh.sigpipe
rwsh.sigterm
rwsh.sigtstp
rwsh.sigcont
rwsh.sigchld
rwsh.sigusr1
rwsh.sigusr2
rwsh.sigunknown
rwsh.tardy_flag
rwsh.unchecked_variable
rwsh.undefined_variable
rwsh.unreadable_dir
rwsh.unrecognized_flag
rwsh.unused_variable
rwsh.vars
rwsh.version_incompatible
0
$.internal_vars
FIGNORE ?
0
$

0
$# .is_default_input .is_default_output .is_default_error

0
$.is_default_input 1
signal triggered: rwsh.bad_argc ( 1 0 0 .is_default_input ) 

-1
$.is_default_input {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .is_default_input ) 

-1
$m {.is_default_input <dummy_file}

1
$m {.is_default_input}

0
$.is_default_output 1
signal triggered: rwsh.bad_argc ( 1 0 0 .is_default_output ) 

-1
$.is_default_output {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .is_default_output ) 

-1
$e ${.is_default_output; .echo $?}
1
0
$m {.is_default_output >dummy_file}

1
$m {.is_default_output}

0
$.is_default_error 1
signal triggered: rwsh.bad_argc ( 1 0 0 .is_default_error ) 

-1
$.is_default_error {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .is_default_error ) 

-1
$m {.is_default_error}

0
$

0
$# .list_executables

0
$.list_executables excess
signal triggered: rwsh.bad_argc ( 1 0 0 .list_executables ) 

-1
$.list_executables {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .list_executables ) 

-1
$.for ${.list_executables}$ {.combine $1 $nl}
#
#!
##
.a
.argc
.cd
.collect_errors_except
.collect_errors_only
.combine
.echo
.else
.else_if
.else_if_not
.exec
.exit
.fallback_handler
.for
.for_each_line
.fork
.function
.function_all_flags
.get_fallback_message
.get_max_collectible_exceptions
.get_max_extra_exceptions
.get_max_nesting
.getpid
.getppid
.global
.if
.init
.internal_features
.internal_functions
.internal_vars
.is_default_error
.is_default_input
.is_default_output
.list_environment
.list_executables
.list_locals
.local
.ls
.nop
.return
.scope
.selection_set
.set
.set_fallback_message
.set_max_collectible_exceptions
.set_max_extra_exceptions
.set_max_nesting
.source
.stepwise
.store_output
.test_greater
.test_is_number
.test_less
.test_not_empty
.test_number_equal
.test_string_equal
.test_string_unequal
.throw
.toggle_readline
.try_catch_recursive
.unset
.usleep
.usleep_overhead
.var_add
.var_divide
.var_exists
.var_subtract
.version
.version_compatible
.waiting_for_binary
.waiting_for_shell
.waiting_for_user
.which_executable
.which_execution_count
.which_last_exception
.which_last_execution_time
.which_path
.which_return
.which_test
.which_total_execution_time
.while
/bin/cat
/bin/echo
/bin/false
/bin/pwd
/bin/rm
/usr/bin/sort
a
af
b
c
e
echo
elif
else
f
fn
fni
fns
for
g
h
iee
ien
if
if_only
if_only_not
m
mark
ntimes
paren_if_words
rwsh.after_command
rwsh.ambiguous_prototype_dash_dash
rwsh.arguments_for_argfunction
rwsh.bad_argc
rwsh.bad_argfunction_style
rwsh.bad_args
rwsh.bad_if_nest
rwsh.before_command
rwsh.binary_not_found
rwsh.dash_dash_argument
rwsh.dash_star_argument
rwsh.divide_by_zero
rwsh.double_redirection
rwsh.duplicate_parameter
rwsh.elipsis_first_arg
rwsh.elipsis_out_of_option_group
rwsh.else_without_if
rwsh.excess_argfunction
rwsh.excessive_exceptions_collected
rwsh.excessive_exceptions_in_catch
rwsh.excessive_nesting
rwsh.executable_not_found
rwsh.failed_substitution
rwsh.file_open_failure
rwsh.flag_in_elipsis
rwsh.if_before_else
rwsh.input_range
rwsh.internal_error
rwsh.invalid_word_selection
rwsh.mismatched_brace
rwsh.mismatched_bracket
rwsh.mismatched_parenthesis
rwsh.missing_argfunction
rwsh.multiple_argfunctions
rwsh.not_a_number
rwsh.not_executable
rwsh.not_soon_enough
rwsh.post_dash_dash_flag
rwsh.post_elipsis_option
rwsh.prompt
rwsh.raw_command
rwsh.result_range
rwsh.return_code
rwsh.selection_not_found
rwsh.shutdown
rwsh.sigchld
rwsh.sigcont
rwsh.sighup
rwsh.sigint
rwsh.sigpipe
rwsh.sigquit
rwsh.sigterm
rwsh.sigtstp
rwsh.sigunknown
rwsh.sigusr1
rwsh.sigusr2
rwsh.tardy_flag
rwsh.unchecked_variable
rwsh.undefined_variable
rwsh.unreadable_dir
rwsh.unrecognized_flag
rwsh.unused_variable
rwsh.vars
rwsh.version_incompatible
set
set_if_undefined
setf
sort
test_var_greater
test_var_not_equal
timings
unset
var_exists
var_val
w
which
whichp
while

0
$

0
$# .ls

0
$.ls
signal triggered: rwsh.bad_argc ( 0 1 0 .ls ) 

-1
$.ls /bin {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .ls ) 

-1
$.ls /bin /usr/
/bin
/usr/

0
$

0
$# .nop

0
$.nop

0
$.nop {optional argfunc}

0
$.nop 1 2 3 4 5

0
$

0
$# .getpid .getppid

0
$.getpid excess
signal triggered: rwsh.bad_argc ( 1 0 0 .getpid ) 

-1
$.getpid {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .getpid ) 

-1
$.getppid excess
signal triggered: rwsh.bad_argc ( 1 0 0 .getppid ) 

-1
$.getppid {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .getppid ) 

-1
$.fork m {/bin/kill ${.getppid}}
signal triggered: rwsh.sigterm ( ) 

-1
$.fork m {/bin/kill ${.getpid}}
signal triggered: rwsh.sigterm ( ) 

0
$m {.fork m {/bin/kill ${.getppid}
            echo after the signal in subshell}
   echo after the signal in parent}
after the signal in subshell 
signal triggered: rwsh.sigterm ( ) 
after the signal in parent 

0
$m {.fork m {/bin/kill ${.getpid}
            echo after the signal in subshell}
   echo after the signal in parent}
signal triggered: rwsh.sigterm ( ) 
after the signal in subshell 
after the signal in parent 

0
$

0
$# .return

0
$.return
signal triggered: rwsh.bad_argc ( 0 1 0 .return ) 

-1
$.return 1 1
signal triggered: rwsh.bad_argc ( 2 1 0 .return ) 

-1
$.return 0 {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .return ) 

-1
$.return 0

0
$.return 1

1
$.return \
signal triggered: rwsh.not_a_number (  .return ) 

-1
$.return O
signal triggered: rwsh.not_a_number ( O .return ) 

-1
$.return 1E2
signal triggered: rwsh.not_a_number ( 1E2 .return ) 

-1
$.return 2147483647

2147483647
$.return 2147483649
signal triggered: rwsh.input_range ( 2147483649 .return ) 

-1
$.return -2147483649
signal triggered: rwsh.input_range ( -2147483649 .return ) 

-1
$

-1
$# .scope

-1
$.scope {e $foo}
signal triggered: rwsh.bad_argc ( 0 2 0 .scope ) 

-1
$.scope foo
signal triggered: rwsh.missing_argfunction ( .scope ) 

-1
$.scope a (y y) {e illegal duplicate required parameter}
signal triggered: rwsh.duplicate_parameter ( y .scope ) 

-1
$.scope a ([-x] [-x]) {e illegal duplicate flag parameter}
signal triggered: rwsh.duplicate_parameter ( -x .scope ) 

-1
$.scope a ([x x]) {e illegal duplicate optional parameter}
signal triggered: rwsh.duplicate_parameter ( x .scope ) 

-1
$.scope a ([-x arg bar] [-y arg]) {e illegal duplicate flag argument}
signal triggered: rwsh.duplicate_parameter ( arg .scope ) 

-1
$.scope a (-x [-x]) {e evil duplication between flags positional}
signal triggered: rwsh.duplicate_parameter ( -x .scope ) 

-1
$.scope -- -- {e -- as a prototype forbids even -- as arguments}
unacceptable arguments: for prototype --,
 found (--) excess
 call stack: .scope 

-1
$.scope -- () {e but ${.list_locals} is acceptable for empty prototype}
but -- is acceptable for empty prototype
0
$.scope a (-- --) {e -- cannot be a duplicate parameter}
signal triggered: rwsh.duplicate_parameter ( -- .scope ) 

-1
$.scope a ([--] [--]) {e [--] cannot be a duplicate flag parameter}
signal triggered: rwsh.duplicate_parameter ( -- .scope ) 

-1
$.scope a ([--] --) {e -- and [--] cannot both be parameters}
signal triggered: rwsh.duplicate_parameter ( -- .scope ) 

-1
$.scope a ([-- arg]) {e -- cannot take arguments}
signal triggered: rwsh.dash_dash_argument ( [-- arg] .scope ) 

-1
$.scope a ([arg -- foo]) {e -- cannot be an argument}
signal triggered: rwsh.dash_dash_argument ( [arg -- foo] .scope ) 

-1
$.scope -x -y a b ([-?] args ...) {for ${.list_locals}$ {.combine $1 = $$1 \ }}
-*=-x -y -?=-x -y args=a b 
0
$.scope a ([-? bad] arg) {e -? cannot currently take arguments}
signal triggered: rwsh.dash_star_argument ( [-? bad] .scope ) 

-1
$.scope a ([-* bad] arg) {e -* (aka -?) cannot currently take arguments}
signal triggered: rwsh.dash_star_argument ( [-* bad] .scope ) 

-1
$.scope -a -* -b a ([-?] a) {for ${.list_locals}$ {.combine $1 = $$1 \ }}
-*=-a -* -b -?=-a -* -b a=a 
0
$.scope bar foo {e aa $foo bb}
aa bar bb
0
$.scope baz bax (foo bar) {for ${.list_locals}$ {.combine $1 = $$1 \ }}
bar=bax foo=baz 
0
$.scope foo bar baz bax (args ...) {e aa $args$2 bb $args$1 cc}
aa baz bb bar cc
0
$.scope single ([-x] [--long-opt y] second) {var_val ${.list_locals}$}
-*() second(single) 
0
$.function_all_flags a [-x] [--long-opt y] second {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }}

0
$w a
.function_all_flags a [--long-opt y] [-x] second {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}}
0
$.function_all_flags pt -- args ... {
  .scope $args$ ([-x] [--long-opt y] second) {
    for ${.list_locals}$ {.combine $1 \( $$1 \) \ }}
  .combine $nl
  .scope $args$ ( [-?] [--long-opt y] second) {
    for ${.list_locals}$ {.combine $1 \( $$1 \) \ }}}

0
$w pt
.function_all_flags pt -- args ... {
  .scope $args$ ([-x] [--long-opt y] second) {
    for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}}
  .combine $nl
  .scope $args$ ( [-?] [--long-opt y] second) {
    for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}}}
0
$a
unacceptable arguments: for prototype [--long-opt y] [-x] second,
 assigned -*=() ,
 but needed (second),
 call stack: a 

-1
$a single
-*() second(single) 
0
$pt single
-*() second(single) 
-*() -?() second(single) 
0
$a -x single
-*(-x) -x(-x) second(single) 
0
$pt -x single
-*(-x) -x(-x) second(single) 
-*(-x) -?(-x) second(single) 
0
$a --long-opt arg single
-*(--long-opt arg) --long-opt(--long-opt arg) second(single) y(arg) 
0
$pt --long-opt arg single
-*(--long-opt arg) --long-opt(--long-opt arg) second(single) y(arg) 
-*(--long-opt arg) --long-opt(--long-opt arg) -?() second(single) y(arg) 
0
$a --long-opt single
unacceptable arguments: for prototype [--long-opt y] [-x] second,
 assigned -*=(--long-opt single) --long-opt=(--long-opt single) y=single ,
 but needed (second),
 call stack: a 

-1
$pt --long-opt single
unacceptable arguments: for prototype [--long-opt y] [-x] second,
 assigned -*=(--long-opt single) --long-opt=(--long-opt single) y=single ,
 but needed (second),
 call stack: .scope pt 

-1
$a --long-opt first -x --long-opt second single
-*(--long-opt first -x --long-opt second) --long-opt(--long-opt first --long-opt second) -x(-x) second(single) y(first second) 
0
$pt --long-opt first -x --long-opt second single
-*(--long-opt first -x --long-opt second) --long-opt(--long-opt first --long-opt second) -x(-x) second(single) y(first second) 
-*(--long-opt first -x --long-opt second) --long-opt(--long-opt first --long-opt second) -?(-x) second(single) y(first second) 
0
$.function_all_flags a [-?] [-first] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }
  e nothing_required}

0
$w a
.function_all_flags a [-?] [-first] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}
  e nothing_required}
0
$.function_all_flags pts -- [args ...] {
  .if var_exists args {
    .scope $args$ ([-first] [-?]) {
      .for ${.list_locals}$ {.combine $1 \( $$1 \) \ }}
      e nothing_required}
  else {.scope ([-first] [-?]) {
      .for ${.list_locals}$ {.combine $1 \( $$1 \) \ }}
      e nothing_required}}

0
$w pts
.function_all_flags pts -- [args ...] {
  .if var_exists args {
    .scope $args$ ([-first] [-?]) {
      .for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}}
      e nothing_required}
  else {.scope ([-first] [-?]) {
      .for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}}
      e nothing_required}}
0
$a
-*() -?() nothing_required
0
$pts
-*() -?() nothing_required
0
$a excess
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=() -?=() ,
 but found (excess) excess
 call stack: a 

-1
$pts excess
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=() -?=() ,
 but found (excess) excess
 call stack: .scope rwsh.mapped_argfunction .if pts 

-1
$a -to
-*(-to) -?(-to) nothing_required
0
$pts -to
-*(-to) -?(-to) nothing_required
0
$a -first --
-*(-first --) --(--) -?() -first(-first) nothing_required
0
$pts -first --
-*(-first --) --(--) -?() -first(-first) nothing_required
0
$a -first excess
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=-first -?=() -first=-first ,
 but found (excess) excess
 call stack: a 

-1
$pts -first excess
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=-first -?=() -first=-first ,
 but found (excess) excess
 call stack: .scope rwsh.mapped_argfunction .if pts 

-1
$a -to -- -first
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=(-to --) --=-- -?=-to ,
 but found (-first) excess
 call stack: a 

-1
$pts -to -- -first
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=(-to --) --=-- -?=-to ,
 but found (-first) excess
 call stack: .scope rwsh.mapped_argfunction .if pts 

-1
$a -to -first
-*(-to -first) -?(-to) -first(-first) nothing_required
0
$pts -to -first
-*(-to -first) -?(-to) -first(-first) nothing_required
0
$.return 0

0
$

0
$# .selection_set

0
$.selection_set A
signal triggered: rwsh.bad_argc ( 1 2 0 .selection_set ) 

-1
$.selection_set A /usr {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .selection_set ) 

-1
$.selection_set A /usr

0
$e $A
/usr
0
$.selection_set A ./

0
$e $A
/usr/*
0
$.selection_set A local/include

0
$e $A
/usr/local/include
0
$.selection_set A ..

0
$e $A
/usr
0
$.selection_set A ()

0
$e $A
/usr
0
$.selection_set A ./local/../../bin

0
$e $A
/bin
0
$.selection_set A sbin etc

0
$e $A
/sbin etc
0
$

0
$# .set

0
$.set A
signal triggered: rwsh.bad_argc ( 1 2 0 .set ) 

-1
$.set B x
signal triggered: rwsh.undefined_variable ( B .set ) 

-1
$.set B x {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .set ) 

-1
$.set A x

0
$e $A
x
0
$

0
$# .get_max_collectible_exceptions .set_max_collectible_exceptions

0
$.get_max_collectible_exceptions excess
signal triggered: rwsh.bad_argc ( 1 0 0 .get_max_collectible_exceptions ) 

-1
$.set_max_collectible_exceptions
signal triggered: rwsh.bad_argc ( 0 0 0 .set_max_collectible_exceptions ) 

-1
$.get_max_collectible_exceptions {excess}
signal triggered: rwsh.excess_argfunction ( .get_max_collectible_exceptions ) 

-1
$.set_max_collectible_exceptions 1 {excess}
signal triggered: rwsh.excess_argfunction ( .set_max_collectible_exceptions ) 

-1
$.set_max_collectible_exceptions NaN
signal triggered: rwsh.not_a_number ( NaN .set_max_collectible_exceptions ) 

-1
$.set_max_collectible_exceptions 0
signal triggered: rwsh.input_range ( 0 .set_max_collectible_exceptions ) 

-1
$.get_max_collectible_exceptions
1
0
$.set_max_collectible_exceptions 7

0
$m {.collect_errors_except .nop {
     m {echo before exception
        .throw rwsh.not_a_number 7
        echo after exception}
     echo between exceptions
     .scope () {.throw rwsh.executable_not_found foo}
     echo inside collect}
   echo outside collect}
before exception 
between exceptions 
inside collect 
signal triggered: rwsh.not_a_number ( 7 .throw rwsh.mapped_argfunction m .collect_errors_except rwsh.mapped_argfunction m ) 
signal triggered: rwsh.executable_not_found ( foo .throw .scope .collect_errors_except rwsh.mapped_argfunction m ) 

-1
$m {.collect_errors_except echo {
     .throw rwsh.executable_not_found foo
     echo between exceptions
     .throw echo 7
     echo inside collect}
   echo outside collect}
between exceptions 
signal triggered: rwsh.executable_not_found ( foo .throw .collect_errors_except rwsh.mapped_argfunction m ) 
7 .throw .collect_errors_except rwsh.mapped_argfunction m 

-1
$# .collect_errors_except .echo {${.throw .echo exception thrown directly}}

-1
$m {.collect_errors_only rwsh.executable_not_found {
     .throw rwsh.executable_not_found foo
     echo between exceptions
     .throw echo 7
     echo inside collect}
   echo outside collect}
between exceptions 
signal triggered: rwsh.executable_not_found ( foo .throw .collect_errors_only rwsh.mapped_argfunction m ) 
7 .throw .collect_errors_only rwsh.mapped_argfunction m 

-1
$.collect_errors_except echo {
 .collect_errors_except echo {
  .collect_errors_except echo {
   .collect_errors_except echo {
    .collect_errors_except .echo {
     echo inside 5
     .throw echo inside 5
     .collect_errors_except echo {
      .collect_errors_except echo {
       .collect_errors_except echo {
        .collect_errors_except echo {
         .collect_errors_except .echo {
          echo inside 10
          .throw echo inside 10
          .collect_errors_except echo {
           .collect_errors_except echo {
            .collect_errors_except echo {
             .collect_errors_except echo {
              .collect_errors_except .echo {
               echo inside 15
               .throw echo inside 15
               .collect_errors_except echo {
                .collect_errors_except echo {
                 .collect_errors_except echo {
                  .collect_errors_except echo {
                   .collect_errors_except .echo {
                    echo inside 20
                    .throw echo inside 20
                   .collect_errors_except .echo {echo inside 21}
}}}}}}}}}}}}}}}}}}}}
inside 5 
inside 10 
inside 15 
inside 20 
inside 5 .throw .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except 
inside 10 .throw .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except 
inside 15 .throw .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except 
inside 20 .throw .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except 
signal triggered: rwsh.excessive_nesting ( echo .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except ) 

-1
$.set_max_collectible_exceptions 1

0
$.function_all_flags collecting_handler args ... {
  echo $args$
}

0
$.set_max_extra_exceptions 1

0
$.try_catch_recursive collecting_handler {
  .collect_errors_except .echo {
    .throw collecting_handler 1
    .throw collecting_handler 2}}
1 .throw .collect_errors_except rwsh.mapped_argfunction 
2 .throw .collect_errors_except rwsh.mapped_argfunction 

-1
$.try_catch_recursive collecting_handler {
  .collect_errors_except .echo {
    .throw collecting_handler 1
    .throw collecting_handler 2
    echo almost nothing}}
1 .throw .collect_errors_except rwsh.mapped_argfunction 
2 .throw .collect_errors_except rwsh.mapped_argfunction 
signal triggered: rwsh.excessive_exceptions_collected ( 1 .collect_errors_except rwsh.mapped_argfunction .try_catch_recursive ) 

-1
$.set_max_extra_exceptions 0

0
$.try_catch_recursive collecting_handler {
  .collect_errors_except .echo {
    .throw collecting_handler 1
    .throw collecting_handler 2}}
1 .throw .collect_errors_except rwsh.mapped_argfunction .try_catch_recursive 
2 .throw .collect_errors_except rwsh.mapped_argfunction .try_catch_recursive 
signal triggered: rwsh.excessive_exceptions_in_catch ( 0 .try_catch_recursive ) 

-1
$.try_catch_recursive collecting_handler {
  .collect_errors_except .echo {
    .throw collecting_handler 1
    .throw collecting_handler 2
    echo almost nothing}}
1 .throw .collect_errors_except rwsh.mapped_argfunction .try_catch_recursive 
2 .throw .collect_errors_except rwsh.mapped_argfunction .try_catch_recursive 
signal triggered: rwsh.excessive_exceptions_collected ( 1 .collect_errors_except rwsh.mapped_argfunction .try_catch_recursive ) 
signal triggered: rwsh.excessive_exceptions_in_catch ( 0 .try_catch_recursive ) 

-1
$.set_max_extra_exceptions 1

0
$.get_max_collectible_exceptions
1
0
$

0
$# .try_catch_recursive .get_max_extra_exceptions .set_max_extra_exceptions

0
$.try_catch_recursive rwsh.executable_not_found 
signal triggered: rwsh.missing_argfunction ( .try_catch_recursive ) 

-1
$.try_catch_recursive {.return A}
signal triggered: rwsh.bad_argc ( 0 1 0 .try_catch_recursive ) 

-1
$f e_after {m {rwsh.argfunction}; echo after}

0
$e_after {.try_catch_recursive rwsh.not_a_number rwsh.executable_not_found {
  .return A}}
signal triggered: rwsh.not_a_number ( A .return rwsh.mapped_argfunction ) 
after 

0
$f rwsh.autofunction {.nop}

0
$e_after {.try_catch_recursive rwsh.executable_not_found {.eturn A}}
signal triggered: rwsh.executable_not_found ( .eturn A rwsh.mapped_argfunction ) 
after 

0
$e_after {.try_catch_recursive rwsh.not_a_number {.return A}}
signal triggered: rwsh.not_a_number ( A .return rwsh.mapped_argfunction ) 
after 

0
$e_after {.try_catch_recursive rwsh.not_a_number {.cho A}}
signal triggered: rwsh.executable_not_found ( .cho A rwsh.mapped_argfunction .try_catch_recursive rwsh.mapped_argfunction m e_after ) 

-1
$e_after {.try_catch_recursive rwsh.not_a_number rwsh.executable_not_found {echo A}}
A 
after 

0
$e_after {m echo hi {.try_catch_recursive ${.internal_functions}$ {&&&*}}}
hi 
after 

0
$.get_max_extra_exceptions excess
signal triggered: rwsh.bad_argc ( 1 0 0 .get_max_extra_exceptions ) 

-1
$.set_max_extra_exceptions
signal triggered: rwsh.bad_argc ( 0 0 0 .set_max_extra_exceptions ) 

-1
$.get_max_extra_exceptions {excess}
signal triggered: rwsh.excess_argfunction ( .get_max_extra_exceptions ) 

-1
$.set_max_extra_exceptions 1 {excess}
signal triggered: rwsh.excess_argfunction ( .set_max_extra_exceptions ) 

-1
$.set_max_extra_exceptions NaN
signal triggered: rwsh.not_a_number ( NaN .set_max_extra_exceptions ) 

-1
$.set_max_extra_exceptions -1
signal triggered: rwsh.input_range ( -1 .set_max_extra_exceptions ) 

-1
$.get_max_extra_exceptions
1
0
$.set_max_extra_exceptions 0

0
$.get_max_extra_exceptions
0
0
$e_after {.try_catch_recursive rwsh.not_a_number {.try_catch_recursive rwsh.not_a_number {.return A}}}
signal triggered: rwsh.not_a_number ( A .return rwsh.mapped_argfunction .try_catch_recursive rwsh.mapped_argfunction .try_catch_recursive rwsh.mapped_argfunction m e_after ) 
signal triggered: rwsh.excessive_exceptions_in_catch ( 0 .try_catch_recursive rwsh.mapped_argfunction .try_catch_recursive rwsh.mapped_argfunction m e_after ) 

-1
$e_after {.try_catch_recursive rwsh.not_a_number {.try_catch_recursive rwsh.not_a_number {.return A}}}
signal triggered: rwsh.not_a_number ( A .return rwsh.mapped_argfunction .try_catch_recursive rwsh.mapped_argfunction .try_catch_recursive rwsh.mapped_argfunction m e_after ) 
signal triggered: rwsh.excessive_exceptions_in_catch ( 0 .try_catch_recursive rwsh.mapped_argfunction .try_catch_recursive rwsh.mapped_argfunction m e_after ) 

-1
$e_after {m echo hi {.try_catch_recursive ${.internal_functions}$ {&&&*}}}
hi 
after 

0
$

0
$# .source

0
$.source
signal triggered: rwsh.bad_argc ( 0 1 0 .source ) 

-1
$.source /etc/hosts {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .source ) 

-1
$.source test_files/*fu*bar*
signal triggered: rwsh.file_open_failure ( test_files/*fu*bar* .source ) 

-1
$.source /etc/hosts
signal triggered: rwsh.not_executable ( /etc/hosts .source ) 

-1
$# .source is tested by having test_init.sh define #

-1
$w .init
.function .init {.set_max_nesting 10
.function rwsh.file_open_failure {.echo init file $1 does not exist \(call stack $*2 \) (
)}
.function rwsh.raw_command {.nop $*}
.source /etc/rwshrc $*
.for &{.internal_functions}$ {.if .which_test $1 {.nop}
.else {.echo &&1 not defined (
)}}
.if .which_test rwsh.help {.if .test_not_empty &&{rwsh.help} {.nop}
.else {.echo rwsh.help produces no output (
)}}
.else {.echo rwsh.help not defined (
)}}
0
$

0
$# .stepwise

0
$f wrapper {a $* two; a $* three}

0
$f a {e $* one $nl; e $* two $nl; e $* three $nl}

0
$f d {e $* $nl; .stepwise $* {d $*}}

0
$.stepwise {e $* $nl}
signal triggered: rwsh.bad_argc ( 0 1 0 .stepwise ) 

-1
$.stepwise wrapper 1 2
signal triggered: rwsh.missing_argfunction ( .stepwise ) 

-1
$.stepwise stepwise {e $* $nl}

1
$.stepwise .stepwise {e $* $nl}

2
$.stepwise wrapper 1 2 {e $* $nl}
a 1 2 two 
a 1 2 three 

0
$f wrapper {a $* one; a $* two; a $* three}

0
$wrapper 1 2
1 2 one one 
1 2 one two 
1 2 one three 
1 2 two one 
1 2 two two 
1 2 two three 
1 2 three one 
1 2 three two 
1 2 three three 

0
$.stepwise wrapper 1 2 {d $*}
a 1 2 one 
e 1 2 one one 
 
.echo 1 2 one one 
 
e 1 2 one two 
 
.echo 1 2 one two 
 
e 1 2 one three 
 
.echo 1 2 one three 
 
a 1 2 two 
e 1 2 two one 
 
.echo 1 2 two one 
 
e 1 2 two two 
 
.echo 1 2 two two 
 
e 1 2 two three 
 
.echo 1 2 two three 
 
a 1 2 three 
e 1 2 three one 
 
.echo 1 2 three one 
 
e 1 2 three two 
 
.echo 1 2 three two 
 
e 1 2 three three 
 
.echo 1 2 three three 
 

2
$.stepwise wrapper 1 2 {e $* $nl}
a 1 2 one 
a 1 2 two 
a 1 2 three 

0
$

0
$# .test_string_equal .test_string_unequal .test_not_empty

0
$.test_string_equal x
signal triggered: rwsh.bad_argc ( 1 2 0 .test_string_equal ) 

-1
$.test_string_equal x x x
signal triggered: rwsh.bad_argc ( 3 2 0 .test_string_equal ) 

-1
$.test_string_equal x x {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .test_string_equal ) 

-1
$.test_string_unequal x 
signal triggered: rwsh.bad_argc ( 1 2 0 .test_string_unequal ) 

-1
$.test_string_unequal x x x
signal triggered: rwsh.bad_argc ( 3 2 0 .test_string_unequal ) 

-1
$.test_string_unequal x x {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .test_string_unequal ) 

-1
$.test_not_empty 
signal triggered: rwsh.bad_argc ( 0 1 0 .test_not_empty ) 

-1
$.test_not_empty x x
signal triggered: rwsh.bad_argc ( 2 1 0 .test_not_empty ) 

-1
$.test_not_empty x {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .test_not_empty ) 

-1
$.test_string_equal x y

1
$.test_string_equal x x

0
$.test_string_unequal x y

0
$.test_string_unequal x x

1
$.test_not_empty \

1
$.test_not_empty x

0
$

0
$# .test_is_number .test_number_equal .test_greater .test_less

0
$.test_is_number
signal triggered: rwsh.bad_argc ( 0 1 0 .test_is_number ) 

-1
$.test_is_number 42 {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .test_is_number ) 

-1
$.test_is_number ()

1
$.test_is_number 42a

1
$.test_is_number 42

0
$.test_is_number -0.314

0
$.test_is_number 6.022e9000000000

2
$.test_is_number 6.022e23

0
$.test_number_equal 42
signal triggered: rwsh.bad_argc ( 1 2 0 .test_number_equal ) 

-1
$.test_number_equal 42 42 {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .test_number_equal ) 

-1
$.test_number_equal 42 42a
signal triggered: rwsh.not_a_number ( 42a .test_number_equal ) 

-1
$.test_number_equal 42b 42
signal triggered: rwsh.not_a_number ( 42b .test_number_equal ) 

-1
$.test_number_equal 0 0.000000000000000000000000001

1
$.test_number_equal 1e-9000000000 1e-9000000001
signal triggered: rwsh.input_range ( 1e-9000000000 .test_number_equal ) 

-1
$.test_number_equal 0 0.0

0
$.test_number_equal 42 42.01

1
$.test_number_equal 42 42

0
$.test_number_equal 6.022e9000000000 .6022e24
signal triggered: rwsh.input_range ( 6.022e9000000000 .test_number_equal ) 

-1
$.test_number_equal 6.022e23 .6022e9000000001
signal triggered: rwsh.input_range ( .6022e9000000001 .test_number_equal ) 

-1
$.test_number_equal 6.022e23 6.022e2

1
$.test_number_equal 6.022e23 .6022e24

0
$.test_greater 6.022e23
signal triggered: rwsh.bad_argc ( 1 2 0 .test_greater ) 

-1
$.test_greater 6.022e23c 6.022e23 {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .test_greater ) 

-1
$.test_greater 6.022e23c 6.022e23
signal triggered: rwsh.not_a_number ( 6.022e23c .test_greater ) 

-1
$.test_greater 6.022e23 6.022e23e
signal triggered: rwsh.not_a_number ( 6.022e23e .test_greater ) 

-1
$.test_greater 6.022e9000000000 .6022e23
signal triggered: rwsh.input_range ( 6.022e9000000000 .test_greater ) 

-1
$.test_greater 6.022e23 .6022e9000000001
signal triggered: rwsh.input_range ( .6022e9000000001 .test_greater ) 

-1
$.test_greater 6.022e2 6.022e23

1
$.test_greater 6.022e23 .6022e24

1
$.test_greater 6.022e23 6.022e2

0
$.test_less 6.022e23
signal triggered: rwsh.bad_argc ( 1 2 0 .test_less ) 

-1
$.test_less 6.022b23 6.022e23 {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .test_less ) 

-1
$.test_less 6.022b23 6.022e23
signal triggered: rwsh.not_a_number ( 6.022b23 .test_less ) 

-1
$.test_less 6.022e23 6.022a23
signal triggered: rwsh.not_a_number ( 6.022a23 .test_less ) 

-1
$.test_less 6.022e9000000000 .6022e23
signal triggered: rwsh.input_range ( 6.022e9000000000 .test_less ) 

-1
$.test_less 6.022e23 .6022e9000000001
signal triggered: rwsh.input_range ( .6022e9000000001 .test_less ) 

-1
$.test_less 6.022e23 6.022e2

1
$.test_less 6.022e23 .6022e24

1
$.test_less 6.022e2 6.022e23

0
$

0
$# .toggle_readline

0
$.toggle_readline excess
signal triggered: rwsh.bad_argc ( 1 0 0 .toggle_readline ) 

-1
$.toggle_readline {excess}
signal triggered: rwsh.excess_argfunction ( .toggle_readline ) 

-1
$.return 0

0
$.nop .toggle_readline

0
$.nop .toggle_readline

0
$

0
$# .which_executable .which_test .which_return

0
$# Arg_script::str() but only an unknown fraction of the lines

0
$# Arg_spec::str() (except trailing whitespace) only through SOON case

0
$.which_test
signal triggered: rwsh.bad_argc ( 0 1 0 .which_test ) 

-1
$.which_test j

1
$.which_test #

0
$.which_test rwsh.mapped_argfunction

1
$.which_test rwsh.mapped_argfunction {rwsh.argfunction}

0
$.which_executable
signal triggered: rwsh.bad_argc ( 0 1 0 .which_executable ) 

-1
$.which_executable j

1
$.which_executable #
.function_all_flags # -- [ignored ...] {
  .local ret $?
  .if .var_exists ignored {.nop $ignored}
  .else {.nop}
  .nop $ret $?
  .return 0
  .return $ret}
0
$w rwsh.mapped_argfunction {.nop 1 () \ \\ \$ \@ \) \(}
{.nop 1 () ( \\) \$ \@ \) \(}
0
$w rwsh.mapped_argfunction {.nop 1 () \  \\ \$ \@ \) \(}
{.nop 1 () ( ) \\ \$ \@ \) \(}
0
$w rwsh.mapped_argfunction {@a @$a @$1 @$* @$*2}
{@a @$a @$1 @$*1 @$*2}
0
$w rwsh.mapped_argfunction {>dummy_file}
{>dummy_file}
0
$# new tests here

0
$w rwsh.mapped_argfunction {{&&{&&x &&{e}}$$$ ${&&x ${e}}$$$ {&&&x &&&{e} {&&&&x &&&&{e}}}}}
{{&{&x &{e}}$$$ ${&x ${e}}$$$ {&&x &&{e} {&&&x &&&{e}}}}}
0
$w rwsh.mapped_argfunction {$A $$A $0 $$$1 $# $* $*2 $A$$$ $A$10 $$*$ $$$*12$}
{$A $$A $0 $$$1 $# $* $*2 $A$$$ $A$10 $$*$ $$$*12$}
0
$w rwsh.mapped_argfunction {&&A &&0 &&* &&*3 &&$A$$$ &&$A$10 &&*$ &&*6$ {&&&A$ &&&A$10}}
{&A &0 &* &*3 &$A$$$ &$A$10 &*$ &*6$ {&&A$ &&A$10}}
0
$.function_all_flags wm [args ...] {
   w rwsh.mapped_argfunction {rwsh.argfunction}
   .echo $nl
   m $args$ {rwsh.argfunction}}

0
$wm (aa ab ac) bb cc {e x &&1 &2 $3 y &&1$1 z &&1$2; m &&1$ {e () w $* $#}}
{e x &1 bb $3 y &1$1 z &1$2; m &1$ {e () w $* $#}}
x aa ab ac bb cc y ab z ac w aa ab ac 4
0
$m (aa ab ac) bb cc {m $* {
  m &1 {echo $* $#}
  m &&1 {echo $* $#}
  m &&&1 {echo $* $#}
  m $1 {echo $* $#}
  m $1$ {echo $* $#}}}
((aa ab ac)) 2 
(aa ab ac) 2 
(aa ab ac) 2 
(aa ab ac) 2 
aa ab ac 4 

0
$wm () {.echo \\\ \ \\\ \\\\ \ \\|\\\ \  \  \\ \( \) \\\)}
{.echo (\\  \\ \\\\) ( \\|\\  ) ( ) \\ \( \) \\)}
\  \ \\  \|\     \ ( ) \)
0
$wm () {.echo (\\  \\ \\\\) ( \\|\\  ) ( ) (\\) (\() (\)) (\\\))}
{.echo (\\  \\ \\\\) ( \\|\\  ) ( ) \\ \( \) \\)}
\  \ \\  \|\     \ ( ) \)
0
$wm () {.echo a\\bc\\d\\\\e fg\\|\\hij klm \\ \) \( \\\(}
{.echo a\\bc\\d\\\\e fg\\|\\hij klm \\ \) \( \\(}
a\bc\d\\e fg\|\hij klm \ ) ( \(
0
$wm () {
.echo \( \) \\( \\) \\\( \\\) \\\\( \\\\) \\\\\( \\\\\)}
{
.echo \( \) \\( \\) \\( \\) \\\\( \\\\) \\\\( \\\\)}
( ) \( \) \( \) \\( \\) \\( \\)
0
$wm () {
.echo \) \( \\) \\( \\\) \\\( \\\\) \\\\( \\\\\) \\\\\(}
{
.echo \) \( \\) \\( \\) \\( \\\\) \\\\( \\\\) \\\\(}
) ( \) \( \) \( \\) \\( \\) \\(
0
$wm () {.echo () xx(yy \$ \@ \$$ \@@ }
{.echo () xx(yy \$ \@ $$ @@}
 xx(yy $ @ $$ @@
0
$wm () {.echo (  ) (	) (
)}
{.echo (  ) (	) (
)}
   	 

0
$w rwsh.mapped_argfunction {.nop 1}
{.nop 1}
0
$w rwsh.mapped_argfunction {@a @$a @$1 @$* @$*2}
{@a @$a @$1 @$*1 @$*2}
0
$w rwsh.mapped_argfunction {>dummy_file}
{>dummy_file}
0
$

0
$.which_executable rwsh.mapped_argfunction

1
$.which_executable rwsh.mapped_argfunction {rwsh.argfunction}
{rwsh.argfunction}
0
$.waiting_for_shell j
signal triggered: rwsh.bad_argc ( 1 0 0 .waiting_for_shell ) 

-1
$.waiting_for_shell {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .waiting_for_shell ) 

-1
$# .waiting_for_shell

-1
$.waiting_for_user j
signal triggered: rwsh.bad_argc ( 1 0 0 .waiting_for_user ) 

-1
$.waiting_for_user {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .waiting_for_user ) 

-1
$# .waiting_for_user

-1
$.waiting_for_binary j
signal triggered: rwsh.bad_argc ( 1 0 0 .waiting_for_binary ) 

-1
$.waiting_for_binary {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .waiting_for_binary ) 

-1
$# .waiting_for_binary

-1
$.which_return
signal triggered: rwsh.bad_argc ( 0 1 0 .which_return ) 

-1
$.which_return rwsh.mapped_argfunction

1
$.which_return rwsh.mapped_argfunction {echo not tracked}
0
0
$.which_return j

1
$.which_return .which_return
1
0
$.which_return .waiting_for_binary
-1
0
$

0
$# .which_last_exception

0
$.which_last_exception .which_last_exception

0
$.which_last_exception
signal triggered: rwsh.bad_argc ( 0 1 0 .which_last_exception ) 

-1
$.which_last_exception .try_catch_recursive {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .which_last_exception ) 

-1
$.which_last_exception .which_last_exception
rwsh.excess_argfunction .which_last_exception .try_catch_recursive {excess argfunc}
0
$.which_last_exception .which_last_return

1
$.which_last_exception .try_catch_recursive
rwsh.not_a_number A .return rwsh.mapped_argfunction .try_catch_recursive rwsh.mapped_argfunction .try_catch_recursive rwsh.not_a_number {.try_catch_recursive rwsh.not_a_number {.return A}}; rwsh.excessive_exceptions_in_catch 0 .try_catch_recursive rwsh.mapped_argfunction .try_catch_recursive rwsh.not_a_number {.try_catch_recursive rwsh.not_a_number {.return A}}
0
$.which_last_exception .which_last_execution_time

0
$.which_last_exception /bin/which

1
$.which_last_exception /bin/cat
rwsh.file_open_failure dummy_file /bin/cat <dummy_file
0
$.which_last_exception /bin/echo

0
$.which_last_exception e

0
$.which_last_exception test_var_greater
rwsh.bad_args -- var value (value 3) (var n)  12 test_var_greater n 3 12
0
$

0
$# .usleep .which_execution_count .which_last_execution_time

0
$# .which_total_execution_time

0
$.usleep_overhead excess
signal triggered: rwsh.bad_argc ( 1 0 0 .usleep_overhead ) 

-1
$.usleep_overhead {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .usleep_overhead ) 

-1
$.usleep_overhead 

1
$.usleep
signal triggered: rwsh.bad_argc ( 0 1 0 .usleep ) 

-1
$.usleep 800 {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .usleep ) 

-1
$.usleep -6
signal triggered: rwsh.input_range ( -6 .usleep ) 

-1
$.usleep 5i
signal triggered: rwsh.not_a_number ( 5i .usleep ) 

-1
$.usleep 800

0
$# .usleep_overhead 

0
$.which_execution_count
signal triggered: rwsh.bad_argc ( 0 1 0 .which_execution_count ) 

-1
$.which_execution_count j

1
$.which_execution_count rwsh.mapped_argfunction {echo not tracked}
0
0
$.which_execution_count .usleep
5
0
$.which_last_execution_time
signal triggered: rwsh.bad_argc ( 0 1 0 .which_last_execution_time ) 

-1
$.which_last_execution_time j

1
$.which_last_execution_time rwsh.mapped_argfunction {echo not tracked}
0.000000
0
$# .which_last_execution_time .usleep

0
$.which_total_execution_time
signal triggered: rwsh.bad_argc ( 0 1 0 .which_total_execution_time ) 

-1
$.which_total_execution_time rwsh.mapped_argfunction {echo not tracked}
0.000000
0
$.which_total_execution_time j

1
$# .which_total_execution_time .usleep

1
$

1
$# .which_path

1
$.which_path cat
signal triggered: rwsh.bad_argc ( 1 2 0 .which_path ) 

-1
$.which_path cat /bin {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .which_path ) 

-1
$.which_path cat \

1
$.which_path does<not>exist /bin:/usr/bin

1
$.which_path cat /bin:/usr/bin
/bin/cat
0
$

0
$# .while

0
$.function tf {.test_string_unequal $A $N}

0
$.set A 0

0
$.set N 4

0
$.while {e ARGS}
signal triggered: rwsh.bad_argc ( 0 1 0 .while ) 

-1
$.while tf
signal triggered: rwsh.missing_argfunction ( .while ) 

-1
$.while tf {e printed; .set A 4}
printed
0
$.while tf {e skipped}

-1
$.while .return 0 {.throw .echo exception within while}
exception within while .throw rwsh.mapped_argfunction .while
-1
$.set A 0

0
$.while tf {e in .while argfunction $A $nl; .var_add A 1}
in .while argfunction 0 
in .while argfunction 1 
in .while argfunction 2 
in .while argfunction 3 

0
$.set A 0

0
$.while tf {.if .return $A {.set A 1}
           .else {.function tf {.return 1}}
           e in overwriting argfunction $nl}
in overwriting argfunction 
in overwriting argfunction 

0
$

0
$# .var_add

0
$.var_add
signal triggered: rwsh.bad_argc ( 0 2 0 .var_add ) 

-1
$.var_add A 1 2
signal triggered: rwsh.bad_argc ( 3 2 0 .var_add ) 

-1
$.var_add A 1 {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .var_add ) 

-1
$.var_add B 1
signal triggered: rwsh.undefined_variable ( B .var_add ) 

-1
$.set A A

0
$.var_add A 2 
signal triggered: rwsh.not_a_number ( A .var_add ) 

-1
$.set A 1e309

0
$.var_add A 2 
signal triggered: rwsh.input_range ( 1e309 .var_add ) 

-1
$.set A -1e308

0
$.var_add A A
signal triggered: rwsh.not_a_number ( A .var_add ) 

-1
$.var_add A 1e309
signal triggered: rwsh.input_range ( 1e309 .var_add ) 

-1
$.var_add A -1e308
signal triggered: rwsh.result_range ( -1e308 -1e308 .var_add ) 

-1
$.var_add A 1e308

0
$.var_add A 1e308

0
$e $A
1e+308
0
$.var_add A 1e308
signal triggered: rwsh.result_range ( 1e+308 1e308 .var_add ) 

-1
$.var_add A -1e308

0
$e $A
0
0
$.var_add A \
signal triggered: rwsh.not_a_number (  .var_add ) 

-1
$e $A
0
0
$

0
$# .var_divide

0
$.var_divide A
signal triggered: rwsh.bad_argc ( 1 2 0 .var_divide ) 

-1
$.var_divide A 1 2
signal triggered: rwsh.bad_argc ( 3 2 0 .var_divide ) 

-1
$.var_divide A 1 {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .var_divide ) 

-1
$.var_divide B 1
signal triggered: rwsh.undefined_variable ( B .var_divide ) 

-1
$.set A A

0
$.var_divide A 2 
signal triggered: rwsh.not_a_number ( A .var_divide ) 

-1
$.set A 1e3000000000

0
$.var_divide A 2 
signal triggered: rwsh.input_range ( 1e3000000000 .var_divide ) 

-1
$.set A 16.8

0
$.var_divide A A
signal triggered: rwsh.not_a_number ( A .var_divide ) 

-1
$.var_divide A 1e3000000000
signal triggered: rwsh.input_range ( 1e3000000000 .var_divide ) 

-1
$.var_divide A 0 
signal triggered: rwsh.divide_by_zero ( 16.8 .var_divide ) 

-1
$.var_divide A 4.2 

0
$e $A
4
0
$.set A 1.8e-20

0
$.var_divide A 1e308
signal triggered: rwsh.result_range ( 1.8e-20 1e308 .var_divide ) 

-1
$.set A 0

0
$.var_divide A 1e308

0
$e $A
0
0
$

0
$# .var_subtract

0
$.var_subtract
signal triggered: rwsh.bad_argc ( 0 2 0 .var_subtract ) 

-1
$.var_subtract A 1 2
signal triggered: rwsh.bad_argc ( 3 2 0 .var_subtract ) 

-1
$.var_subtract A 1 {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .var_subtract ) 

-1
$.var_subtract B 1
signal triggered: rwsh.undefined_variable ( B .var_subtract ) 

-1
$.set A A

0
$.var_subtract A 2 
signal triggered: rwsh.not_a_number ( A .var_subtract ) 

-1
$.set A 3000000000

0
$.var_subtract A 2 

0
$.set A 1e308

0
$.var_subtract A -1e308
signal triggered: rwsh.result_range ( 1e308 -1e308 .var_subtract ) 

-1
$e $A
1e308
0
$.set A -1e308

0
$.var_subtract A 1e308
signal triggered: rwsh.result_range ( -1e308 1e308 .var_subtract ) 

-1
$e $A
-1e308
0
$.set A -2147483648

0
$.var_subtract A A
signal triggered: rwsh.not_a_number ( A .var_subtract ) 

-1
$.var_subtract A 3000000000

0
$.var_subtract A -2147483648

0
$.var_subtract A 2147483647

0
$.var_subtract A 2147483647

0
$e $A
-7.29496e+09
0
$.var_subtract A 2147483647

0
$.var_subtract A -2147483648

0
$e $A
-7.29496e+09
0
$.var_subtract A \
signal triggered: rwsh.not_a_number (  .var_subtract ) 

-1
$e $A
-7.29496e+09
0
$

0
$# .version .version_compatible

0
$.version 1.0
signal triggered: rwsh.bad_argc ( 1 0 0 .version ) 

-1
$.version {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .version ) 

-1
$.version_compatible
signal triggered: rwsh.bad_argc ( 0 1 0 .version_compatible ) 

-1
$.version_compatible 1.0 1.0
signal triggered: rwsh.bad_argc ( 2 1 0 .version_compatible ) 

-1
$.version_compatible 1.0 {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .version_compatible ) 

-1
$.version
0.3+
0
$.version_compatible 1.0
signal triggered: rwsh.version_incompatible ( 1.0 .version_compatible ) 

-1
$.version_compatible 0.3+

0
$

0
$# binary test implicitly tests Old_argv_t

0
$/bn/echo 1 2 3
signal triggered: rwsh.binary_not_found ( /bn/echo ) 
signal triggered: rwsh.return_code ( 65280 /bn/echo ) 

-1
$.which_return /bn/echo
65280
0
$/bin/echo 1 2 3
1 2 3

0
$

0
$# internal functions 

0
$# rwsh.after_command rwsh.raw_command rwsh.prompt

0
$# all of these are used as part of the test itself. If this changes, then the 

0
$# following tests will fail.

0
$w rwsh.after_command
.function rwsh.after_command {
  .set last_command_return $?
  .echo $nl; .echo $last_command_return; .echo $nl}
0
$w rwsh.prompt
.function rwsh.prompt {.echo \$}
0
$w rwsh.raw_command
.function rwsh.raw_command {.echo $1; .echo $nl}
0
$

0
$# rwsh.arguments_for_argfunction rwsh.before_command rwsh.binary_not_found

0
$w x {rwsh.escaped_argfunction me}
signal triggered: rwsh.arguments_for_argfunction ( rwsh.escaped_argfunction ) 

-1
$f rwsh.before_command {.echo $*0; .echo $nl}

0
$/bn
rwsh.before_command /bn
signal triggered: rwsh.binary_not_found ( /bn ) 
signal triggered: rwsh.return_code ( 65280 /bn ) 

-1
$.which_return /bn
rwsh.before_command .which_return /bn
65280
0
$f rwsh.before_command
rwsh.before_command f rwsh.before_command

0
$

0
$# rwsh.autofunction

0
$w z

1
$f rwsh.autofunction {e $*0 $nl}

0
$z 1 2 3
rwsh.autofunction z 1 2 3 
signal triggered: rwsh.executable_not_found ( z 1 2 3 ) 

-1
$w z

1
$f rwsh.autofunction {y $*0}

0
$z 1 2 3
signal triggered: rwsh.executable_not_found ( y rwsh.autofunction z 1 2 3 rwsh.autofunction ) 
signal triggered: rwsh.executable_not_found ( z 1 2 3 ) 

-1
$w z

1
$f rwsh.autofunction {f $1 {e $* $nl}}

0
$z 1 2 3
1 2 3 

0
$w z
.function z {e $* $nl}
0
$f rwsh.autofunction

0
$

0
$# rwsh.double_redirection

0
$# m {e hi #>dummy_file >dummy_file}

0
$# m {e hi >dummy_file}

0
$# m {e &{e hi #>dummy_file}}

0
$

0
$# rwsh.executable_not_found

0
$m {m {x; e should not be printed}}
signal triggered: rwsh.executable_not_found ( rwsh.autofunction x rwsh.mapped_argfunction m rwsh.mapped_argfunction m ) 
signal triggered: rwsh.executable_not_found ( x rwsh.mapped_argfunction m rwsh.mapped_argfunction m ) 

-1
$f rwsh.executable_not_found

0
$w rwsh.executable_not_found

1
$w x

1
$x
rwsh.autofunction : command not found ( rwsh.autofunction x ) 
x : command not found ( x ) 

-1
$w rwsh.executable_not_found
.function rwsh.executable_not_found {.echo $1 (: command not found) \( $* \) (
)
.return -1}
0
$

0
$# rwsh.mapped_argfunction rwsh.unescaped_argfunction rwsh.argfunction

0
$# rwsh.escaped_argfunction

0
$rwsh.mapped_argfunction 1 2 3 {e a $* a}
a 1 2 3 a
0
$rwsh.mapped_argfunction
rwsh.mapped_argfunction : command not found ( rwsh.mapped_argfunction ) 

-1
$f g {w rwsh.argfunction {rwsh.unescaped_argfunction}
     w rwsh.argfunction {rwsh.argfunction}
     w rwsh.argfunction {rwsh.escaped_argfunction}}

0
$g {}
{w rwsh.argfunction {}
     w rwsh.argfunction {rwsh.argfunction}
     w rwsh.argfunction {rwsh.escaped_argfunction}}{}{rwsh.argfunction}
0
$

0
$# rwsh.excessive_nesting Base_executable::exception_handler

0
$f g {h}

0
$f h {g}

0
$g
signal triggered: rwsh.excessive_nesting ( h g h g h g h g h g h g h g h g h g h g h g ) 

-1
$.stepwise g {e $* $nl; $*}
h 
signal triggered: rwsh.excessive_nesting ( g h g h g h g h g h g h g h g h g h g h rwsh.mapped_argfunction .stepwise ) 

-1
$f rwsh.excessive_nesting {h}

0
$g
Exception for failed handler. Original exception with call stack:
rwsh.excessive_nesting h g h g h g h g h g h g h g h g h g h g h g
Exception for failed handler. Original exception with call stack:
rwsh.excessive_nesting h g h g h g h g h g h g h g h g h g h g h rwsh.excessive_nesting

-1
$f rwsh.excessive_nesting {e &&{.return 1}}

0
$f rwsh.failed_substitution {e $Z}

0
$g
Exception for failed handler. Original exception with call stack:
rwsh.excessive_nesting h g h g h g h g h g h g h g h g h g h g h g
Exception for failed handler. Original exception with call stack:
rwsh.failed_substitution &{.return 1} rwsh.excessive_nesting
signal triggered: rwsh.undefined_variable ( Z rwsh.failed_substitution ) 

-1
$e_after {.try_catch_recursive rwsh.undefined_variable rwsh.excessive_nesting rwsh.failed_substitution {g}}
Exception for failed handler. Original exception with call stack:
rwsh.excessive_nesting g h g h g h g h g h g h g h g h g rwsh.mapped_argfunction .try_catch_recursive rwsh.mapped_argfunction m e_after
Exception for failed handler. Original exception with call stack:
rwsh.failed_substitution &{.return 1} rwsh.excessive_nesting
signal triggered: rwsh.undefined_variable ( Z rwsh.failed_substitution ) 
signal triggered: rwsh.excessive_exceptions_in_catch ( 0 .try_catch_recursive rwsh.mapped_argfunction m e_after ) 

-1
$.set_max_extra_exceptions 5

0
$e_after {.try_catch_recursive rwsh.undefined_variable rwsh.excessive_nesting rwsh.failed_substitution {g}}
signal triggered: rwsh.undefined_variable ( Z rwsh.failed_substitution ) 
Exception for failed handler. Original exception with call stack:
rwsh.excessive_nesting g h g h g h g h g h g h g h g h g rwsh.mapped_argfunction .try_catch_recursive rwsh.mapped_argfunction m e_after
Exception for failed handler. Original exception with call stack:
rwsh.failed_substitution &{.return 1} rwsh.excessive_nesting
signal triggered: rwsh.undefined_variable ( Z rwsh.failed_substitution ) 
Exception for failed handler. Original exception with call stack:
rwsh.failed_substitution &{.return 1} rwsh.excessive_nesting .try_catch_recursive rwsh.mapped_argfunction m e_after

-1
$e_after {.try_catch_recursive rwsh.undefined_variable rwsh.failed_substitution {
  e ${.return 1}}}
signal triggered: rwsh.undefined_variable ( Z rwsh.failed_substitution ) 
Exception for failed handler. Original exception with call stack:
rwsh.failed_substitution ${.return 1} rwsh.mapped_argfunction .try_catch_recursive rwsh.mapped_argfunction m e_after
signal triggered: rwsh.undefined_variable ( Z rwsh.failed_substitution ) 

-1
$f rwsh.else_without_if {e ${.return 1}}

0
$e_after {.try_catch_recursive rwsh.undefined_variable rwsh.else_without_if {
  .else {}}}
Exception for failed handler. Original exception with call stack:
rwsh.else_without_if .else rwsh.mapped_argfunction .try_catch_recursive rwsh.mapped_argfunction m e_after
Exception for failed handler. Original exception with call stack:
rwsh.failed_substitution ${.return 1} rwsh.else_without_if
signal triggered: rwsh.undefined_variable ( Z rwsh.failed_substitution ) 
Exception for failed handler. Original exception with call stack:
rwsh.failed_substitution ${.return 1} rwsh.else_without_if .try_catch_recursive rwsh.mapped_argfunction m e_after

-1
$f rwsh.failed_substitution {e ${.return 2}}

0
$e_after {.try_catch_recursive rwsh.undefined_variable rwsh.failed_substitution {
  e ${.return 1}}}
Exception for failed handler. Original exception with call stack:
rwsh.failed_substitution ${.return 1} rwsh.mapped_argfunction .try_catch_recursive rwsh.mapped_argfunction m e_after
Exception for failed handler. Original exception with call stack:
rwsh.failed_substitution ${.return 2} rwsh.failed_substitution
Exception for failed handler. Original exception with call stack:
rwsh.failed_substitution ${.return 2} rwsh.failed_substitution .try_catch_recursive rwsh.mapped_argfunction m e_after
Exception for failed handler. Original exception with call stack:
rwsh.failed_substitution ${.return 2} rwsh.failed_substitution .try_catch_recursive rwsh.mapped_argfunction m e_after
Exception for failed handler. Original exception with call stack:
rwsh.failed_substitution ${.return 2} rwsh.failed_substitution .try_catch_recursive rwsh.mapped_argfunction m e_after
Exception for failed handler. Original exception with call stack:
rwsh.failed_substitution ${.return 2} rwsh.failed_substitution .try_catch_recursive rwsh.mapped_argfunction m e_after
Exception for failed handler. Original exception with call stack:
rwsh.failed_substitution ${.return 2} rwsh.failed_substitution .try_catch_recursive rwsh.mapped_argfunction m e_after
signal triggered: rwsh.excessive_exceptions_in_catch ( 5 .try_catch_recursive rwsh.mapped_argfunction m e_after ) 

-1
$f rwsh.else_without_if {e $Z}

0
$e_after {.try_catch_recursive rwsh.undefined_variable rwsh.else_without_if {
  .else {}}}
signal triggered: rwsh.undefined_variable ( Z rwsh.else_without_if ) 
Exception for failed handler. Original exception with call stack:
rwsh.else_without_if .else rwsh.mapped_argfunction .try_catch_recursive rwsh.mapped_argfunction m e_after
signal triggered: rwsh.undefined_variable ( Z rwsh.else_without_if ) 

-1
$f rwsh.failed_substitution {.return Z}

0
$e_after {.try_catch_recursive rwsh.not_a_number rwsh.failed_substitution {
  e ${.return 1}}}
signal triggered: rwsh.not_a_number ( Z .return rwsh.failed_substitution ) 
Exception for failed handler. Original exception with call stack:
rwsh.failed_substitution ${.return 1} rwsh.mapped_argfunction .try_catch_recursive rwsh.mapped_argfunction m e_after
signal triggered: rwsh.not_a_number ( Z .return rwsh.failed_substitution ) 

-1
$

0
$# .throw

0
$.throw
signal triggered: rwsh.bad_argc ( 0 1 0 .throw ) 

-1
$.throw .nop

-1
$.throw rwsh.not_a_number 7
signal triggered: rwsh.not_a_number ( 7 .throw ) 

-1
$m {if_only .return 0 {.throw m {echo even from $* 7 is a number}}}
even from .throw rwsh.mapped_argfunction .if if_only rwsh.mapped_argfunction m 7 is a number 

-1
$m {.try_catch_recursive echo {
      echo first
      .throw echo failing successfully
      echo second}
   echo third}
first 
failing successfully .throw rwsh.mapped_argfunction 
third 

0
$

0
$# rwsh.run_logic

0
$f rwsh.run_logic {.if .return $1 {.nop}; .else_if $*2 {.nop}; .else {.nop}}

0
$0 e don't print nuthin'

0
$1 e do print
do print
0
$1 f rwsh.run_logic

0
$1 e executable not found
rwsh.autofunction : command not found ( rwsh.autofunction 1 e executable not found ) 
1 : command not found ( 1 e executable not found ) 

-1
$

0
$# rwsh.undefined_variable

0
$e $WRONG $WWRONG
signal triggered: rwsh.undefined_variable ( WRONG ) 

-1
$e &WWRONG
signal triggered: rwsh.undefined_variable ( WWRONG ) 

-1
$

0
$# rwsh.vars

0
$rwsh.vars
FIGNORE ?
0
$

0
$# check for extraneous variables

0
$/usr/bin/printenv
?=0
A=-7.29496e+09
FIGNORE=*de*
LC_ALL=C
N=4
last_command_return=0
nl=

original_message=Exception for failed handler. Original exception with call stack:


0
$

0
$# .list_environment

0
$.global SHELL unmodified

0
$/usr/bin/printenv
?=0
A=-7.29496e+09
FIGNORE=*de*
LC_ALL=C
N=4
SHELL=unmodified
last_command_return=0
nl=

original_message=Exception for failed handler. Original exception with call stack:


0
$.list_environment x
signal triggered: rwsh.bad_argc ( 1 0 0 .list_environment ) 

-1
$.list_environment {excess argfunc}
signal triggered: rwsh.excess_argfunction ( .list_environment ) 

-1
$for ${.list_environment}$ {
  .scope $1$ (var val) {
    .global $var $val}}

0
$e $TESTABILITY
an external variable
0
$e $SHELL
unmodified
0
$.unset TESTABILITY

0
$for ${.list_environment}$ {
  .scope $1$ (var val) {setf $var $val; .nop $$var}}

0
$e $TESTABILITY
an external variable
0
$e $SHELL
/bin/rwsh
0
$.set_max_collectible_exceptions 7

0
$.collect_errors_except .nop {${.throw echo exception from inside substitution}}
Exception for failed handler. Original exception with call stack:
rwsh.failed_substitution ${.throw echo exception from inside substitution} .collect_errors_except
signal triggered: rwsh.not_a_number ( Z .return rwsh.failed_substitution ) 

-1
$.collect_errors_only .nop {${.throw echo exception from inside substitution}}
Exception for failed handler. Original exception with call stack:
rwsh.failed_substitution ${.throw echo exception from inside substitution} .collect_errors_only
signal triggered: rwsh.not_a_number ( Z .return rwsh.failed_substitution ) 

-1
$

0
$## unused variables

0
$# bless_unused_variables

0
$.scope () {}

0
$.scope -- () {}

0
$.scope -- () {echo $--}
-- 

0
$.scope -- (-- [a]) {}
a was unused with call stack .scope 

-1
$.scope () {.local a n; .local b o; .local c p}
a was unused with call stack .scope 
b was unused with call stack .scope 
c was unused with call stack .scope 

-1
$.scope () {
  .local a n; .local b o; .local c p
  echo $a $b $c $d
  .local d too_late}
signal triggered: rwsh.undefined_variable ( d .scope ) 

-1
$.scope () {
  .local a n; .local b o; .local c p
  echo $d $a $b $c
  .local d too_late}
a was unused with call stack .scope 
b was unused with call stack .scope 
c was unused with call stack .scope 
signal triggered: rwsh.undefined_variable ( d .scope ) 

-1
$.scope n o p q (a b c d) {echo $a $b $c $d}
n o p q 

0
$.scope n o p q (a b c d) {echo a b c d}
a b c d 
a was unused with call stack .scope 
b was unused with call stack .scope 
c was unused with call stack .scope 
d was unused with call stack .scope 

-1
$.scope n o (a [b] c [d]) {echo $a $c }
n o 
b was not checked with call stack .scope 
d was not checked with call stack .scope 

-1
$.scope n o ([a] b [c] d) {echo $b $d; .var_exists a}
n o 
c was not checked with call stack .scope 

-1
$.scope n o ([a] b [c] d) {echo $b; .var_exists c}
n 
a was not checked with call stack .scope 
d was unused with call stack .scope 

-1
$.scope n ([a1 a2 a3 a4] b [c] [d1 d2] [e ...]) {echo $b}
n 
a1 was not checked with call stack .scope 
a2 was not checked with call stack .scope 
a3 was not checked with call stack .scope 
a4 was not checked with call stack .scope 
c was not checked with call stack .scope 
d1 was not checked with call stack .scope 
d2 was not checked with call stack .scope 
e was not checked with call stack .scope 

-1
$.scope n ([a1 a2 a3 a4] b [c] [d1 d2] [e ...]) {echo $b; .var_exists a4 d2 e c}
n 

1
$.scope n ([a1 a2 a3 a4] b [c] [d1 d2] [e ...]) {echo $b; .var_exists a3 d1}
n 
c was not checked with call stack .scope 
e was not checked with call stack .scope 

-1
$.scope n ([a1 a2 a3 a4] b [c] [d1 d2] [e ...]) {echo ${.list_locals} $b}
b n 

0
$.scope n o p q r s ([a1 a2 a3 a4] b [c] [d1 d2] [e ...]) {echo ${.list_locals} $b}
(a1 a2 a3 a4 b c) r 
a1 was unused with call stack .scope 
a2 was unused with call stack .scope 
a3 was unused with call stack .scope 
a4 was unused with call stack .scope 
c was unused with call stack .scope 

-1
$.scope n o p q r s t u ([a1 a2 a3 a4] b [c] [d1 d2]) {echo $a1 $d2}
n u 
a2 was unused with call stack .scope 
a3 was unused with call stack .scope 
a4 was unused with call stack .scope 
b was unused with call stack .scope 
c was unused with call stack .scope 
d1 was unused with call stack .scope 

-1
$.scope n o p q r s t u ([a1 a2 a3 a4] b [c] [d1 d2]) {
  echo $a1 $a2 $a3 $a4 $c $d1 $d2}
n o p q s t u 
b was unused with call stack .scope 

-1
$.scope ([-a a1 a2 a3] [-b] [-c] [-d d1]) {}
-a was not checked with call stack .scope 
a1 was not checked with call stack .scope 
a2 was not checked with call stack .scope 
a3 was not checked with call stack .scope 
-b was not checked with call stack .scope 
-c was not checked with call stack .scope 
-d was not checked with call stack .scope 
d1 was not checked with call stack .scope 
-* was unused with call stack .scope 

-1
$.scope ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {}
-a was not checked with call stack .scope 
a1 was not checked with call stack .scope 
a2 was not checked with call stack .scope 
a3 was not checked with call stack .scope 
-b was not checked with call stack .scope 
-c was not checked with call stack .scope 
-d was not checked with call stack .scope 
d1 was not checked with call stack .scope 
-? was unused with call stack .scope 
-* was unused with call stack .scope 

-1
$.scope ([-a a1 a2 a3] [-b] [-c] [-d d1]) {.var_exists -a -b -c -d}

1
$.scope ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {echo $-?; .var_exists -a -b -c -d}
() 

1
$.scope ([-a a1 a2 a3] [-b] [-c] [-d d1]) {.list_locals}
-*
0
$.scope -b -d darg ([-a a1 a2 a3] [-b] [-c] [-d d1]) {.list_locals; echo ()}
-* -b -d d1() 
d1 was unused with call stack .scope 
-d was unused with call stack .scope 
-* was unused with call stack .scope 

-1
$.scope ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {echo ${.list_locals} $-?}
(-* -?) () 

0
$.scope -b -d darg -v ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {echo ${.list_locals} $-?}
(-* -? -b -d d1) -v 
d1 was unused with call stack .scope 
-d was unused with call stack .scope 
-* was unused with call stack .scope 

-1
$.scope ([-a a1 a2 a3] [-d d1 d2]) {.var_exists a2 d2}

1
$.scope ([-?] [-a a1 a2 a3] [-d d1 d2]) {.var_exists -? a3 d1}
-? was unused with call stack .scope 
-* was unused with call stack .scope 

-1
$.scope ([-a a1 a2 a3] [-b] [-c] [-d d1]) {echo $-*}
() 

0
$.scope ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {echo $-*}
() 

0
$.scope n ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1] [e] f) {.local loc lval; echo $-*}
() 
e was not checked with call stack .scope 
f was unused with call stack .scope 
loc was unused with call stack .scope 

-1
$.scope -c ([-a a1 a2 a3] [-b] [-c] [-d d1]) {echo $-c}
-c 
-a was not checked with call stack .scope 
a1 was not checked with call stack .scope 
a2 was not checked with call stack .scope 
a3 was not checked with call stack .scope 
-b was not checked with call stack .scope 
-d was not checked with call stack .scope 
d1 was not checked with call stack .scope 
-* was unused with call stack .scope 

-1
$.scope -b -c ([-a a1 a2 a3] [-b] [-c] [-d d1]) {echo $-c; .var_exists -a -b -d}
-c 

0
$.scope -b -c ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {
  echo $-c; .var_exists -a -b -d -?}
-c 
-? was unused with call stack .scope 
-* was unused with call stack .scope 

-1
$.scope -b -c ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {
  echo $-c $-?; .var_exists -a -b -d}
-c () 

0
$.scope -b -c ([-a a1 a2 a3] [-b] [-c] [-d d1]) {echo $-b; .var_exists a2 d1}
-b 
-c was unused with call stack .scope 
-* was unused with call stack .scope 

-1
$.scope -a n o p -b -c -d q ([-a a1 a2 a3] [-b] [-c] [-d d1]) {
  echo $-c; .var_exists -a -b -d}
-c 
a1 was unused with call stack .scope 
a2 was unused with call stack .scope 
a3 was unused with call stack .scope 
-a was unused with call stack .scope 
d1 was unused with call stack .scope 
-d was unused with call stack .scope 
-* was unused with call stack .scope 

-1
$.scope -a n o p -b -c -d q ([-a a1 a2 a3] [-b] [-c] [-d d1]) {
  echo $-b; .var_exists a2 d1}
-b 
a1 was unused with call stack .scope 
a2 was unused with call stack .scope 
a3 was unused with call stack .scope 
-a was unused with call stack .scope 
-c was unused with call stack .scope 
d1 was unused with call stack .scope 
-d was unused with call stack .scope 
-* was unused with call stack .scope 

-1
$.scope -a n o p -b -c -d q ([-a a1 a2 a3] [-b] [-c] [-d d1]) {
  echo $-a $-b $-c $-d}
(-a n o p) -b -c (-d q) 

0
$.scope -a n o p -b -c -d q ([-a a1 a2 a3] [-b] [-c] [-d d1]) {
  echo $a1 $a2 $a3 $d1; .var_exists -b -c}
n o p q 

0
$.scope -a n o p -b -c -d q ([-a a1 a2 a3] [-b] [-c] [-d d1]) {
  echo $-*}
(-a n o p -b -c -d q) 

0
$.scope -v -a n o p -b -c -d q ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {
  echo $a1 $a2 $a3 $d1; .var_exists -b -c}
n o p q 
-? was unused with call stack .scope 
-* was unused with call stack .scope 

-1
$.scope -v -a n o p -b -c -d q ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {echo $-?}
-v 
a1 was unused with call stack .scope 
a2 was unused with call stack .scope 
a3 was unused with call stack .scope 
-a was unused with call stack .scope 
-b was unused with call stack .scope 
-c was unused with call stack .scope 
d1 was unused with call stack .scope 
-d was unused with call stack .scope 
-* was unused with call stack .scope 

-1
$.scope -v -a n o p -b -c -d q ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {echo $-*}
(-v -a n o p -b -c -d q) 

0
$.scope -a n o p ([-a a1 a2 a3]) {echo $a1 $a3}
n p 
a2 was unused with call stack .scope 
-a was unused with call stack .scope 
-* was unused with call stack .scope 

-1
$

0
$# exiting

0
$# rwsh.shutdown .exit

0
$.exit excess_argument
signal triggered: rwsh.bad_argc ( 1 0 0 .exit ) 

-1
$.exit {excess argfunction}
signal triggered: rwsh.excess_argfunction ( .exit ) 

-1
$.exit

0

now terminating normally
