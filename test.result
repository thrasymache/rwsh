init file /non-existent/file/to/test/failure does not exist
call stack .source .try_catch_recursive(body)
.global A \
.set SHELL /bin/rwsh
.nop .function .run_logic -- cmd [args ...] {.nop
  .signal_handler &{.internal_functions}$ {&&* {.argfunction}}
  .mapped_argfunction {&&* {.argfunction}}
  &&* {.argfunction}}
.function .before_command -- args ... [.{argfunction}] {.nop $args}
.function .after_command -- args ... [.{argfunction}] {.nop $args}
.function .prompt {.echo \$}
.function .vars {.internal_vars}
.source /etc/rwshrc-basic $argv$
#! /bin/rwsh --init-file
.function () {.nop}
.function # -- [ignored ...] [.{argfunction}] {.nop $ignored$}
.function fn -- prototype ... .{argfunction} {
  .function $prototype$ {.argfunction}}

# set up environment
.set_max_collectible_exceptions 10
.set_max_extra_exceptions 5
.global nl (
)
.if .var_exists ? {}
.else {.global ? (); .nop $?}
.nop $FIGNORE

# internal functions
.function .ambiguous_prototype_dash_dash prototype stack ... {
  .echo $prototype is an ambiguous location for a prototype --
  .combine ( (it requests reading the user's mind) ) \( stack: $stack \) $nl}
.function .arguments_for_argfunction name {
  echo cannot specify arguments for $name directly}
.function .bad_argfunction_style style {
  echo $style is neither an argfunction nor a substitution nor a brace literal}
.function .bad_args -- proto assigned needed excess call_stack ... {
  .combine (unacceptable arguments: for prototype ) $proto , $nl
  if_only .test_not_empty $assigned {
    .combine ( assigned )
    .for $assigned$ (-- var val) {.combine $var = ${paren_if_words $val} ( )}
    .combine , $nl ( but)}
  if_only .test_not_empty $needed {
    .combine ( needed \() $needed \), $nl
    if_only .test_not_empty $excess {.combine ( and)}}
  if_only .test_not_empty $excess {
    .combine ( found \() $excess (\) excess) $nl}
  echo \ call stack:  $call_stack}
.function .bad_if_nest stack ... {
  echo nested .if without .else with call stack: $stack$}
.function .binary_does_not_exist name [stack ...] {
  echo $name : binary does not exist
  if_only .var_exists stack {echo call stack: $stack}}
.function .binary_not_found name path stack ... {
  echo $name : binary not found in $path
  echo call stack: $stack$}
.function .break stack ... {
  echo .break thrown outside of control flow body
  echo call stack: $stack$}
.function .continue stack ... {
  echo .continue thrown outside of control flow body
  echo call stack: $stack$}
.function .dash_dash_argument args stack ... {
  echo optional -- parameter cannot take arguments \( $args \) with call stack: $stack$}
.function .dash_star_argument args stack ... {
  echo optional -* parameter cannot take arguments \( $args \) with call stack: $stack$}
.function .directory_not_found -- dir stack ... {
  .combine $dir ( directory does not exist) $nl
  echo call stack $stack}
.function .divide_by_zero numerator stack ... {
  echo attempt to divide $numerator by 0 with call stack: $stack$}
.function .double_redirection first second [stack ...] {
  echo double redirection is not supported at this time: $first and $second
  if_only .var_exists stack {echo call stack: $stack$}}
.function .duplicate_parameter -- parameter stack ... {
  echo duplicated parameter in function definition: $parameter
  echo call stack: $stack$}
.function .elipsis_first_arg -- elipsis stack ... {
  echo $elipsis elipsis cannot be the first argument in a prototype
  echo call stack: $stack$}
.function .elipsis_out_of_option_group -- group stack ... {
  echo $group for elipsis to apply to option it must occur within the brackets
  echo call stack: $stack$}
.function .else_without_if stack ... {
  echo else without if with call stack: $stack$}
.function .epsilon var_val change stack ... {
  echo $change is too small relative to $var_val to modify its value
  echo call stack: $stack$}
.function .excess_argfunction cmd [stack ...] {
  echo $cmd does not accept an argfunction with call stack: $cmd $stack$}
.function .excessive_exceptions_collected max stack ... {
  echo exceeded maximum number of exceptions \( $max \) in collect_errors.
  echo call stack: $stack$}
.function .excessive_exceptions_in_catch max stack ... {
  echo exceeded maximum number of exceptions \( $max \) in try_catch.
  echo call stack: $stack$}
.function .excessive_nesting stack ... {
  echo function exceeded max nesting \( ${.get_max_nesting} \). call stack: $stack}
.function .exec_failed binary errno stack ... {
  .combine (.exec failed for ) $binary ( with errno ) $errno $nl
  echo call stack $stack}
.function .executable_already_exists -- binary stack ... {
  echo $binary is already an executable in the hash table $nl
  echo call stack $stack}
.function .failed_substitution substitution [stack ...] {
  echo substitution $substitution failed
  if_only .var_exists stack {echo call stack: $stack$}}
.function .false test [stack ...] {
  echo assertion $test failed
  echo call stack $stack$}
.function .file_not_found -- file stack ... {
  echo could not find file $file
  echo call stack $stack}
.function .file_open_failure -- file stack ... {
  echo could not open file $file
  echo call stack $stack}
.function .fixed_argument -- arg stack ... {
  echo $arg : fixed arguments are not supported at this time
  echo call stack $stack}
.function .flag_in_elipsis -- flag group stack ... {
  echo found flag $flag while collecting arguments for elipsis in $group
  echo call stack $stack$}
.function .function_not_found -- cmd [stack ...] {
  echo $cmd : command not found \( $cmd $stack$ \)}
.function .global_would_be_masked name stack ... {
  .echo requested global $name already exists as a local
  echo . It would be masked by the local and inaccessible from here
  echo call stack $stack$}
.function .help [args ...] {
  .nop $args$
  .echo this is the default configuration for rwsh \(or something copied from it
  echo \), documentation should be available at rwsh.sf.net or rwsh.org}
.function .if_before_else stack ... {
  echo two .if commands without a .else between them with call stack : $stack$}
.function .illegal_function_name name stack ... {
  .combine \$ $name ( cannot be a function) $nl
  echo call stack $stack}
.function .illegal_variable_name name stack ... {
  .combine \$ $name ( cannot be set) $nl
  echo call stack $stack}
.function .input_range -- value stack ... {
  echo value $value is out of usable numeric range
  echo call stack $stack$}
.function .internal_error -- [args ...] {
  echo internal error: $args$}
.function .interrupted_sleep [stack ...] {
  echo sleep was interrupted
  echo call stack $stack$}
.function .invalid_word_selection selection [stack ...] {
  echo $selection is not a valid word selection
  echo call stack $stack$}
.function .mismatched_brace context [stack ...] {
  echo mismatched brace: $context $stack$}
.function .mismatched_bracket context [stack ...] {
  echo mismatched bracket: $context
  if_only .var_exists stack {echo call stack: $stack$}}
.function .mismatched_parenthesis string [stack ...] {
  .echo signal triggered: $0 \( $string $stack$ \); .combine $nl
  echo mismatched parenthesis: $string
  echo call stack: $stack$}
.function .unclosed_parenthesis string [stack ...] {
  .echo signal triggered: $0 \( $string $stack$ \); .combine $nl
  echo mismatched parenthesis: $string
  echo call stack: $stack$}
.function .missing_argfunction cmd [add_stack ...] {
  echo $cmd requires an argfunction
  if_only .var_exists add_stack {echo stack $add_stack$}}
.function .multiple_argfunctions {
  echo multiple argfunctions not supported at this time}
.function .not_a_directory file stack ... {
  .combine $file ( is not a directory) $nl
  echo call stack $stack}
.function .not_a_function executable stack ... {
  .combine $executable ( is not a function) $nl
  echo call stack $stack}
.function .not_a_number -- nan stack ... {
  echo $nan is not a number
  echo call stack: $stack$}
.function .not_catching_exception stack ... {
  echo .replace_exception called outside of an exception handler
  echo call stack: $stack$}
.function .not_executable file stack ... {
  echo $file is not executable
  echo call stack: $stack$}
.function .not_soon_enough too_late [stack ...] {
  echo $too_late attempts to substitute after the command has been run
  if_only .var_exists stack {echo call stack $stack}}
.function .number_not_an_integer -- nan stack ... {
  echo $nan is a number but not an integer
  echo call stack: $stack$}
.function .post_elipsis_option -- flag stack ... {
  echo option $flag coming after an elipsis has no meaning
  echo call stack: $stack$}
.function .post_dash_dash_flag -- flag stack ... {
  echo flag option $flag occurs after -- in the prototype
  echo call stack: $stack$}
.function .prompt {.echo \$}
.function .result_range -- lhs rhs op [stack ...] {
  echo result of $op with arguments $lhs and $rhs is out of range
  echo call stack: $op $stack$}
.function .return_code code cmd [add_stack ...] {
  .if .test_in $cmd /usr/bin/test /bin/false {
    .replace_exception .false $cmd
    .nop $code $add_stack$}
  .else {
    .set ? $cmd returned $code
    echo $?$ : call stack $cmd $add_stack$}}
.function .selection_not_found not_found selection [stack ...] {
  .echo no file matching pattern $not_found
  if_only .test_string_unequal $not_found $selection {
    .echo () for selection $selection}
  .echo $nl
  if_only .var_exists stack {echo call stack: $stack$}}
.function .sigcont {
  echo received SIGCONT}
.function .sigchld {
  echo received SIGCHLD}
.function .sighup {
  echo received SIGHUP}
.function .sigint {
  .throw echo $nl received SIGINT}
.function .sigquit {
  echo received SIGQUIT}
.function .sigpipe {
  echo received SIGPIPE}
.function .sigterm {
  .throw echo $nl received SIGTERM}
.function .sigtstp {
  echo received SIGTSTP}
.function .siginfo {
  echo received SIGINFO}
.function .sigusr1 {
  echo received SIGUSR1}
.function .sigusr2 {
  echo received SIGUSR2}
.function .sigunknown {
  echo received unknown unix signal}
.function .shutdown -- [args ...] {.nop $args}
.function .tardy_flag -- flag stack ... {
  echo $flag flag comes too late in command
  echo call stack: $stack$}
.function .unchecked_variable -- var [stack ...] {
  echo $var was not checked with call stack $stack$}
.function .unclosed_brace context [stack ...] {
  echo unclosed brace: $context $stack$}
.function .undeclared_variable -- name [stack ...] {
  echo $name was not declared
  echo call stack: $stack$}
.function .undefined_variable -- name [stack ...] {
  echo optional variable $name was not defined
  echo call stack: $stack$}
.function .unfinished_if_block [stack ...] {
  echo conditional not finished within preceeding block
  if_only .var_exists stack {echo call stack: $stack$}}
.function .unreadable_dir dir errno [stack ...] {
  .combine (cannot read directory ) $dir \ \(errno\  $errno \) $nl
  echo call stack: $stack$}
.function .unrecognized_flag -- flag proto [stack ...] {
  echo $flag flag is unrecognized for $proto
  echo call stack: $stack$}
.function .unused_before_set -- var [stack ...] {
  echo attempt to set $var before making use of its initial value
  echo call stack $stack$}
.function .unused_variable -- var [stack ...] {
  echo $var was unused with call stack $stack$}
.function .variable_already_exists name stack ... {
  echo variable $name already exists
  echo call stack $stack$}
.function .version_incompatible version stack ... {
  echo this shell is not compatible with requested version $version
  echo call stack: $stack$}

# ability of functions to act as builtin wrappers
fn ! -- args ... {
  .if $args$ {.throw .false ${.echo ! $args}}
  .else {.nop}}
fn af -- [argv ...] .{argfunction} {.argfunction}
fn c -- text ... {.combine $text$}
fn e -- text ... {.echo $text}
fn do_while argv ... .{argfunction} {
  .try_catch_recursive .break {
    .nop $argv
    .try_catch_recursive .continue {.argfunction}
    .while $argv$ {.argfunction}}}
fn echo -- text ... {.echo $text; .combine $nl}
fn echo-comments argv ... {
  .stepwise $argv$ (-- cmd [args ...]) {.nop $args$
    if_only .test_in $cmd .nop # #! ## {echo &&&*}}}
fn exec -- argv ... {.exec $argv$}
fn elif command ... .{argfunction} {
  .else_if $command$ {.argfunction}}
fn else .{argfunction} {.else {.argfunction}}
fn fns -- name args ... .{argfunction} {fn $name [-?] $args$ {.argfunction}}
fn if_only -- args ... .{argfunction} {
  .if $args$ {.argfunction}; .else {.nop}}
fn if_only_not -- args ... .{argfunction} {
  .if $args$ {.nop}; .else {.argfunction}}
fn ntimes n .{argfunction} {
  .while test_var_greater n 0 {
    .mapped_argfunction {.argfunction}
    .var_subtract n 1}}
fn outer_break stack ... {.replace_exception .break $stack$}
fn outer_continue stack ... {.replace_exception .continue $stack$}
fn forj -- [vals ...] .{argfunction} {.for $vals$ (-- j) {.argfunction}}
fn foreok -- [items ...] prototype .{argfunction} {
  .if .var_exists items {.for $items$ $prototype {.argfunction}}
  .else {.nop $prototype}}
fn outer_for -- vals ... var .{argfunction} {
  .for $vals$ $var {
    .try_catch_recursive outer_break outer_continue {.argfunction}}}
fn outer_while -- argv ... .{argfunction} {
  .while $argv$ {
    .try_catch_recursive outer_break outer_continue {.argfunction}}}
fn setf -- var value {
  .if .var_exists $var {.set $var $value}
  .else {.global $var $value}}
fn single -- args ... {.scope ${$args$}$ result {echo $result}}
fn test_var_not_equal var value {.test_string_unequal $$var $value}
fn test_var_greater -- var value {.test_greater $$var $value}
fn type [-t] args ... [.{argfunction}] {
  .for $args$ (-- name ...) {
    .try_catch_recursive .function_not_found {
      if_only_not .var_exists -t {.echo &&&name is ()}
      .type &&&1 {.argfunction}}}}
fn whence command [.{argfunction}] {
  .try_catch_recursive .function_not_found {
    .whence_function $command {.argfunction}}}
fn whichp binary {.which_path $binary $PATH}
fn while_and_one_more argv ... .{argfunction} {
  .try_catch_recursive .break {
    .while $argv$ {.argfunction}
    .try_catch_recursive .continue {.argfunction}}}
fn var_exists -- var {.var_exists $var}
fn var_in var set ... {.test_in $$var $set$}
fn var_less var N {.test_less $$var $N}
fn var_val -- [vars ...] {
  .if .var_exists vars {.for $vars$ (-- v ...) {.combine $v \( $$v \) \ }}
  .else {.nop}}
fn paren_if_words -- value {
  .if .test_number_equal ${.argc $value$} 1 {.combine $value}
  .else {.combine \( $value \)}}
fn polish -- operator builtin {
  fn &&operator -- lhs rhs [extra ...] {
    if_only .test_in $lhs + - / * {
      .reinterpret ${$lhs $rhs $extra$}$ (-- lhs rhs [extra ...])}
    if_only .test_in $rhs + - / * {
      .reinterpret ${$rhs $extra$}$ (-- rhs [extra ...])}
    &&builtin lhs $rhs
    echo $lhs $extra$}}
polish + .var_add
polish / .var_divide
polish % .var_modulo
polish * .var_multiply
polish - .var_subtract
fn rpn -- [extra ...] lhs rhs operator {
  if_only .test_in $rhs + - / * % {
    .reinterpret ${rpn $extra$ $lhs $rhs}$ (-- [extra ...] lhs rhs)}
  if_only .test_in $lhs + - / * % {
    .reinterpret ${rpn $extra$ $lhs}$ (-- [extra ...] lhs)}
  echo $extra$ ${$operator $lhs $rhs}$}

# external commands tested in the test suite
fn false {.try_catch_recursive .return_code {${whichp false}}}
fn ln [-?] [-t directory] target ... {
  .nop $-* $target # in case the following assertion fails
  .fork .mapped_argfunction {
    if_only .var_exists -t {.cd $directory}
    .for $target$ (-- j ...) {.test_file_exists $j}
    .exec &{.which_path ln /bin:/usr/bin} $-? -t . $target$}}
fn test -- args ... {.try_catch_recursive .return_code {${whichp test} $args$}}
if_only .var_exists argv {.error ignored excess arguments $argv $nl}
.function .shutdown -- args ... {
  .nop $args
  .combine $nl (now terminating normally) $nl}
$.binary /bin/cat
$/bin/cat /tmp/lcl
/etc/rwshrc ./rwsh --init-file test_init.rwsh 
$.function ## [args ...] {.nop $args}
$#
$.nop beware the empty comment
$
$## argm
$# .source
$.nop
$     .nop
$.nop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
$echo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
$.scope  ()    1                2       (a ...) {.echo $a$ $# $nl}
 1 2 4 
$.scope \escaped internal\ space (a ...) {.echo $a$ $# $nl}
escaped internal space 3 
$.scope now \ external\  (a ...) {.echo $a$ $# $nl}
now  external  3 
$.scope a \  space (a ...) {.echo $a$ $# $nl}
a   space 4 
$echo \$tokens \} \{ \; \\ \) \(
$tokens } { ; \ ) (
$.echo a \
a $line continuation (or it was supposed to be)
PATH was not declared
call stack: .autofunction .autofunction
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction
line : command not found ( line continuation (or it was supposed to be) )
$ echo ignore leading space
ignore leading space
$	echo ignore leading tab
ignore leading tab
$.mapped_argfunction {	   echo ignore leading tab in argfunction}
ignore leading tab in argfunction
$.whence_function .mapped_argfunction {.nop}
{.nop}
$.whence_function .argfunction {
  multiple line argfunction }
{
  multiple line argfunction}
$.nop .argfunction .mismatched_brace } x{}}&&&is$not$all
mismatched brace: (.nop .argfunction .mismatched_brace })
x is neither an argfunction nor a substitution nor a brace literal
mismatched brace: (.nop .argfunction .mismatched_brace } x{}})
$not$all is not a valid word selection
call stack
&&&is$not$all attempts to substitute after the command has been run
$.source
unacceptable arguments: for prototype -- file [args ...],
 needed (file),
( call) stack: .source
$.source /etc/hosts {excess argfunc}
.source does not accept an argfunction with call stack: .source
$.source test_files/*fu*bar*
could not open file test_files/*fu*bar*
call stack .source
$.source /etc/hosts
/etc/hosts is not executable
call stack: .source
$.source test_files/unclosed_brace.rwsh
fn bar {echo baz

unclosed brace: (fn bar) .source
argv was not checked with call stack .source
$.source test_files/unclosed_brace_without_newline.rwsh
fn bar {echo baz

unclosed brace: (fn bar) .source
argv was not checked with call stack .source
$.source test_files/unclosed_dot_brace.rwsh
echo bar .{argfunction baz

unclosed brace: (echo bar .{) .source
argv was not checked with call stack .source
$.source test_files/unclosed_parenthesis.rwsh
echo bar (baz

signal triggered: .unclosed_parenthesis ( echo bar ( .source )
mismatched parenthesis: (echo bar ()
call stack: .source
argv was not checked with call stack .source
$.source test_files/unclosed_parenthesis_without_newline.rwsh
echo bar (baz

signal triggered: .unclosed_parenthesis ( echo bar ( .source )
mismatched parenthesis: (echo bar ()
call stack: .source
argv was not checked with call stack .source
$.source test_files/multiple_errors.rwsh
echo first; echo second ;echo third
first
second
third
fn bar {echo &&&baz$$bax
  cat >something >else
  }
$$bax is not a valid word selection
call stack .source
&&&baz$$bax attempts to substitute after the command has been run
call stack .source
double redirection is not supported at this time: >something and >else
call stack: .source
argv was not checked with call stack .source
$.source test_files/bad_substitution.rwsh
echo before error
before error
echo the error ${.throw echo nonexistent} was there
nonexistent .throw test_files/bad_substitution.rwsh .source
substitution (${.throw echo nonexistent}) failed
call stack: .source
argv was not checked with call stack .source
$.nop multiple statements \; on a line
$.whence_function .argfunction {.multiple_argfunctions} {}
multiple argfunctions not supported at this time
$.whence_function .argfunction {.argfunction with text args}
cannot specify arguments for (.argfunction with text args!) directly
$.whence_function .argfunction {.argfunction {with a function arg}}
cannot specify arguments for (.argfunction {with a function arg}!) directly
$.whence_function x {.escaped_argfunction me}
cannot specify arguments for (.escaped_argfunction me!) directly
$.whence_function .argfunction {{{{{{{{{{{}}}}}}}}}}}
{{{{{{{{{{{}}}}}}}}}}}
$.whence_function .argfunction {
  .function  x  { ${ .which_path  echo  $PATH }  something } }
{
  .function x { ${ .which_path echo $PATH} something}}
$
$## ability of functions to perform custom control flow
$# rwshrc-basic
$.function echoe -- text ... {.nop $text; .echo $*}
$.function echow -- text ... {.echo $text$; .combine $nl}
$.function sa [args ...] .{argfunction} {
  .scope $args$ ([args ...]) {.argfunction}}
$.function se .{argfunction} {.scope () {.argfunction}}
$.whence_function echoe
.function echoe -- text ... {.nop $text; .echo $*}
$.whence_function sa
.function sa [args ...] .{argfunction} {
  .scope $args$ ([args ...]) {.argfunction}}
$.whence_function se
.function se .{argfunction} {.scope () {.argfunction}}
$whence echoe
.function echoe -- text ... {.nop $text; .echo $*}
$whence echo
.function echo -- text ... {.echo $text; .combine $nl}
$whence ee
ee : command not found ( ee .whence_function .try_catch_recursive(body) )
$whence () {}
.function ()  {.nop}
$echo text that does not have a prompt appended
text that does not have a prompt appended
$se {echo again}
again
$if_only .test_is_number false {echo not printed}
$if_only .test_is_number 0 {echo printed without error}
printed without error
$foreok k {echo skipped without error}
$foreok 1 2 3 k {echo loop $k}
loop 1
loop 2
loop 3
$
$## arg_script.cc and arg_spec.cc
$# Arg_spec::FIXED, Arg_script::add_quote
$echo 5 4 3 2 1
5 4 3 2 1
$sa a (tight string created by parentheses $#) {echow $args$ $#}
a tight string created by parentheses $# 3
$sa a ( spaced string created by parentheses $# ) {echow $args$ $#}
a  spaced string created by parentheses $#  3
$.scope some escaped \) \(parentheses (a b c d) {echo $a $b $c $d $#}
some escaped ) (parentheses 5
$sa some (nested (parentheses) $#) {echow $args$ $#}
some nested (parentheses) $# 3
$sa some ((((((((((repeated))))) parentheses))))) {echow $args$ $#}
some (((((((((repeated))))) parentheses)))) 3
$sa a (multi-line parenthesis
  enclosed string) {echow $args$ $#}
a multi-line parenthesis
  enclosed string 3
$echo a )mismatched &&parenthesis
signal triggered: .mismatched_parenthesis ( echo a ) )
mismatched parenthesis: (echo a ))
call stack:
&&parenthesis attempts to substitute after the command has been run
$echo a (multi-line parenthesis
  mismatch))
signal triggered: .mismatched_parenthesis ( echo a (multi-line parenthesis
  mismatch)) )
mismatched parenthesis: (echo a (multi-line parenthesis
  mismatch)))
call stack:
$echoe (internal \)parenthesis \\ escape ( \))); .combine $nl
internal )parenthesis \ escape ( ))
$.argc (internal \)parenthesis \\ escape ( \))); .combine $nl
1
$
$# star_var (argm_star_var)
$.scope 1 2 3 4 (a b c d) {echo $a $b $* $c $d \$*}
1 2 1 2 3 4 3 4 $*
$.scope 1 2 1 2 (a b c d) {echo $a $b $*3}
1 2 1 2
c was unused with call stack .scope
d was unused with call stack .scope
$
$# star_soon
$sa .nop 1 2 3 {
  .if $args$ {echo &&*}
  .else {}}
.nop 1 2 3
$sa .nop 1 2 3 {
  .if $args$ {echo &&*0}
  .else {}}
.scope .nop 1 2 3
$
$# .init, rwshrc's autofunction, .binary
$whence .init
.function .init -- [args ...] {.set_max_nesting 10
    .function .file_open_failure name stack ... {.nop
        .combine (init file ) $name ( does not exist
call stack ) $stack (
)}
    .function .raw_command -- args ... {.nop $args}
    .collect_errors_except .nop {.nop
      .source /etc/rwshrc $args$
      .for &{.internal_functions}$ (func ...) {.nop
        .if .test_executable_exists $func {.nop}
        .else {.echo &&&func not defined (
)}}
      .if .test_executable_exists .help {.nop
        .if .test_not_empty ${.help} {.nop}
        .else {.echo .help produces no output (
)}}
      .else {.echo .help not defined (
)}}}
$whence .autofunction
.function .autofunction -- cmd [args ...] [.{argfunction}] {.nop
  .if .var_exists args {.nop $args}
  .else {.nop}
  .nop {argfunction}
  .local full_path ${.which_path $cmd $PATH}
  .if .test_executable_exists $full_path {.nop}
  .else {.binary $full_path}
  .if .test_string_equal $cmd $full_path {.nop}
  .else {.function $cmd -- [args ...] {&full_path $args$}}
  .error added $cmd to executable map $nl}
$whence .binary
.binary file
$.binary {echo excess argfunction}
unacceptable arguments: for prototype file,
 needed (file),
( call) stack: .binary
.binary does not accept an argfunction with call stack: .binary
$.binary /bin/rzwsh
/bin/rzwsh : binary does not exist
call stack: .binary
$.binary /bin/cat
/bin/cat is already an executable in the hash table (
)
call stack .binary
$.global PATH /usr/bin
$/bin/true
/bin/true : binary not found in /usr/bin
call stack: .which_path .autofunction .autofunction
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction
/bin/true : command not found ( /bin/true )
$true
true : binary not found in /usr/bin
call stack: .which_path .autofunction .autofunction
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction
true : command not found ( true )
$.binary /bin/true
$true
true : binary not found in /usr/bin
call stack: .which_path .autofunction .autofunction
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction
true : command not found ( true )
$.rm_executable /bin/true
$.set PATH /bin:/usr/bin:.
$fals
fals : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction
fals : command not found ( fals )
$/bin/true add the binary by itself
$true add the function using existing binary
$.whence_function /usr/bin/env
/usr/bin/env : command not found ( /usr/bin/env .whence_function )
$env false add the function and the binary at once
/usr/bin/env returned 1 : call stack /usr/bin/env env
$.whence_function true
.function true -- [args ...] {/bin/true $args$}
$/bin/echo this will add /bin/echo to the hash table
this will add /bin/echo to the hash table
$/bin/echo this will use the existing /bin/echo reference
this will use the existing /bin/echo reference
$echo this function is already defined
this function is already defined
$.autofunction ./rwsh
$.whence_function ./rwsh
./rwsh
$./rwsh -c (echo in a subshell)
in a subshell
$false
assertion /bin/false failed
call stack .replace_exception .mapped_argfunction .if .return_code .try_catch_recursive false
$if_only_not false {echo false throwing a .false exception}
false throwing a .false exception
$./rwsh -c (env false)
/usr/bin/env returned 1 : call stack /usr/bin/env env .mapped_argfunction .collect_errors_except .mapped_argfunction .if .scope .source .collect_errors_except .init
./rwsh returned 1 : call stack ./rwsh
$./rwsh -c (.get_pid)
.get_pid : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction .mapped_argfunction .collect_errors_except .mapped_argfunction .if .scope .source .collect_errors_except .init
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction .mapped_argfunction .collect_errors_except .mapped_argfunction .if .scope .source .collect_errors_except .init
.get_pid : command not found ( .get_pid .mapped_argfunction .collect_errors_except .mapped_argfunction .if .scope .source .collect_errors_except .init )
$./rwsh --init-file /non-existent/file/to/test/failure <test_files/pause_hello.rwsh
.ambiguous_prototype_dash_dash not defined 
.arguments_for_argfunction not defined 
.bad_argfunction_style not defined 
.bad_args not defined 
.bad_if_nest not defined 
.binary_does_not_exist not defined 
.binary_not_found not defined 
.break not defined 
.continue not defined 
.dash_dash_argument not defined 
.dash_star_argument not defined 
.directory_not_found not defined 
.divide_by_zero not defined 
.double_redirection not defined 
.duplicate_parameter not defined 
.elipsis_first_arg not defined 
.elipsis_out_of_option_group not defined 
.else_without_if not defined 
.epsilon not defined 
.excess_argfunction not defined 
.excessive_exceptions_collected not defined 
.excessive_exceptions_in_catch not defined 
.excessive_nesting not defined 
.exec_failed not defined 
.executable_already_exists not defined 
.failed_substitution not defined 
.false not defined 
.file_not_found not defined 
.fixed_argument not defined 
.flag_in_elipsis not defined 
.function_not_found not defined 
.global_would_be_masked not defined 
.if_before_else not defined 
.illegal_function_name not defined 
.illegal_variable_name not defined 
.input_range not defined 
.internal_error not defined 
.interrupted_sleep not defined 
.invalid_word_selection not defined 
.mismatched_brace not defined 
.mismatched_bracket not defined 
.mismatched_parenthesis not defined 
.missing_argfunction not defined 
.multiple_argfunctions not defined 
.not_a_directory not defined 
.not_a_function not defined 
.not_a_number not defined 
.not_catching_exception not defined 
.not_executable not defined 
.not_soon_enough not defined 
.number_not_an_integer not defined 
.return_code not defined 
.result_range not defined 
.post_elipsis_option not defined 
.post_dash_dash_flag not defined 
.prompt not defined 
.selection_not_found not defined 
.sighup not defined 
.sigint not defined 
.sigquit not defined 
.sigpipe not defined 
.sigterm not defined 
.sigtstp not defined 
.sigcont not defined 
.sigchld not defined 
.sigusr1 not defined 
.sigusr2 not defined 
.sigunknown not defined 
.tardy_flag not defined 
.unchecked_variable not defined 
.unclosed_brace not defined 
.unclosed_parenthesis not defined 
.undeclared_variable not defined 
.undefined_variable not defined 
.unfinished_if_block not defined 
.unreadable_dir not defined 
.unrecognized_flag not defined 
.unused_before_set not defined 
.unused_variable not defined 
.variable_already_exists not defined 
.version_incompatible not defined 
.help not defined 
init file /non-existent/file/to/test/failure does not exist
call stack .source .mapped_argfunction .if .scope .source .collect_errors_except .init
Exception for failed handler. Original exception with call stack:
.binary_not_found .prompt /bin:/usr/bin:. .which_path .autofunction .autofunction
.binary_not_found : command not found ( .binary_not_found .prompt /bin:/usr/bin:. .which_path .autofunction .autofunction )
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
.failed_substitution : command not found ( .failed_substitution ${.which_path $cmd $PATH} .autofunction )
.prompt : command not found ( .prompt )
Exception for failed handler. Original exception with call stack:
.binary_not_found .binary_not_found /bin:/usr/bin:. .which_path .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.binary_not_found .failed_substitution /bin:/usr/bin:. .which_path .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.binary_not_found .prompt /bin:/usr/bin:. .which_path .autofunction .autofunction
.binary_not_found : command not found ( .binary_not_found .prompt /bin:/usr/bin:. .which_path .autofunction .autofunction )
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
.failed_substitution : command not found ( .failed_substitution ${.which_path $cmd $PATH} .autofunction )
.prompt : command not found ( .prompt )
Exception for failed handler. Original exception with call stack:
.binary_not_found .binary_not_found /bin:/usr/bin:. .which_path .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.binary_not_found .failed_substitution /bin:/usr/bin:. .which_path .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.binary_not_found .prompt /bin:/usr/bin:. .which_path .autofunction .autofunction
.binary_not_found : command not found ( .binary_not_found .prompt /bin:/usr/bin:. .which_path .autofunction .autofunction )
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
.failed_substitution : command not found ( .failed_substitution ${.which_path $cmd $PATH} .autofunction )
.prompt : command not found ( .prompt )
Exception for failed handler. Original exception with call stack:
.binary_not_found .binary_not_found /bin:/usr/bin:. .which_path .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.binary_not_found .failed_substitution /bin:/usr/bin:. .which_path .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
hello world 
Exception for failed handler. Original exception with call stack:
.binary_not_found .prompt /bin:/usr/bin:. .which_path .autofunction .autofunction
.binary_not_found : command not found ( .binary_not_found .prompt /bin:/usr/bin:. .which_path .autofunction .autofunction )
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
.failed_substitution : command not found ( .failed_substitution ${.which_path $cmd $PATH} .autofunction )
.prompt : command not found ( .prompt )
Exception for failed handler. Original exception with call stack:
.binary_not_found .binary_not_found /bin:/usr/bin:. .which_path .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.binary_not_found .failed_substitution /bin:/usr/bin:. .which_path .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.unused_variable FIGNORE
.unused_variable : command not found ( .unused_variable FIGNORE )
Exception for failed handler. Original exception with call stack:
.binary_not_found .unused_variable /bin:/usr/bin:. .which_path .autofunction .autofunction
.binary_not_found : command not found ( .binary_not_found .unused_variable /bin:/usr/bin:. .which_path .autofunction .autofunction )
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
.failed_substitution : command not found ( .failed_substitution ${.which_path $cmd $PATH} .autofunction )
Exception for failed handler. Original exception with call stack:
.binary_not_found .binary_not_found /bin:/usr/bin:. .which_path .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.binary_not_found .failed_substitution /bin:/usr/bin:. .which_path .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
./rwsh returned 10 : call stack ./rwsh
$./rwsh --init-file test_files/pause_hello.rwsh <test_files/pause_hello.rwsh
hello world 
.ambiguous_prototype_dash_dash not defined 
.arguments_for_argfunction not defined 
.bad_argfunction_style not defined 
.bad_args not defined 
.bad_if_nest not defined 
.binary_does_not_exist not defined 
.binary_not_found not defined 
.break not defined 
.continue not defined 
.dash_dash_argument not defined 
.dash_star_argument not defined 
.directory_not_found not defined 
.divide_by_zero not defined 
.double_redirection not defined 
.duplicate_parameter not defined 
.elipsis_first_arg not defined 
.elipsis_out_of_option_group not defined 
.else_without_if not defined 
.epsilon not defined 
.excess_argfunction not defined 
.excessive_exceptions_collected not defined 
.excessive_exceptions_in_catch not defined 
.excessive_nesting not defined 
.exec_failed not defined 
.executable_already_exists not defined 
.failed_substitution not defined 
.false not defined 
.file_not_found not defined 
.fixed_argument not defined 
.flag_in_elipsis not defined 
.function_not_found not defined 
.global_would_be_masked not defined 
.if_before_else not defined 
.illegal_function_name not defined 
.illegal_variable_name not defined 
.input_range not defined 
.internal_error not defined 
.interrupted_sleep not defined 
.invalid_word_selection not defined 
.mismatched_brace not defined 
.mismatched_bracket not defined 
.mismatched_parenthesis not defined 
.missing_argfunction not defined 
.multiple_argfunctions not defined 
.not_a_directory not defined 
.not_a_function not defined 
.not_a_number not defined 
.not_catching_exception not defined 
.not_executable not defined 
.not_soon_enough not defined 
.number_not_an_integer not defined 
.return_code not defined 
.result_range not defined 
.post_elipsis_option not defined 
.post_dash_dash_flag not defined 
.prompt not defined 
.selection_not_found not defined 
.sighup not defined 
.sigint not defined 
.sigquit not defined 
.sigpipe not defined 
.sigterm not defined 
.sigtstp not defined 
.sigcont not defined 
.sigchld not defined 
.sigusr1 not defined 
.sigusr2 not defined 
.sigunknown not defined 
.tardy_flag not defined 
.unchecked_variable not defined 
.unclosed_brace not defined 
.unclosed_parenthesis not defined 
.undeclared_variable not defined 
.undefined_variable not defined 
.unfinished_if_block not defined 
.unreadable_dir not defined 
.unrecognized_flag not defined 
.unused_before_set not defined 
.unused_variable not defined 
.variable_already_exists not defined 
.version_incompatible not defined 
.help not defined 
Exception for failed handler. Original exception with call stack:
.unchecked_variable argv .source .mapped_argfunction .if .scope .source .collect_errors_except .init
.unchecked_variable : command not found ( .unchecked_variable argv .source .mapped_argfunction .if .scope .source .collect_errors_except .init )
Exception for failed handler. Original exception with call stack:
.binary_not_found .unchecked_variable /bin:/usr/bin:. .which_path .autofunction .autofunction
.binary_not_found : command not found ( .binary_not_found .unchecked_variable /bin:/usr/bin:. .which_path .autofunction .autofunction )
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
.failed_substitution : command not found ( .failed_substitution ${.which_path $cmd $PATH} .autofunction )
Exception for failed handler. Original exception with call stack:
.binary_not_found .binary_not_found /bin:/usr/bin:. .which_path .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.binary_not_found .failed_substitution /bin:/usr/bin:. .which_path .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.binary_not_found .prompt /bin:/usr/bin:. .which_path .autofunction .autofunction
.binary_not_found : command not found ( .binary_not_found .prompt /bin:/usr/bin:. .which_path .autofunction .autofunction )
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
.failed_substitution : command not found ( .failed_substitution ${.which_path $cmd $PATH} .autofunction )
.prompt : command not found ( .prompt )
Exception for failed handler. Original exception with call stack:
.binary_not_found .binary_not_found /bin:/usr/bin:. .which_path .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.binary_not_found .failed_substitution /bin:/usr/bin:. .which_path .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.binary_not_found .prompt /bin:/usr/bin:. .which_path .autofunction .autofunction
.binary_not_found : command not found ( .binary_not_found .prompt /bin:/usr/bin:. .which_path .autofunction .autofunction )
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
.failed_substitution : command not found ( .failed_substitution ${.which_path $cmd $PATH} .autofunction )
.prompt : command not found ( .prompt )
Exception for failed handler. Original exception with call stack:
.binary_not_found .binary_not_found /bin:/usr/bin:. .which_path .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.binary_not_found .failed_substitution /bin:/usr/bin:. .which_path .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.binary_not_found .prompt /bin:/usr/bin:. .which_path .autofunction .autofunction
.binary_not_found : command not found ( .binary_not_found .prompt /bin:/usr/bin:. .which_path .autofunction .autofunction )
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
.failed_substitution : command not found ( .failed_substitution ${.which_path $cmd $PATH} .autofunction )
.prompt : command not found ( .prompt )
Exception for failed handler. Original exception with call stack:
.binary_not_found .binary_not_found /bin:/usr/bin:. .which_path .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.binary_not_found .failed_substitution /bin:/usr/bin:. .which_path .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
hello world 
Exception for failed handler. Original exception with call stack:
.binary_not_found .prompt /bin:/usr/bin:. .which_path .autofunction .autofunction
.binary_not_found : command not found ( .binary_not_found .prompt /bin:/usr/bin:. .which_path .autofunction .autofunction )
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
.failed_substitution : command not found ( .failed_substitution ${.which_path $cmd $PATH} .autofunction )
.prompt : command not found ( .prompt )
Exception for failed handler. Original exception with call stack:
.binary_not_found .binary_not_found /bin:/usr/bin:. .which_path .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.binary_not_found .failed_substitution /bin:/usr/bin:. .which_path .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.unused_variable FIGNORE
.unused_variable : command not found ( .unused_variable FIGNORE )
Exception for failed handler. Original exception with call stack:
.binary_not_found .unused_variable /bin:/usr/bin:. .which_path .autofunction .autofunction
.binary_not_found : command not found ( .binary_not_found .unused_variable /bin:/usr/bin:. .which_path .autofunction .autofunction )
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
.failed_substitution : command not found ( .failed_substitution ${.which_path $cmd $PATH} .autofunction )
Exception for failed handler. Original exception with call stack:
.binary_not_found .binary_not_found /bin:/usr/bin:. .which_path .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.binary_not_found .failed_substitution /bin:/usr/bin:. .which_path .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
./rwsh returned 10 : call stack ./rwsh
$./rwsh --init-file test_files/signal_triggered.rwsh <test_files/pause_hello.rwsh
signal triggered: .raw_command ( .function .shutdown -- [args ...] {.nop $args; .exit 255} )
.help not defined 
signal triggered: .prompt ( )
signal triggered: .raw_command ( #! /bin/rwsh )
signal triggered: .prompt ( )
signal triggered: .raw_command (  )
signal triggered: .prompt ( )
signal triggered: .raw_command ( .echo hello world (
) )
hello world 
signal triggered: .prompt ( )
signal triggered: .unused_variable ( FIGNORE )
./rwsh returned 255 : call stack ./rwsh
$./rwsh test_files/hello_argv.rwsh
hello 
$./rwsh test_files/hello_argv.rwsh world
hello world 
$.autofunction test_files/../rwsh
$whence test_files/../rwsh
.function test_files/../rwsh -- [args ...] {./test_files/../rwsh $args$}
$
$.function .autofunction -- cmd [args ...] {
  # $args$ redefining .autofunction tested by subsequent usage
  .local full_path ${.which_path $cmd $PATH}
  if_only_not .test_executable_exists $full_path {.binary $full_path}
  if_only_not .test_string_equal $cmd $full_path {
    .function $cmd -- [args ...] {
      &&full_path $args$
      echo this &&cmd function has been brought to you by .autofunction}}
  echo added $cmd to executable map in test suite}
$.binary /bin/rm
$
$# selection_read read_dir()
$echo @/etc
/etc
$echo @test_files/ixx
no file matching pattern test_files/ixx
$echo @test_files/i*xx
test_files/ixxx
$echo @test_files/i**xx
test_files/ixxx
$echo @test_files/ii**xx
no file matching pattern test_files/ii**xx
$echo @test_files/ix*xx
test_files/ixxx
$echo @test_files/ix*xx*
test_files/ixxx
$echo @test_files/ix*xxx
no file matching pattern test_files/ix*xxx
$echo @test_files/ix*xxx*
no file matching pattern test_files/ix*xxx*
$echo @test_files/*iixxx
no file matching pattern test_files/*iixxx
$echo @test_files/ix*x*x
test_files/ixxx
$echo @test_files/ix*xx*x
no file matching pattern test_files/ix*xx*x
$echo @test_files/ix*x*xx
no file matching pattern test_files/ix*x*xx
$.scope () {echo @test_files/i*xx/f*}
cannot read directory test_files/ixxx// (errno 20)
call stack: .scope
$.scope () {echo @/*selection_not_found*}
no file matching pattern /*selection_not_found*
call stack: .scope
$echo @/ur/bin/pwd
no file matching pattern /ur for selection /ur/bin/pwd
$echo @test_main.cc
no file matching pattern test_main.cc
$forj @e*c {echo $j}
executable.cc
executable_map.cc
$echo @test_files/*xx
test_files/ixxx
$echo @test_files/*x*x*x*x
no file matching pattern test_files/*x*x*x*x
$echo @test_files/*xyxy
test_files/ixyxyxy
$echo @/bin
/bin
$forj @/usr/*bin {echo $j}
/usr/bin
/usr/sbin
$forj @/etc/rwsh* {echo $j}
/etc/rwshrc
/etc/rwshrc-basic
/etc/rwshrc-default
$echo @/etc/rw*ic
/etc/rwshrc-basic
$echo @/etc/rwsh*a*
/etc/rwshrc-basic /etc/rwshrc-default
$.set FIGNORE rwshrc* rwshrc-bas rwshrc-default
$echo @/etc/rwshrc-*
/etc/rwshrc-basic
$echo @/etc/rwshrc*
/etc/rwshrc /etc/rwshrc-basic
$echo @/etc/rwshr*
no file matching pattern /etc/rwshr*
$.set FIGNORE *.cc
$echo @*cc
no file matching pattern *cc
$echo @*h.cc
rwsh.cc
$.set FIGNORE *de*
$echo @/etc/rwshrc-defa*
/etc/rwshrc-default
$echo @/etc/rwshrc-d*
no file matching pattern /etc/rwshrc-d*
$echo @/etc/rwsh*a*
/etc/rwshrc-basic
$echo @test_files/*i*x*y*y*x*
test_files/ixyxyxy
$echo @/etc/rw*-basi*si*
no file matching pattern /etc/rw*-basi*si*
$echo @test_main.sh
test_main.sh
$forj @test_files/*x* {echo $j}
test_files/ixxx
test_files/ixyxyxy
$.scope r*h.cc sel*.h (A ...) {echo @$A}
rwsh.cc selection.h
$
$# Arg_spec::REFERENCE, interpret(), evaluate_expansion(), evaluate_var()
$.nop $A
$.set A /bin
$.global B ( (zero   zero) ((one one  ) one   ) two three)
$.global C ((external) () ( ) internal(parenthesis))
$.global broken (extra_close\) \(extra_open)
$echo $A $0 @$A
/bin .interpret /bin
$.scope A 1 (a b) {echo $a $1 $b $$2 $$$2}
A A 1 A /bin
$echo A $1a
optional variable 1a was not defined
call stack:
$sa A 1 2 3 4 5 6 7 {echo $args$ $$$$$$$$$8}
A 1 2 3 4 5 6 7 /bin
$sa $UNDECLARED $ALSO_UNDECLARED {}
UNDECLARED was not declared
call stack:
$sa {echo $UNDECLARED $ALSO_UNDECLARED}
args was not checked with call stack .scope sa
UNDECLARED was not declared
call stack: .scope sa
$echo &UNDECLARED &ALSO_UNDECLARED
UNDECLARED was not declared
call stack:
$.scope [undefined] {echo $undefined and also unchecked}
undefined was not checked with call stack .scope
optional variable undefined was not defined
call stack: .scope
$.scope [udef] {echo but $udef$ can vanish}
but can vanish
$.scope ([-x foo bar]) {echo along with specific $-x$ flags}
along with specific flags
$.scope ([-x foo bar]) {echo note even one $bar$ prevents an error}
note even one prevents an error
$.scope [also_undefined] {echo even &&also_undefined$ in a soon}
even in a soon
$.scope undeclared ([leading_ud] ref) {echo references $$ref$ can throw}
leading_ud was not checked with call stack .scope
undeclared was not declared
call stack: .scope
$.scope leading_ud ([leading_ud] ref) {echo good $$ref$ ones are checked}
good ones are checked
$sa $B$$1x {echo $# $args$}
$$1x is not a valid word selection
call stack
$sa $B$$1$ {echo $# $args$}
$$1$ is not a valid word selection
call stack
$sa $B {echow $# $args$}
2  (zero   zero) ((one one  ) one   ) two three
$sa $B$ {echow $# $args$}
5 zero   zero (one one  ) one    two three
$sa $B$$ {echow $# $args$}
7 zero zero one one   one two three
$sa $B$$$$ {echo $# $args$}
8 zero zero one one one two three
$se {sa $B$$$$ {echo $# $args$}}
8 zero zero one one one two three
$sa $B$10 {echo $# $args$}
optional variable $B$10 was not defined
call stack:
$sa $B$1 {echow $# $args$}
2 (one one  ) one   
$sa $B$$1 {echo $# $args$}
2 zero
$.scope $broken arg {echoe $# $arg $nl}
2 extra_close) (extra_open 
$sa $broken$ {echo $# $args$}
signal triggered: .mismatched_parenthesis ( extra_close) )
mismatched parenthesis: extra_close)
call stack:
$sa $broken$$ {echo $# $args$}
signal triggered: .mismatched_parenthesis ( extra_close) )
mismatched parenthesis: extra_close)
call stack:
$sa $C {echow $# $args$}
2 (external) () ( ) internal(parenthesis)
$sa $C$ {echow $# $args$}
5 external    internal(parenthesis)
$sa $C$$ {echo $# $args$}
3 external internal(parenthesis)
$
$# Arg_spec::SOON, apply()
$.scope A 1 (a b) {echo $a &&1 $b &&$2 &&$$2}
A A 1 A /bin
$echo &&A
&&A attempts to substitute after the command has been run
$se {e &&&A}
&&&A attempts to substitute after the command has been run
$se {@{} e &&&without$A $.{mismatched} {.argfunction brace} &&&{thrown}B
}
@ is neither an argfunction nor a substitution nor a brace literal
$A is not a valid word selection
call stack
&&&without$A attempts to substitute after the command has been run
$. is neither an argfunction nor a substitution nor a brace literal
cannot specify arguments for (.argfunction brace!) directly
(B
) is not a valid word selection
call stack
(&&&{thrown}B
) attempts to substitute after the command has been run
$echo &{e &&A}
&&A attempts to substitute after the command has been run
$echo &&{e &A}
(&&{e &A}) attempts to substitute after the command has been run
$echo &A
/bin
$.scope not_bin A {echo &A &&A $A; .scope otherwise A {echo &A &&A &&&A $A}}
/bin not_bin not_bin
/bin not_bin otherwise otherwise
$se {sa &B$10 {echoe $# $args$}}
optional variable &B$10 was not defined
call stack:
$se {sa &B$$$$ {echo $# $args$}}
8 zero zero one one one two three
$se {sa &B$1 {echoe $# $args$} $nl}
3 (one one  ) one    
$se {sa &B$$1 {echo $# $args$}}
2 zero
$
$# Arg_spec::SUBSTITUTION and Arg_spec::SOON_SUBSTITUTION, apply(), interpret(),
$# evaluate_substitution()
$echo ${e $A}
/bin
$whence .argfunction {e ${e $A}}
{e ${e $A}}
$.scope not_bin A {
   echoe &{.echo $A} &&{.echo $A} $A $nl
   .scope otherwise A {
      echo &{.echo $A} &&{.echo $A} &&&{.echo $A} ${.echo $A} $A}}
/bin not_bin not_bin 
/bin not_bin otherwise otherwise otherwise
$.scope not_bin A {echoe &{.echo &A $A} &&{.echo &A &&A} ${.echo &A $A} $nl}
/bin /bin /bin not_bin /bin not_bin 
$sa &{.echo $A} {echo $args &1$}
/bin
$sa &{.throw .nop} {}
substitution (&{.throw .nop}) failed
$sa ${.throw .nop} {}
substitution (${.throw .nop}) failed
$se {e &{.throw .nop}}
substitution (&{.throw .nop}) failed
$se {e &&{.throw .nop}; e after}
substitution (&{.throw .nop}) failed
call stack: .scope se
$se {e &&{.throw .nop}; e after}
substitution (&{.throw .nop}) failed
call stack: .scope se
$.collect_errors_except .nop {
  ${.throw echo exception from inside substitution}
  echo after failed substitution}
after failed substitution
exception from inside substitution .throw .mapped_argfunction .collect_errors_except
substitution (${.throw echo exception from inside substitution}) failed
call stack: .collect_errors_except
$.collect_errors_only .failed_substitution echo {
  ${.throw echo exception from inside substitution}
  echo after failed substitution}
after failed substitution
exception from inside substitution .throw .mapped_argfunction .collect_errors_only
substitution (${.throw echo exception from inside substitution}) failed
call stack: .collect_errors_only
$.collect_errors_only .nop {
  ${.throw echo exception from inside substitution}
  echo after failed substitution}
exception from inside substitution .throw .mapped_argfunction .collect_errors_only
substitution (${.throw echo exception from inside substitution}) failed
call stack: .collect_errors_only
$echo before .{argfunction} between [.{argfunction}] after
before .{argfunction} between [.{argfunction}] after
$echo before ..{still bad} between [.{missing close} after
.. is neither an argfunction nor a substitution nor a brace literal
mismatched bracket: ([.{missing close})
$echo x{echo bad argfunction style}
x is neither an argfunction nor a substitution nor a brace literal
$echo x&&&{echo x}
x&&& is neither an argfunction nor a substitution nor a brace literal
$echo $+{echo x}
$+ is neither an argfunction nor a substitution nor a brace literal
$echo &+{echo x}
&+ is neither an argfunction nor a substitution nor a brace literal
$echo &&${echo x}
&&$ is neither an argfunction nor a substitution nor a brace literal
(&&${echo x}) attempts to substitute after the command has been run
$echo ${echo 0}
(0
)
$echo &{.echo 0}
0
$.echo nevermore &{/bin/echo quoth the raven} 
nevermore quoth the raven
$sa ${echo $B}$@1 ${echo $B}$1 ${echo $B}XYZ {echo $# $args$}
@1 is not a valid word selection
call stack
XYZ is not a valid word selection
call stack
$sa ${echoe $B} {echow $# $args$}
2  (zero   zero) ((one one  ) one   ) two three
$sa &{echoe $B} {echow $# $args$}
2  (zero   zero) ((one one  ) one   ) two three
$sa ${echoe $B}$ {echow $# $args$}
5 zero   zero (one one  ) one    two three
$sa &{echoe $B}$ {echow $# $args$}
5 zero   zero (one one  ) one    two three
$sa &{.echo $B}$ {echow $# $args$}
5 zero   zero (one one  ) one    two three
$se {echow $# &{echow $B}$}
1 zero   zero (one one  ) one    two three
$se {echo $# &{echo $B}$}
1 ( (zero   zero) ((one one  ) one   ) two three)
$sa &{echoe $B}$$ {echoe $# $args$ $nl}
7 zero zero one one   one two three 
$sa ${echoe $B}$$ {echoe $# $args$ $nl}
7 zero zero one one   one two three 
$se {sa ${echoe $B}$1 {echoe $# $args$ $nl}}
2 (one one  ) one    
$se {sa &{echoe $B}$1 {.echo $# $args$ $nl}}
2 (one one  ) one    
$se {sa ${echoe $B}$$$1 {echo $# $args$}}
2 zero
$se {sa &{echoe $B}$$$1 {echo $# $args$}}
2 zero
$.unset A
$.unset B
$sa &{echoe ((zero zero) (one one) two three)}$10 {echo $# $args$}
optional variable (&{echoe ((zero zero) (one one) two three)}$10) was not defined
call stack:
$sa ${echoe (zero zero) \)one one two three}$1 {echo $# $args$}
signal triggered: .mismatched_parenthesis ( zero zero ) )
mismatched parenthesis: (zero zero ))
call stack:
$sa &{echoe (zero zero) \(one one two three}$1 {echo $# $args$}
signal triggered: .mismatched_parenthesis ( zero zero (one one two three )
mismatched parenthesis: (zero zero (one one two three)
call stack:
$.scope ${echoe (zero zero) \)one one two three} arg {.echo $# $arg $nl}
2 zero zero )one one two three 
$c x &{.echo (y y)}$ x $nl
xyyx
$c x ${.echo ( y y )}$ x $nl
xyyx
$c x &{.echo (( y) (y ))}$ x $nl
x yy x
$c x ${.echo (    )}$ x $nl
xx
$c x &{.echo (
y
y
)}$ x $nl
xyyx
$
$# file redirection (but don't overwrite files that exist)
$# .for_each_line
$/bin/cat <non_existent_file
could not open file non_existent_file
call stack /bin/cat
$.for_each_line
unacceptable arguments: for prototype -- prototype ... .{argfunction},
 needed (prototype),
( call) stack: .for_each_line
.for_each_line requires an argfunction
$.for_each_line <non_existent_file argv {echo line of $# \( $argv$ \)}
could not open file non_existent_file
call stack .for_each_line
$se {sa {echo hi >one >two} {cat <three <four}
}
double redirection is not supported at this time: >one and >two
multiple argfunctions not supported at this time
double redirection is not supported at this time: <three and <four
$se {
  .if .test_file_exists outfile {echo failed to remove outfile}
  .else {echo outfile properly removed}}
outfile properly removed
$se {echo hi >outfile}
$/bin/cat outfile
hi
$se {
  .if .test_is_number 0 {>outfile /bin/echo there}
  .else {.nop}}
$/bin/cat outfile
there
$se {se >outfile {
  echo line 1; echo line 2 longer; .echo $nl; echo ending}}
$/bin/cat <outfile
line 1
line 2 longer

ending
$.for_each_line {}
unacceptable arguments: for prototype -- prototype ... .{argfunction},
 needed (prototype),
( call) stack: .for_each_line
$.for_each_line <outfile x
.for_each_line requires an argfunction
$.for_each_line <outfile <another A{}
double redirection is not supported at this time: <outfile and <another
A is neither an argfunction nor a substitution nor a brace literal
$.for_each_line <outfile argv ... {
  echo current line $argv$
  if_only .test_greater $2 1 {
    .collect_errors_except .nop {
      .throw .continue
      .throw .break
      .throw .continue}}
  .throw .continue
  echo not printed}
current line line 1
current line line 2 longer
$.for_each_line <outfile argv ... {
  echo line of $# \( $argv$ \); .throw echo exception in for_each_line}
line of 3 ( line 1 )
exception in for_each_line .throw .for_each_line(body) .for_each_line
$.for_each_line <outfile [argv ...] {echo line of $# \( $argv$ \)}
line of 3 ( line 1 )
line of 4 ( line 2 longer )
line of 1 ( )
line of 2 ( ending )
$.for_each_line <outfile first second [third] {
  .nop $first;
  if_only .var_exists third {.combine \(extra\ is\  $third \)\ }
  echo $second}
1
(extra is longer) 2
unacceptable arguments: for prototype first second [third],
 needed (first second),
( call) stack: (.for_each_line(body) .for_each_line)
$/bin/rm outfile
$
$# soon level promotion .get_max_nesting .set_max_nesting
$.get_max_nesting excess {excess argfunction}
unacceptable arguments: for prototype ,
 found (excess) excess
( call) stack: .get_max_nesting
.get_max_nesting does not accept an argfunction with call stack: .get_max_nesting
$.set_max_nesting {excess argfunction}
unacceptable arguments: for prototype -- maximum,
 needed (maximum),
( call) stack: .set_max_nesting
.set_max_nesting does not accept an argfunction with call stack: .set_max_nesting
$.global A 0
$.global OLD_NESTING ${.get_max_nesting}
$.set_max_nesting 46
$fn x .{argfunction} {.var_add A 1
     se {.var_add A 1
        se {.var_add A 1
           se {.var_add A 1
              se {.var_add A 1
                 se {.argfunction}}}}}}
$.scope 00 A {x {echo &A &&A &&&A $A}}
0 00 5 5
$.scope 00 A {x {x {x {x {echo &A &&A &&&A &&&&A &&&&&A &&&&&&A $A}}}}}
0 00 5 10 15 20 20
$.scope 00 A {
  x {echoe &{.echo &A $A} . &&{.echo &A &&A $A} . &&&{.echo &A &&A &&&A $A} . ${
  .echo &A &&A &&&A $A} . $A $nl}}
0 0 . 0 00 00 . 0 00 5 5 . 0 00 5 5 . 5 
$.set A 0
$x {x {x {x {
  echoe &{.echo &A $A} . &&{.echo &A &&A $A} . &&&{.echo &A &&A &&&A $A} . &&&&{
  .echo &A &&A &&&A &&&&A $A} . &&&&&{.echo &A &&A &&&A &&&&A &&&&&A $A} . ${
  .echo &A &&A &&&A &&&&A &&&&&A $A} . $A $nl}}}}
0 0 . 0 5 5 . 0 5 10 10 . 0 5 10 15 15 . 0 5 10 15 20 20 . 0 5 10 15 20 20 . 20 
$.rm_executable x
$.function not soon {&&&enough}
&&&enough attempts to substitute after the command has been run
$.set_max_nesting $OLD_NESTING
$.unset A
$.unset OLD_NESTING
$
$## builtin tests
$# .argc
$whence .argc
.argc -- [list ...]
$.argc {excess argfunc}
.argc does not accept an argfunction with call stack: .argc
$.scope () {.argc; .echo $nl}
0
$.scope () {.argc (); .echo $nl}
1
$.scope () {.argc (1 a) (2 b (c d)) (3 ((e () f))); .echo $nl}
3
$
$# .cd (.which_path ../)
$.cd
unacceptable arguments: for prototype -- path,
 needed (path),
( call) stack: .cd
$.cd /bin {excess argfunc}
.cd does not accept an argfunction with call stack: .cd
$.cd /bin /
unacceptable arguments: for prototype -- path,
 assigned path=/bin ,
 but found (/) excess
( call) stack: .cd
$.cd /bn
/bn directory does not exist
call stack .cd
$.cd /bin/rwsh
/bin/rwsh is not a directory
call stack .cd
$.fork .mapped_argfunction {
  .try_catch_recursive .binary_not_found {.which_path ../bin/rwsh /bin:.}
  .cd /bin
  .binary /bin/pwd
  echo directory is now ${/bin/pwd}$ in subshell
  .try_catch_recursive .binary_not_found {.which_path ../bin/rwsh /bin}
  .try_catch_recursive .binary_not_found {.which_path ../bin/rwsh /bin:.}
  .combine $nl}
../bin/rwsh : binary not found in /bin:.
call stack: .which_path .try_catch_recursive(body)
directory is now /bin in subshell
../bin/rwsh : binary not found in /bin
call stack: .which_path .try_catch_recursive(body)
../bin/rwsh
$
$# .combine
$.combine
unacceptable arguments: for prototype -- text ...,
 needed (text),
( call) stack: .combine
$.combine something {excess argfunc}
.combine does not accept an argfunction with call stack: .combine
$sa on () e \ two ( ) {.combine $args$ ${.argc $args$} $nl}
one two 5
$
$# .echo .error
$.error
unacceptable arguments: for prototype -- text ...,
 needed (text),
( call) stack: .error
$.error something {excess argfunc}
.error does not accept an argfunction with call stack: .error
$.nop .error cannot test error with a diff until you can redirect it $nl
$.echo
unacceptable arguments: for prototype -- text ...,
 needed (text),
( call) stack: .echo
$.echo something {excess argfunc}
.echo does not accept an argfunction with call stack: .echo
$.echo these are fixed strings $nl
these are fixed strings 
$
$# .exec .fork Binary Old_argv_t .binary_not_found
$.fork
unacceptable arguments: for prototype -- command ... [.{argfunction}],
 needed (command),
( call) stack: .fork
$.fork echo text
text
$.fork .exit 127
.fork returned 127 : call stack .fork
$.fork sa 126 {sa $args$ {echo about to return $args$; .exit $args$}}
about to return 126
.fork returned 126 : call stack .fork
$.exec
unacceptable arguments: for prototype -- command ...,
 needed (command),
( call) stack: .exec
$.exec something {excess argfunc}
.exec does not accept an argfunction with call stack: .exec
$.exec /bin/ech does not exist
/bin/ech : binary does not exist
call stack: .exec
$.exec /etc/rwshrc config files are not interpreters
/etc/rwshrc is not executable
call stack: .exec
$.exec /bin cannot exec a directory
/bin is not executable
call stack: .exec
$.exec /bin/rwsh/insanity errno is ENOTDIR
.exec failed for /bin/rwsh/insanity with errno 20
call stack .exec
$.fork se {.exec /bin/rwsh/insanity errno is ENOTDIR}
.exec failed for /bin/rwsh/insanity with errno 20
call stack (.exec .scope se)
.fork returned 255 : call stack .fork
$.fork se {.exec /bin/echo something; /bin/echo else}
something
$.scope () {.fork se {.exec /bn/echo 1 2 3}}
/bn/echo : binary does not exist
call stack: (.exec .scope se)
.fork returned 255 : call stack .fork .scope
$.fork se {/bn/echo 1 2 3}
/bn/echo : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction .scope se
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction .scope se
/bn/echo : command not found ( /bn/echo 1 2 3 .scope se )
.fork returned 255 : call stack .fork
$.last_exception /bn/echo
/bn/echo : command not found ( /bn/echo .last_exception )
$.exec /bn/echo 1 2 3
/bn/echo : binary does not exist
call stack: .exec
$/bn/echo 1 2 3
/bn/echo : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction
/bn/echo : command not found ( /bn/echo 1 2 3 )
$.last_exception /bn/echo
/bn/echo : command not found ( /bn/echo .last_exception )
$.fork se {/bn/echo 1 2 3}
/bn/echo : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction .scope se
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction .scope se
/bn/echo : command not found ( /bn/echo 1 2 3 .scope se )
.fork returned 255 : call stack .fork
$.fork .exec /bn/echo 1 2 3
/bn/echo : binary does not exist
call stack: .exec
.fork returned 255 : call stack .fork
$/bn/echo 1 2 3
/bn/echo : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction
/bn/echo : command not found ( /bn/echo 1 2 3 )
$.exec /bn/echo 1 2 3
/bn/echo : binary does not exist
call stack: .exec
$/bin/echo 1 2 3
1 2 3
$
$# .fallback_handler .get_fallback_message .set_fallback_message
$.fallback_handler
unacceptable arguments: for prototype -- command ... [.{argfunction}],
 needed (command),
( call) stack: .fallback_handler
$.fallback_handler something {excess argfunc}
Exception for failed handler. Original exception with call stack:
something
$.get_fallback_message something 
unacceptable arguments: for prototype ,
 found (something) excess
( call) stack: .get_fallback_message
$.get_fallback_message {excess argfunc}
.get_fallback_message does not accept an argfunction with call stack: .get_fallback_message
$.set_fallback_message
unacceptable arguments: for prototype message ...,
 needed (message),
( call) stack: .set_fallback_message
$.set_fallback_message something {excess argfunc}
.set_fallback_message does not accept an argfunction with call stack: .set_fallback_message
$.fallback_handler pretend_error
Exception for failed handler. Original exception with call stack:
pretend_error
$.local original_message &{.get_fallback_message}
$.set_fallback_message spaceless fallback message
$.fallback_handler second pretend error
spaceless fallback messagesecond pretend error
$.set_fallback_message (alternate fallback message: )
$.fallback_handler a third
alternate fallback message: a third
$.set_fallback_message $original_message
$.throw sa .throw {echo even from $args$ 7 is a number}
even from .throw .throw 7 is a number
$.fallback_handler .throw sa .throw {echo even from $args$ 7 is a number}
Exception for failed handler. Original exception with call stack:
.throw sa .throw
$.throw .throw sa {echo even from $args$ 7 is a number}
Exception for failed handler. Original exception with call stack:
.throw sa .throw
even from .throw .throw 7 is a number
$
$# .for
$.for q {echo no arguments $q}
unacceptable arguments: for prototype -- list ... prototype .{argfunction},
 assigned list=q ,
 but needed (prototype),
( call) stack: .for
$.for no_argfunction q
.for requires an argfunction
$.for 1 q {echo one argument $q}
one argument 1
$.for 1 2 q {echo one argument $q; .throw echo exception in for}
one argument 1
exception in for .throw .for(body) .for
$.for 1 2 3 4 q {
  echo current arg $q
  if_only .test_greater $q 2 {
    .collect_errors_except .nop {
      .throw .continue
      .throw .break
      .throw .continue}}
  .throw .continue
  echo not printed}
current arg 1
current arg 2
current arg 3
$fn fIJ outer inner {
  .local sum 0
  .nop $sum
  $outer 1 2 3 4 5 6 I {
    if_only_not .test_string_equal $I 1 {.combine $nl}
    .combine $I :
    $inner 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 J {
      if_only .test_less 1 $J {.echo ,}
      .echo $J
      .set sum ${+ $I $J}
      .if .test_less 5 $sum$ {.throw outer_break}
      .else_if .test_less 3 $sum$ {.throw outer_continue}
      .else {}}}
  .echo $nl}
$fIJ .for .for
1:1,2,3Exception for failed handler. Original exception with call stack:
outer_continue .throw .mapped_argfunction .else_if .for(body) .for .for(body) .for fIJ
.continue thrown outside of control flow body
call stack: .throw .mapped_argfunction .else_if .for(body) .for .for(body) .for fIJ .replace_exception outer_continue
$fIJ outer_for .for
1:1,2,3
2:1,2
3:1
4:1
5:1
$fIJ .for outer_for
1:1,2,3,4,5
2:1,2,3,4
3:1,2,3
4:1,2
5:1
6:1
$fIJ outer_for outer_for
1:1,2,3,4,5
2:1,2,3,4
3:1,2,3
4:1,2
5:1
6:1
$.for 1 2 3 4 for_argument {echoe four arguments $for_argument $nl}
four arguments 1 
four arguments 2 
four arguments 3 
four arguments 4 
$.for (-x -y permitted) (-z rejected) ([-x] [-y arg] [-z]) {echo $-*}
(-x -y permitted)
unacceptable arguments: for prototype [-x] [-y arg] [-z],
 assigned -*=-z -z=-z ,
 but found (rejected) excess
( call) stack: (.for(body) .for)
$
$# .function .rm_executable .list_locals
$whence .function
.function -- name [prototype ...] .{argfunction}
$.function
unacceptable arguments: for prototype -- name [prototype ...] .{argfunction},
 needed (name),
( call) stack: .function
.function requires an argfunction
$.rm_executable {excess argfunction}
unacceptable arguments: for prototype -- command,
 needed (command),
( call) stack: .rm_executable
.rm_executable does not accept an argfunction with call stack: .rm_executable
$.list_locals excess {excess argfunction}
unacceptable arguments: for prototype ,
 found (excess) excess
( call) stack: .list_locals
.list_locals does not accept an argfunction with call stack: .list_locals
$.function .exit {.nop}
$.exit cannot be a function
call stack .function
$.function .escaped_argfunction {.nop}
$.escaped_argfunction cannot be a function
call stack .function
$.rm_executable a
a : command not found ( a .rm_executable )
$.function a {.nop}
$.whence_function a
.function a  {.nop}
$a 1 2 3
unacceptable arguments: for prototype ,
 found (1 2 3) excess
( call) stack: a
$.rm_executable a
$.whence_function a
a : command not found ( a .whence_function )
$.global A \
$sa () A () A () {.echo $args$ ${.argc $args$} $nl}
 A  A  5 
$.function a arg {echoe 9 $A $arg @/usr $nl}
$.whence_function a
.function a arg {echoe 9 $A $arg @/usr $nl}
$a \
9   /usr 
$a 1
9  1 /usr 
$a 1 2
unacceptable arguments: for prototype arg,
 assigned arg=1 ,
 but found (2) excess
( call) stack: a
$.function a [args ...] {.nop $args$; echoe $*5 $* $*0 $nl}
$a
a 
$a 1
1 a 1 
$a 1 2
1 2 a 1 2 
$fn g name .{argfunction} {.function $name name {
  .function $name {.argfunction}}}
$g a {echoe 3 2 1 $nl}
$whence a
.function a name {
  .function $name {echoe 3 2 1 $nl}}
$a b
$b
3 2 1 
$# a function redefining itself doesn't seg fault
$fn g {echoe hi $nl; fn g {echoe there $nl}; fn h {echoe nothing here}; g}
$g
hi 
there 
$fn ll {.list_locals; .combine $nl}
$.function .exit {echoe cannot redefine a builtin as a function}
$.exit cannot be a function
call stack .function
$.function .a {can define a function for non-existant builtin}
$.function .argfunction {echoe cannot define .argfunction}
$.argfunction cannot be a function
call stack .function
$.function a y y {echoe illegal duplicate required parameter}
duplicated parameter in function definition: y
call stack: .function
$.function a [-x] [-x] {echoe illegal duplicate flag parameter}
duplicated parameter in function definition: -x
call stack: .function
$.function a [x x] {echoe illegal duplicate optional parameter}
duplicated parameter in function definition: x
call stack: .function
$.function a [-x arg bar] [-y arg] {echoe illegal duplicate flag argument}
duplicated parameter in function definition: arg
call stack: .function
$.function a -x [-x] {echoe evil duplication between flags positional}
duplicated parameter in function definition: -x
call stack: .function
$.function a -- -- {echoe -- cannot be a duplicate parameter}
duplicated parameter in function definition: --
call stack: .function
$.function a [--] [--] {echoe [--] cannot be a duplicate parameter}
duplicated parameter in function definition: --
call stack: .function
$.function a [--] -- {echoe -- and [--] cannot both be parameters}
duplicated parameter in function definition: --
call stack: .function
$.function a [-- arg] {echoe -- cannot take arguments}
optional -- parameter cannot take arguments ( ([-- arg]) ) with call stack: .function
$.function a [arg -- foo] {echoe -- cannot take arguments}
optional -- parameter cannot take arguments ( ([arg -- foo]) ) with call stack: .function
$.rm_executable nonsense
nonsense : command not found ( nonsense .rm_executable )
$whence test_var_greater
.function test_var_greater -- var value {.test_greater $$var $value}
$.scope 5 n {test_var_greater n}
unacceptable arguments: for prototype -- var value,
 assigned var=n ,
 but needed (value),
( call) stack: (test_var_greater .scope)
n was unused with call stack .scope
$.scope 5 n {test_var_greater n 3 12}
unacceptable arguments: for prototype -- var value,
 assigned value=3 var=n ,
 but found (12) excess
( call) stack: (test_var_greater .scope)
n was unused with call stack .scope
$.scope 5 n {test_var_greater n 3}
$whence ntimes
.function ntimes n .{argfunction} {
  .while test_var_greater n 0 {
    .mapped_argfunction {.argfunction}
    .var_subtract n 1}}
$ntimes -- 3 {echoe $n remaining $nl}
3 remaining 
2 remaining 
1 remaining 
$ntimes 2 {ntimes 3 {echoe &&n and $n remaining $nl}}
2 and 3 remaining 
2 and 2 remaining 
2 and 1 remaining 
1 and 3 remaining 
1 and 2 remaining 
1 and 1 remaining 
$.function a [-x] [-] [--long-opt y second {
  echoe mismatched bracket (i.e. missing close brakcet)}
mismatched bracket: ([--long-opt y second)
call stack: .function
$.function a [-?] [--] {.list_locals}
[-?] [--] is an ambiguous location for a prototype -- (it requests reading the user's mind) (stack:.function)
$.function a [-x] [--] foo {.list_locals}
[-x] [--] is an ambiguous location for a prototype -- (it requests reading the user's mind) (stack:.function)
$.function a [-?] -- foo {.list_locals}
[-?] -- is an ambiguous location for a prototype -- (it requests reading the user's mind) (stack:.function)
$.function a [-x] -- {.list_locals}
[-x] -- is an ambiguous location for a prototype -- (it requests reading the user's mind) (stack:.function)
$.function a [--] {if_only .var_exists -- {.echo $--}; ll}
$whence a
.function a [--] {if_only .var_exists -- {.echo $--}; ll}
$a

$a --
----
$a foo
unacceptable arguments: for prototype [--],
 found (foo) excess
( call) stack: a
$.function a [-x] [--long-opt y] second {
  forj ${.list_locals}$ {.combine $j \( $$j \) \ }; .echo $nl}
$whence a
.function a [--long-opt y] [-x] second {
  forj ${.list_locals}$ {.combine $j \( $$j \) ( )}; .echo $nl}
$a
unacceptable arguments: for prototype [--long-opt y] [-x] second,
 assigned -*=() ,
 but needed (second),
( call) stack: a
$a single
-*() second(single) 
$a -x single
-*(-x) -x(-x) second(single) 
$a --long-opt arg single
-*(--long-opt arg) --long-opt(--long-opt arg) second(single) y(arg) 
$a --long-opt single
unacceptable arguments: for prototype [--long-opt y] [-x] second,
 assigned -*=(--long-opt single) --long-opt=(--long-opt single) y=single ,
 but needed (second),
( call) stack: a
$a --long-opt first -x --long-opt second single
-*(--long-opt first -x --long-opt second) --long-opt(--long-opt first --long-opt second) -x(-x) second(single) y(first second) 
$.function a [-q option1 option2] [-x o1 o2 o3 o4] required {
  forj ${ll}$ {.combine $j \( $$j \) \ }; .echo $nl}
$whence a
.function a [-q option1 option2] [-x o1 o2 o3 o4] required {
  forj ${ll}$ {.combine $j \( $$j \) ( )}; .echo $nl}
$a
unacceptable arguments: for prototype [-q option1 option2] [-x o1 o2 o3 o4] required,
 assigned -*=() ,
 but needed (required),
( call) stack: a
$a single
-*() required(single) 
$a -q one two
unacceptable arguments: for prototype [-q option1 option2] [-x o1 o2 o3 o4] required,
 assigned -*=(-q one two) -q=(-q one two) option1=one option2=two ,
 but needed (required),
( call) stack: a
$a -q opt and req
-*(-q opt and) -q(-q opt and) option1(opt) option2(and) required(req) 
$a -x opt and
unacceptable arguments: for prototype [-q option1 option2] [-x o1 o2 o3 o4] required,
 assigned -*=(-x opt and) -x=(-x opt and) o1=opt o2=and ,
 but needed (o3 o4 required),
( call) stack: a
$a -x first second third fourth req
-*(-x first second third fourth) -x(-x first second third fourth) o1(first) o2(second) o3(third) o4(fourth) required(req) 
$a -q one two -q three four five
-*(-q one two -q three four) -q(-q one two -q three four) option1(one three) option2(two four) required(five) 
$a -x one two three four -q five six seven
-*(-x one two three four -q five six) -q(-q five six) -x(-x one two three four) o1(one) o2(two) o3(three) o4(four) option1(five) option2(six) required(seven) 
$a -x one two three four five -q six seven
-*(-x one two three four -q six seven) -q(-q six seven) -x(-x one two three four) o1(one) o2(two) o3(three) o4(four) option1(six) option2(seven) required(five) 
$a one -x two three four five -q six seven
-*(-x two three four five -q six seven) -q(-q six seven) -x(-x two three four five) o1(two) o2(three) o3(four) o4(five) option1(six) option2(seven) required(one) 
$.function a [optional0] -- [optional1 optional2 optional3] required {
  forj ${.list_locals}$ {.combine $j \( $$j \) \ }; .echo $nl}
$whence a
.function a [optional0] -- [optional1 optional2 optional3] required {
  forj ${.list_locals}$ {.combine $j \( $$j \) ( )}; .echo $nl}
$a
unacceptable arguments: for prototype [optional0] -- [optional1 optional2 optional3] required,
 needed (required),
( call) stack: a
$a single
required(single) 
$a one two
optional0(one) required(two) 
$a one two three
unacceptable arguments: for prototype [optional0] -- [optional1 optional2 optional3] required,
 assigned optional0=one optional1=two optional2=three ,
 but needed (optional3 required),
( call) stack: a
$a one two three four five
optional0(one) optional1(two) optional2(three) optional3(four) required(five) 
$a one two three four five six seven eight nine
unacceptable arguments: for prototype [optional0] -- [optional1 optional2 optional3] required,
 assigned optional0=one optional1=two optional2=three optional3=four required=five ,
 but found (six seven eight nine) excess
( call) stack: a
$.function a -y [second] {
  forj ${.list_locals}$ {.combine $j \( $$j \) \ }; .echo $nl}
$whence a
.function a -y [second] {
  forj ${.list_locals}$ {.combine $j \( $$j \) ( )}; .echo $nl}
$a
unacceptable arguments: for prototype -y [second],
 needed (-y),
( call) stack: a
$a 1
-y(1) 
$a 1 2
-y(1) second(2) 
$a 1 2 3
unacceptable arguments: for prototype -y [second],
 assigned -y=1 second=2 ,
 but found (3) excess
( call) stack: a
$.function a [-x] -y [--long-opt] second [--] [-] {
  forj ${.list_locals}$ {.combine $j \( $$j \) \ }; .echo $nl}
$whence a
.function a [--long-opt] [-x] -y second [--] [-] {
  forj ${.list_locals}$ {.combine $j \( $$j \) ( )}; .echo $nl}
$a --long-opt -xx over-long flag
-xx flag is unrecognized for ([--long-opt] [-x] -y second [--] [-])
call stack: a
$a -xx --long-opt over-long flag extra excess
-xx flag is unrecognized for ([--long-opt] [-x] -y second [--] [-])
call stack: a
unacceptable arguments: for prototype [--long-opt] [-x] -y second [--] [-],
 assigned -=extra -*=(-xx --long-opt) --long-opt=--long-opt -y=over-long second=flag ,
 but found (excess) excess
( call) stack: a
$a --long-op short flag
--long-op flag is unrecognized for ([--long-opt] [-x] -y second [--] [-])
call stack: a
$a - --long-op short flag
--long-op flag is unrecognized for ([--long-opt] [-x] -y second [--] [-])
call stack: a
$a no flags
-*() -y(no) second(flags) 
$a deficient
unacceptable arguments: for prototype [--long-opt] [-x] -y second [--] [-],
 assigned -*=() -y=deficient ,
 but needed (second),
( call) stack: a
$a flagless but_has excess argument
unacceptable arguments: for prototype [--long-opt] [-x] -y second [--] [-],
 assigned -=excess -*=() -y=flagless second=but_has ,
 but found (argument) excess
( call) stack: a
$a -x with flag
-*(-x) -x(-x) -y(with) second(flag) 
$a -x -x doubled flag
-*(-x -x) -x(-x -x) -y(doubled) second(flag) 
$a accepted -x interlaced_flag -
-(-) -*(-x) -x(-x) -y(accepted) second(interlaced_flag) 
$a tardy flags_last - -x
-x flag comes too late in command
call stack: a
$a -x -- - flag_made_fixed_argument
-*(-x --) --(--) -x(-x) -y(-) second(flag_made_fixed_argument) 
$a -- - flag_again_made_fixed_argument
-*(--) --(--) -y(-) second(flag_again_made_fixed_argument) 
$a -x -- flag_and_fixed-x -x
-*(-x --) --(--) -x(-x) -y(flag_and_fixed-x) second(-x) 
$a -x just flags-x --long-opt -x
--long-opt flag comes too late in command
call stack: a
-x flag comes too late in command
call stack: a
$a -x just flags-x -- --long-opt
-(--long-opt) -*(-x --) --(--) -x(-x) -y(just) second(flags-x) 
$a -x just flags-x --other --also-wrong
--other flag comes too late in command
call stack: a
--also-wrong flag comes too late in command
call stack: a
$a -x just flags-x -- --other
-(--other) -*(-x --) --(--) -x(-x) -y(just) second(flags-x) 
$a -x with one excess argument
unacceptable arguments: for prototype [--long-opt] [-x] -y second [--] [-],
 assigned -=excess -*=-x -x=-x -y=with second=one ,
 but found (argument) excess
( call) stack: a
$a - with flag
-(flag) -*() -y(-) second(with) 
$a --long-opt with flag
-*(--long-opt) --long-opt(--long-opt) -y(with) second(flag) 
$a --long-opt -x - some_flags in_order
-(in_order) -*(--long-opt -x) --long-opt(--long-opt) -x(-x) -y(-) second(some_flags) 
$a - -x --long-opt some_flags reversed
-(reversed) -*(-x --long-opt) --long-opt(--long-opt) -x(-x) -y(-) second(some_flags) 
$a - --long-opt some_flags in_order
-(in_order) -*(--long-opt) --long-opt(--long-opt) -y(-) second(some_flags) 
$a --long-opt - some_flags reversed
-(reversed) -*(--long-opt) --long-opt(--long-opt) -y(-) second(some_flags) 
$a -x --long-opt some_flags in_order
-*(-x --long-opt) --long-opt(--long-opt) -x(-x) -y(some_flags) second(in_order) 
$a --long-opt -x some_flags reversed
-*(--long-opt -x) --long-opt(--long-opt) -x(-x) -y(some_flags) second(reversed) 
$a -x --long-opt deficient
unacceptable arguments: for prototype [--long-opt] [-x] -y second [--] [-],
 assigned -*=(-x --long-opt) --long-opt=--long-opt -x=-x -y=deficient ,
 but needed (second),
( call) stack: a
$a -x - --long-opt all_flags in_order
-(in_order) -*(-x --long-opt) --long-opt(--long-opt) -x(-x) -y(-) second(all_flags) 
$a --long-opt - -x all_flags reversed
-(reversed) -*(--long-opt -x) --long-opt(--long-opt) -x(-x) -y(-) second(all_flags) 
$a - --long-opt -x all_flags shuffled
-(shuffled) -*(--long-opt -x) --long-opt(--long-opt) -x(-x) -y(-) second(all_flags) 
$a - --long-opt -x -x some_flags doubled
-(doubled) -*(--long-opt -x -x) --long-opt(--long-opt) -x(-x -x) -y(-) second(some_flags) 
$a -x --long-opt -x --long-opt -x one_doubled one_tripled
-*(-x --long-opt -x --long-opt -x) --long-opt(--long-opt --long-opt) -x(-x -x -x) -y(one_doubled) second(one_tripled) 
$a --long-opt -x -x - --long-opt all_flags doubled
-(doubled) -*(--long-opt -x -x --long-opt) --long-opt(--long-opt --long-opt) -x(-x -x) -y(-) second(all_flags) 
$.function a [-first] [-to] {
  forj ${.list_locals}$ {.combine $j \( $$j \) \ }
  echo nothing_required}
$whence a
.function a [-first] [-to] {
  forj ${.list_locals}$ {.combine $j \( $$j \) ( )}
  echo nothing_required}
$a
-*() nothing_required
$a excess
unacceptable arguments: for prototype [-first] [-to],
 assigned -*=() ,
 but found (excess) excess
( call) stack: a
$a -to
-*(-to) -to(-to) nothing_required
$a -first --
-*(-first --) --(--) -first(-first) nothing_required
$a -first excess
unacceptable arguments: for prototype [-first] [-to],
 assigned -*=-first -first=-first ,
 but found (excess) excess
( call) stack: a
$a -to -- -first -- stops flag parsing rather than being a flag
unacceptable arguments: for prototype [-first] [-to],
 assigned -*=(-to --) --=-- -to=-to ,
 but found (-first -- stops flag parsing rather than being a flag) excess
( call) stack: a
$a -to -first
-*(-to -first) -first(-first) -to(-to) nothing_required
$.function a [-?] [-first] {
  forj ${.list_locals}$ {.combine $j \( $$j \) \ }
  echo nothing_required}
$whence a
.function a [-?] [-first] {
  forj ${.list_locals}$ {.combine $j \( $$j \) ( )}
  echo nothing_required}
$a
-*() -?() nothing_required
$a excess
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=() -?=() ,
 but found (excess) excess
( call) stack: a
$a -to
-*(-to) -?(-to) nothing_required
$a -first --
-*(-first --) --(--) -?(--) -first(-first) nothing_required
$a -first excess
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=-first -?=() -first=-first ,
 but found (excess) excess
( call) stack: a
$a -to -- -first
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=(-to --) --=-- -?=(-to --) ,
 but found (-first) excess
( call) stack: a
$a -to -first
-*(-to -first) -?(-to) -first(-first) nothing_required
$.function a [-*] [-first] {
  forj ${.list_locals}$ {.combine $j \( $$j \) \ }
  echo nothing_required}
$whence a
.function a [-?] [-first] {
  forj ${.list_locals}$ {.combine $j \( $$j \) ( )}
  echo nothing_required}
$a
-*() -?() nothing_required
$a -to -- -first
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=(-to --) --=-- -?=(-to --) ,
 but found (-first) excess
( call) stack: a
$a -to -first
-*(-to -first) -?(-to) -first(-first) nothing_required
$.function a [-?] {
  forj ${.list_locals}$ {.combine $j \( $$j \) \ }
  echo nothing_required}
$whence a
.function a [-?] {
  forj ${.list_locals}$ {.combine $j \( $$j \) ( )}
  echo nothing_required}
$a
-*() -?() nothing_required
$.function a ... y {}
... elipsis cannot be the first argument in a prototype
call stack: .function
$.function a [-x] [--file file] ... y {}
... elipsis cannot be the first argument in a prototype
call stack: .function
$.function a [...] x {}
[...] elipsis cannot be the first argument in a prototype
call stack: .function
$.function a [... y] x {}
([... y]) elipsis cannot be the first argument in a prototype
call stack: .function
$.function a x ... [y z] {}
option ([y z]) coming after an elipsis has no meaning
call stack: .function
$.function a x [... y] z ... {}
duplicated parameter in function definition: ...
call stack: .function
$.function a [y z] ... x {}
([y z]) for elipsis to apply to option it must occur within the brackets
call stack: .function
$.function a [y] ... x {}
$whence a
.function a [y ...] x {}
$.function a x ... y ... {}
duplicated parameter in function definition: ...
call stack: .function
$.function a [x ...] [y z] {}
option ([y z]) coming after an elipsis has no meaning
call stack: .function
$.function a [x ...] y ... {}
duplicated parameter in function definition: ...
call stack: .function
$.function a [x ... a] [y] {}
option [y] coming after an elipsis has no meaning
call stack: .function
$.function a [x ... a] y ... {}
duplicated parameter in function definition: ...
call stack: .function
$.function a [x ... a ...] {}
duplicated parameter in function definition: ...
call stack: .function
$.function a [x ... a ... b] {}
duplicated parameter in function definition: ...
call stack: .function
$.function a [-x ...] b [c] {}
option [c] coming after an elipsis has no meaning
call stack: .function
$.function a -? x ... y {
  forj ${.list_locals}$ {.combine $j \( $$j \) \ }; .echo $nl}
$whence a
.function a [-?] x ... y {
  forj ${.list_locals}$ {.combine $j \( $$j \) ( )}; .echo $nl}
$.function a -* x ... y {
  forj ${.list_locals}$ {.combine $j \( $$j \) \ }; .echo $nl}
$whence a
.function a [-?] x ... y {
  forj ${.list_locals}$ {.combine $j \( $$j \) ( )}; .echo $nl}
$.function a [-?] x ... y {
  forj ${.list_locals}$ {.combine $j \( $$j \) \ }; .echo $nl}
$whence a
.function a [-?] x ... y {
  forj ${.list_locals}$ {.combine $j \( $$j \) ( )}; .echo $nl}
$a -c -a -b first second third
-*(-c -a -b) -?(-c -a -b) x(first second) y(third) 
$a -c first -a second -b third
found flag -a while collecting arguments for elipsis in (x ...)
call stack a
found flag -b while collecting arguments for elipsis in (x ...)
call stack a
$a 
unacceptable arguments: for prototype [-?] x ... y,
 assigned -*=() -?=() ,
 but needed (x y),
( call) stack: a
$a first
unacceptable arguments: for prototype [-?] x ... y,
 assigned -*=() -?=() x=first ,
 but needed (y),
( call) stack: a
$a first (se cond)
-*() -?() x(first) y(se cond) 
$a first (se cond) third
-*() -?() x(first (se cond)) y(third) 
$a first (se cond) third fourth (fi fth)
-*() -?() x(first (se cond) third fourth) y(fi fth) 
$.function a [-?] x [...] {
  forj ${.list_locals}$ {.combine $j \( $$j \) \ }; .echo $nl}
$whence a
.function a [-?] x ... {
  forj ${.list_locals}$ {.combine $j \( $$j \) ( )}; .echo $nl}
$a
unacceptable arguments: for prototype [-?] x ...,
 assigned -*=() -?=() ,
 but needed (x),
( call) stack: a
$a first second third fourth fifth
-*() -?() x(first second third fourth fifth) 
$.function a [-?] x [--] [y ...] {
  forj ${.list_locals}$ {.combine $j \( $$j \) \ }; .echo $nl}
$whence a
.function a [-?] x [--] [y ...] {
  forj ${.list_locals}$ {.combine $j \( $$j \) ( )}; .echo $nl}
$a
unacceptable arguments: for prototype [-?] x [--] [y ...],
 assigned -*=() -?=() ,
 but needed (x),
( call) stack: a
$a first
-*() -?() x(first) 
$a first second
-*() -?() x(first) y(second) 
$a first second third
-*() -?() x(first) y(second third) 
$a first second third fourth fifth
-*() -?() x(first) y(second third fourth fifth) 
$.function a [-?] a [b ... c] d {
  forj ${.list_locals}$ {.combine $j \( $$j \) \ }; .echo $nl}
$whence a
.function a [-?] a [b ... c] d {
  forj ${.list_locals}$ {.combine $j \( $$j \) ( )}; .echo $nl}
$a first
unacceptable arguments: for prototype [-?] a [b ... c] d,
 assigned -*=() -?=() a=first ,
 but needed (d),
( call) stack: a
$a first second
-*() -?() a(first) d(second) 
$a first second third
unacceptable arguments: for prototype [-?] a [b ... c] d,
 assigned -*=() -?=() a=first b=second c=third ,
 but needed (d),
( call) stack: a
$a first second third fourth
-*() -?() a(first) b(second) c(third) d(fourth) 
$a first second third fourth fifth
-*() -?() a(first) b(second third) c(fourth) d(fifth) 
$a first second third fourth fifth sixth
-*() -?() a(first) b(second third fourth) c(fifth) d(sixth) 
$.function a [-x ...] b c {
  forj ${.list_locals}$ {.combine $j \( $$j \) \ }; .echo $nl}
$whence a
.function a [-x ...] b c {
  forj ${.list_locals}$ {.combine $j \( $$j \) ( )}; .echo $nl}
$a first second
-*() b(first) c(second) 
$a -x first
unacceptable arguments: for prototype [-x ...] b c,
 assigned -*=-x -x=-x b=first ,
 but needed (c),
( call) stack: a
$a -x first second
-*(-x) -x(-x) b(first) c(second) 
$a -x first second third
-*(-x first) -x(-x first) b(second) c(third) 
$a -x first second third fourth
-*(-x first second) -x(-x first second) b(third) c(fourth) 
$.function a [-x b ...] c {
  forj ${.list_locals}$ {.combine $j \( $$j \) \ }; .echo $nl}
$whence a
.function a [-x b ...] c {
  forj ${.list_locals}$ {.combine $j \( $$j \) ( )}; .echo $nl}
$a first
-*() c(first) 
$a -x first
unacceptable arguments: for prototype [-x b ...] c,
 assigned -*=(-x first) -x=(-x first) b=first ,
 but needed (c),
( call) stack: a
$a -x (fi rst) second
-*(-x (fi rst)) -x(-x (fi rst)) b((fi rst)) c(second) 
$a -x first (sec ond) third
-*(-x first (sec ond)) -x(-x first (sec ond)) b(first (sec ond)) c(third) 
$a -x first -x (sec ond) third
found flag -x while collecting arguments for elipsis in ([-x b ...])
call stack a
$a -x first -y (sec ond) third
found flag -y while collecting arguments for elipsis in ([-x b ...])
call stack a
$a -x (fi rst) (sec ond) third fourth
-*(-x (fi rst) (sec ond) third) -x(-x (fi rst) (sec ond) third) b((fi rst) (sec ond) third) c(fourth) 
$.function a [-x ... b] c {
  forj ${.list_locals}$ {.combine $j \( $$j \) \ }
  .combine $nl
  if_only .test_not_empty $-* {c (-*: ) $-*$ $nl}
  if_only .var_exists -x {c (-x: ) $-x$ $nl}
  if_only .var_exists b {c (b: ) $b$ $nl}
  if_only .var_exists c {c (c: ) $c$ $nl}
}
$whence a
.function a [-x ... b] c {
  forj ${.list_locals}$ {.combine $j \( $$j \) ( )}
  .combine $nl
  if_only .test_not_empty $-* {c (-*: ) $-*$ $nl}
  if_only .var_exists -x {c (-x: ) $-x$ $nl}
  if_only .var_exists b {c (b: ) $b$ $nl}
  if_only .var_exists c {c (c: ) $c$ $nl}
}
$a first
-*() c(first) 
c: first
$a -x first
unacceptable arguments: for prototype [-x ... b] c,
 assigned -*=(-x first) -x=(-x first) b=first ,
 but needed (c),
( call) stack: a
$a -x (fi rst) second
-*(-x (fi rst)) -x(-x (fi rst)) b((fi rst)) c(second) 
-*: -xfi rst
-x: -xfi rst
b: fi rst
c: second
$a -x () (fi rst) second
-*(-x () (fi rst)) -x(-x () (fi rst)) b((fi rst)) c(second) 
-*: -xfi rst
-x: -xfi rst
b: fi rst
c: second
$a -x first (sec ond) third
-*(-x first (sec ond)) -x(-x first (sec ond)) b((sec ond)) c(third) 
-*: -xfirstsec ond
-x: -xfirstsec ond
b: sec ond
c: third
$a -x (fi rst) (sec ond) third fourth
-*(-x (fi rst) (sec ond) third) -x(-x (fi rst) (sec ond) third) b(third) c(fourth) 
-*: -xfi rstsec ondthird
-x: -xfi rstsec ondthird
b: third
c: fourth
$.function a x [-?] [... y z] {
  forj ${.list_locals}$ {.combine $j \( $$j \) \ }
  .combine $nl
  if_only .var_exists x {c (x: ) $x$ $nl}}
$whence a
.function a [-?] x [... y z] {
  forj ${.list_locals}$ {.combine $j \( $$j \) ( )}
  .combine $nl
  if_only .var_exists x {c (x: ) $x$ $nl}}
$a
unacceptable arguments: for prototype [-?] x [... y z],
 assigned -*=() -?=() ,
 but needed (x),
( call) stack: a
$a (fi rst)
-*() -?() x((fi rst)) 
x: fi rst
$a (fi rst) second
unacceptable arguments: for prototype [-?] x [... y z],
 assigned -*=() -?=() x=(fi rst) y=second ,
 but needed (z),
( call) stack: a
$a first (sec ond) third
-*() -?() x(first) y(sec ond) z(third) 
x: first
$a (fi rst) (sec ond) third fourth
-*() -?() x((fi rst) (sec ond)) y(third) z(fourth) 
x: fi rstsec ond
$a () (sec ond) third fourth
-*() -?() x(() (sec ond)) y(third) z(fourth) 
x: sec ond
$a (fi rst) (sec ond) (thi rd) (fou rth) (fi fth)
-*() -?() x((fi rst) (sec ond) (thi rd)) y(fou rth) z(fi fth) 
x: fi rstsec ondthi rd
$.function a [-?] [x] [... y] {
  forj ${.list_locals}$ {.combine $j \( $$j \) \ }; .echo $nl}
$whence a
.function a [-?] [x] [... y] {
  forj ${.list_locals}$ {.combine $j \( $$j \) ( )}; .echo $nl}
$a
-*() -?() 
$a (fi rst)
-*() -?() x((fi rst)) 
$a (fi rst) second
-*() -?() x((fi rst)) y(second) 
$a first (sec ond) third
-*() -?() x(first (sec ond)) y(third) 
$a (fi rst) (sec ond) third fourth
-*() -?() x((fi rst) (sec ond) third) y(fourth) 
$a (fi rst) (sec ond) (thi rd) (fou rth) (fi fth)
-*() -?() x((fi rst) (sec ond) (thi rd) (fou rth)) y(fi fth) 
$.function a [-?] [x y] [... z] {
  forj ${.list_locals}$ {.combine $j \( $$j \) \ }
  .combine $nl
  if_only .var_exists x {c (x: ) $x $nl}
  if_only .var_exists y {c (y: ) $y$ $nl}
  if_only .var_exists z {c (z: ) $z$ $nl}}
$whence a
.function a [-?] [x y] [... z] {
  forj ${.list_locals}$ {.combine $j \( $$j \) ( )}
  .combine $nl
  if_only .var_exists x {c (x: ) $x $nl}
  if_only .var_exists y {c (y: ) $y$ $nl}
  if_only .var_exists z {c (z: ) $z$ $nl}}
$a
-*() -?() 
$a (fi rst)
unacceptable arguments: for prototype [-?] [x y] [... z],
 assigned -*=() -?=() x=(fi rst) ,
 but needed (y),
( call) stack: a
$a (fi rst) second
-*() -?() x(fi rst) y(second) 
x: fi rst
y: second
$a (fi rst) (sec ond) (thi rd)
-*() -?() x(fi rst) y((sec ond)) z(thi rd) 
x: fi rst
y: sec ond
z: third
$a (fi rst) (sec ond) third (fou rth)
-*() -?() x(fi rst) y((sec ond) third) z(fou rth) 
x: fi rst
y: sec ondthird
z: fourth
$a (fi rst) (sec ond) (thi rd) (fou rth) (fi fth)
-*() -?() x(fi rst) y((sec ond) (thi rd) (fou rth)) z(fi fth) 
x: fi rst
y: sec ondthi rdfou rth
z: fifth
$.function a -- [-x] y z {}
flag option [-x] occurs after -- in the prototype
call stack: .function
$.function a -- [x y] z {
  forj ${.list_locals}$ {.combine $j \( $$j \) \ }; .echo $nl}
$whence a
.function a -- [x y] z {
  forj ${.list_locals}$ {.combine $j \( $$j \) ( )}; .echo $nl}
$a
unacceptable arguments: for prototype -- [x y] z,
 needed (z),
( call) stack: a
$a --file
z(--file) 
$a first second third
x(first) y(second) z(third) 
$a -x second -
x(-x) y(second) z(-) 
$
$# .get_max_collectible_exceptions .set_max_collectible_exceptions
$# .collect_errors_except .collect_errors_only
$.get_max_collectible_exceptions excess
unacceptable arguments: for prototype ,
 found (excess) excess
( call) stack: .get_max_collectible_exceptions
$.set_max_collectible_exceptions
unacceptable arguments: for prototype -- maximum,
 needed (maximum),
( call) stack: .set_max_collectible_exceptions
$.get_max_collectible_exceptions {excess}
.get_max_collectible_exceptions does not accept an argfunction with call stack: .get_max_collectible_exceptions
$.set_max_collectible_exceptions 1 {excess}
.set_max_collectible_exceptions does not accept an argfunction with call stack: .set_max_collectible_exceptions
$.set_max_collectible_exceptions NaN
NaN is not a number
call stack: .set_max_collectible_exceptions
$.scope () {.get_max_collectible_exceptions; .echo $nl}
10
$.set_max_collectible_exceptions 0
value 0 is out of usable numeric range
call stack .set_max_collectible_exceptions
$.scope () {.get_max_collectible_exceptions; .echo $nl}
10
$.set_max_collectible_exceptions 7
$.collect_errors_except
unacceptable arguments: for prototype -- exceptions ... .{argfunction},
 needed (exceptions),
( call) stack: .collect_errors_except
.collect_errors_except requires an argfunction
$.collect_errors_only
unacceptable arguments: for prototype -- exceptions ... .{argfunction},
 needed (exceptions),
( call) stack: .collect_errors_only
.collect_errors_only requires an argfunction
$se {.collect_errors_except .nop {
     se {echo before exception
        .throw .not_a_number 7
        echo after exception}
     echo between exceptions
     .scope () {.throw .function_not_found foo}
     echo inside collect}
   echo outside collect}
before exception
between exceptions
inside collect
7 is not a number
call stack: .throw .scope se .collect_errors_except .scope se
foo : command not found ( foo .throw .scope .collect_errors_except .scope se )
$se {.collect_errors_except echo {
     .throw .function_not_found foo
     echo between exceptions
     .throw echo 7
     echo inside collect}
   echo outside collect}
between exceptions
foo : command not found ( foo .throw .collect_errors_except .scope se )
7 .throw .collect_errors_except .scope se
$.collect_errors_except echo {${.throw echo exception thrown directly}}
exception thrown directly .throw .mapped_argfunction .collect_errors_except
substitution (${.throw echo exception thrown directly}) failed
call stack: .collect_errors_except
$se {.collect_errors_only .function_not_found {
     .throw .function_not_found foo
     echo between exceptions
     .throw echo 7
     echo inside collect}
   echo outside collect}
between exceptions
foo : command not found ( foo .throw .collect_errors_only .scope se )
7 .throw .collect_errors_only .scope se
$.collect_errors_except echo {
 .collect_errors_except echo {
  .collect_errors_except echo {
   .collect_errors_except echo {
    .collect_errors_except .echo {
     echo inside 5
     .throw echo inside 5
     .collect_errors_except echo {
      .collect_errors_except echo {
       .collect_errors_except echo {
        .collect_errors_except echo {
         .collect_errors_except .echo {
          echo inside 10
          .throw echo inside 10
          .collect_errors_except echo {
           .collect_errors_except echo {
            .collect_errors_except echo {
             .collect_errors_except echo {
              .collect_errors_except .echo {
               echo inside 15
               .throw echo inside 15
               .collect_errors_except echo {
                .collect_errors_except echo {
                 .collect_errors_except echo {
                  .collect_errors_except echo {
                   .collect_errors_except .echo {
                    echo inside 20
                    .throw echo inside 20
                   .collect_errors_except .echo {echo inside 21}
}}}}}}}}}}}}}}}}}}}}
inside 5
inside 10
inside 15
inside 20
inside 21
inside 5 .throw .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except
inside 10 .throw .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except
inside 15 .throw .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except
inside 20 .throw .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except
$.set_max_collectible_exceptions 1
$.function collecting_handler args ... {
  echo $args$
}
$.scope () {.get_max_extra_exceptions; .echo $nl}
5
$.set_max_extra_exceptions 1
$.try_catch_recursive collecting_handler {
  .collect_errors_except .echo {
    .throw collecting_handler 1
    .throw collecting_handler 2}}
1 .throw .collect_errors_except .try_catch_recursive(body)
2 .throw .collect_errors_except .try_catch_recursive(body)
$.try_catch_recursive collecting_handler {
  .collect_errors_except .echo {
    .throw collecting_handler 1
    .throw collecting_handler 2
    echo almost nothing}}
1 .throw .collect_errors_except .try_catch_recursive(body)
2 .throw .collect_errors_except .try_catch_recursive(body)
exceeded maximum number of exceptions ( 1 ) in collect_errors.
call stack: .collect_errors_except .try_catch_recursive(body) .try_catch_recursive
$.set_max_extra_exceptions 0
$.try_catch_recursive collecting_handler {
  .collect_errors_except .echo {
    .throw collecting_handler 1
    .throw collecting_handler 2}}
1 .throw .collect_errors_except .try_catch_recursive(body) .try_catch_recursive
2 .throw .collect_errors_except .try_catch_recursive(body) .try_catch_recursive
exceeded maximum number of exceptions ( 0 ) in try_catch.
call stack: .try_catch_recursive
$.try_catch_recursive collecting_handler {
  .collect_errors_except .echo {
    .throw collecting_handler 1
    .throw collecting_handler 2
    echo almost nothing}}
1 .throw .collect_errors_except .try_catch_recursive(body) .try_catch_recursive
2 .throw .collect_errors_except .try_catch_recursive(body) .try_catch_recursive
exceeded maximum number of exceptions ( 1 ) in collect_errors.
call stack: .collect_errors_except .try_catch_recursive(body) .try_catch_recursive
exceeded maximum number of exceptions ( 0 ) in try_catch.
call stack: .try_catch_recursive
$.set_max_extra_exceptions 1
$.set_max_collectible_exceptions 7
$.scope () {.get_max_collectible_exceptions; .echo $nl}
7
$
$# .global .local .local_declare .unset .var_exists
$.global
unacceptable arguments: for prototype -- var value,
 needed (var value),
( call) stack: .global
$.global x y z
unacceptable arguments: for prototype -- var value,
 assigned value=y var=x ,
 but found (z) excess
( call) stack: .global
$.global x y {excess argfunc}
.global does not accept an argfunction with call stack: .global
$.local
unacceptable arguments: for prototype -- var value,
 needed (var value),
( call) stack: .local
$.local x y z
unacceptable arguments: for prototype -- var value,
 assigned value=y var=x ,
 but found (z) excess
( call) stack: .local
$.local x y {excess argfunc}
.local does not accept an argfunction with call stack: .local
$.local_declare
unacceptable arguments: for prototype -- var ...,
 needed (var),
( call) stack: .local_declare
$.local_declare x {excess argfunc}
.local_declare does not accept an argfunction with call stack: .local_declare
$.unset
unacceptable arguments: for prototype -- var,
 needed (var),
( call) stack: .unset
$.unset x {excess argfunc}
.unset does not accept an argfunction with call stack: .unset
$.unset x y
unacceptable arguments: for prototype -- var,
 assigned var=x ,
 but found (y) excess
( call) stack: .unset
$.unset FIGNORE
$FIGNORE cannot be set
call stack .unset
$.var_exists
unacceptable arguments: for prototype -- var ...,
 needed (var),
( call) stack: .var_exists
$.var_exists x {excess argfunc}
.var_exists does not accept an argfunction with call stack: .var_exists
$.global 100 nihilism
$100 cannot be set
call stack .global
$.local 0 nihilism
$0 cannot be set
call stack .local
$.local_declare 0 #
$0 cannot be set
call stack .local_declare
$# cannot be set
call stack .local_declare
$.global .var_exists (must be requested to be checked)
$echo $.var_exists$
must be requested to be checked
$.unset #
$# cannot be set
call stack .unset
$.unset #
$# cannot be set
call stack .unset
$.unset *
$* cannot be set
call stack .unset
$.unset 1
$1 cannot be set
call stack .unset
$.unset MAX_NESTING
MAX_NESTING was not declared
call stack: .unset
$.var_exists #
$.var_exists *
$.var_exists 0
$.var_exists 2
assertion (var exists: 2) failed
call stack .var_exists
$.var_exists x
assertion (var exists: x) failed
call stack .var_exists
$.var_exists x y
assertion (var exists: x y) failed
call stack .var_exists
$.var_exists # y
$.var_exists y x
assertion (var exists: y x) failed
call stack .var_exists
$.unset x
x was not declared
call stack: .unset
$.global x nihilism
$.local_declare x
variable x already exists
call stack .local_declare
$.var_exists x
$.var_exists x y
$echo $x
nihilism
$.global x nihilism
$.global x ubernihilism
variable x already exists
call stack .global
$.global i nihilism
$.unset i
attempt to set i before making use of its initial value
call stack .unset
$.global j nihilism
$fn echo-i-y in-out func {
  if_only .var_exists i {echo $in-out $func i $i}
  if_only .var_exists j {echo $in-out $func j $j}
  if_only .var_exists k {echo $in-out $func k $k}
  if_only .var_exists m {echo $in-out $func m $m}
  if_only .var_exists n {echo $in-out $func n $n}
  if_only .var_exists x {echo $in-out $func x $x}
  if_only .var_exists y {echo $in-out $func y $y}}
$fn a {echo-i-y in a
      .local x (first level not global)
      .local y (level one not global)
      .local z (will be unused)
      .local_declare i j k l m n
      .set i (declared first level not global)
      .set j (declared first level not global)
      .set k (declared level one not global)
      .set l (will be unused)
      .set n (will be used)
      b
      echo-i-y out a}
$fn b {echo-i-y in b
      .local x (second level masks first)
      .set y   (level two overwrites one)
      .local_declare i j m
      echo undefined i will hide the first level local
      .set j (declared second level masks first)
      .set k (declared level two overwrites one)
      c
      echo-i-y out b}
$fn c {echo-i-y in c
      .reinterpret .reinterpreted .reinterpreted (n [j] y)
      echo-i-y middle c
      # can unset a local, but won't remove everything named x
      .unset x
      .unset j
      .unset n
      .try_catch_recursive .global_would_be_masked {
        .global y (attempting to create global masked by local)}
      .set x (third level overwrites first)
      .set i (declared third level overwrites second)
      .set j (declared third level overwrites first)
      .local x (third level masks first)
      .local_declare i j m
      .set i (declared third level masks first)
      .set j (declared third level masks first)
      .set y (level three overwrites one)
      .set k (declared level three overwrites one)
      echo-i-y out c}
$a
in a i nihilism
in a j nihilism
in a x nihilism
in b i (declared first level not global)
in b j (declared first level not global)
in b k (declared level one not global)
in b n (will be used)
in b x (first level not global)
in b y (level one not global)
undefined i will hide the first level local
in c j (declared second level masks first)
in c k (declared level two overwrites one)
in c n (will be used)
in c x (second level masks first)
in c y (level two overwrites one)
middle c k (declared level two overwrites one)
middle c n .reinterpreted
middle c x (second level masks first)
middle c y .reinterpreted
requested global y already exists as a local. It would be masked by the local and inaccessible from here
call stack .global .try_catch_recursive(body)
out c i (declared third level masks first)
out c j (declared third level masks first)
out c k (declared level three overwrites one)
out c x (third level masks first)
out c y (level three overwrites one)
out b i (declared third level overwrites second)
out b j (declared third level overwrites first)
out b k (declared level three overwrites one)
out b x (third level overwrites first)
out b y (level three overwrites one)
out a i (declared first level not global)
out a j (declared third level overwrites first)
out a k (declared level three overwrites one)
out a x (third level overwrites first)
out a y (level three overwrites one)
l was unused with call stack a
z was unused with call stack a
$# demonstrating that final values are not retained
$a
in a i nihilism
in a j nihilism
in a x nihilism
in b i (declared first level not global)
in b j (declared first level not global)
in b k (declared level one not global)
in b n (will be used)
in b x (first level not global)
in b y (level one not global)
undefined i will hide the first level local
in c j (declared second level masks first)
in c k (declared level two overwrites one)
in c n (will be used)
in c x (second level masks first)
in c y (level two overwrites one)
middle c k (declared level two overwrites one)
middle c n .reinterpreted
middle c x (second level masks first)
middle c y .reinterpreted
requested global y already exists as a local. It would be masked by the local and inaccessible from here
call stack .global .try_catch_recursive(body)
out c i (declared third level masks first)
out c j (declared third level masks first)
out c k (declared level three overwrites one)
out c x (third level masks first)
out c y (level three overwrites one)
out b i (declared third level overwrites second)
out b j (declared third level overwrites first)
out b k (declared level three overwrites one)
out b x (third level overwrites first)
out b y (level three overwrites one)
out a i (declared first level not global)
out a j (declared third level overwrites first)
out a k (declared level three overwrites one)
out a x (third level overwrites first)
out a y (level three overwrites one)
l was unused with call stack a
z was unused with call stack a
$ntimes 2 {
  echo before $x$ , $j$
  .local_declare x
  .local_declare x
  .local j (locally defined)
  echo between $x$ , $j$
  .set x locally set
  echo after $x$ , $j$}
before nihilism , nihilism
between , locally defined
after locally set , locally defined
before nihilism , nihilism
between , locally defined
after locally set , locally defined
$echo $x
nihilism
$.var_exists y
assertion (var exists: y) failed
call stack .var_exists
$.unset x
$.unset i
$.unset j
$.var_exists x
assertion (var exists: x) failed
call stack .var_exists
$
$# .store_output
$.store_output x
.store_output requires an argfunction
$.store_output {echo some text}
unacceptable arguments: for prototype -- var .{argfunction},
 needed (var),
( call) stack: .store_output
$.store_output # {echo some text}
$# cannot be set
call stack .store_output
$.store_output x {echo some text}
x was not declared
call stack: .store_output
$.global x ()
$.store_output x {echo some text; .throw echo exception}
exception .throw .mapped_argfunction .store_output
$echoe $x
$.store_output x {echo some text}
$echoe $x
some text
$.unset x
$
$## if_core
$# helper functions
$.function silent_throw [text ...] {
  .collect_errors_only .false echo {
    .throw .false first
    .throw echo exception $text$
    .throw .false second
    .nop}}
$.function caught_silent_throw [text ...] {
  .try_catch_recursive echo {silent_throw $text$}}
$silent_throw on its own
assertion first failed
call stack .throw .collect_errors_only silent_throw
exception on its own .throw .collect_errors_only silent_throw
assertion second failed
call stack .throw .collect_errors_only silent_throw
$caught_silent_throw on its own
exception on its own .throw .collect_errors_only silent_throw .try_catch_recursive(body)
assertion first failed
call stack .throw .collect_errors_only silent_throw .try_catch_recursive(body) .try_catch_recursive caught_silent_throw
assertion second failed
call stack .throw .collect_errors_only silent_throw .try_catch_recursive(body) .try_catch_recursive caught_silent_throw
$fn if_true .{argfunction} {.if .test_not_empty ( ) {.argfunction}}
$fn if_false .{argfunction} {.if .test_not_empty ()  {.argfunction}}
$fn else_if_true .{argfunction} {
  .else_if .test_string_unequal q w {.argfunction}}
$fn else_if_false .{argfunction} {
  .else_if .test_string_unequal q q {.argfunction}}
$fn else_if_not_true .{argfunction} {
  .else_if_not .test_string_equal x x {.argfunction}}
$fn else_if_not_false .{argfunction} {
  .else_if_not .test_string_equal y z {.argfunction}}
$fn obscured_else .{argfunction} {.scope () {.scope () {.else {.argfunction}}}}
$fn if_with_body args ... {.if $args$ {echo the afore-mentioned body}}
$fn if_else_if_not_with_body args ... {
  .if $args$ {echo the first body}
  .else_if_not $args$ {echo the second body}}
$fn double_if_with_body args ... {
  .if $args$ {echo the first body}
  .if $args$ {echo the second body}}
$fn else_if_with_body args ... {.else_if $args$ {echo the afore-mentioned body}}
$fn else_with_body [args ...] {.else {echo the afore-mentioned &&args$}}
$fn conditional_true {
  .if .test_in . . {echo in_conditional_if}
  .else {echo in_conditional_else}
  .test_in . .}
$fn conditional_false {
  .if .test_in . {echo in_conditional_if}
  .else {echo in_conditional_else}
  .test_in .}
$fn conditional_echo first second {
  .if .test_in () {echo not printed if empty string in null set}
  .else_if_not .echo $first {echo not printed else if echo fails}
  .else {.echo () $second}}
$
$# ! negation: if_core workout
$.function !x args ... {
  .if .throw .false anyway {}
  .else_if_not $args$ {.nop}
  .else {.throw .false ${.echo ! $args}}}
$.function !! args ... {
  .if $args$ {}
  .else {.throw .false ${.echo !! $args}}}
$.test_string_equal 42 420e-1
assertion (42 == 420e-1) failed
call stack .test_string_equal
$.test_number_equal 42 420e-1
$!  .test_greater 50 230
$!x .test_greater 50 230
$!! !  .test_greater 50 230
$!  !! .test_greater 50 230
$!! .test_greater 50 230
assertion (!! .test_greater 50 230) failed
call stack .throw .mapped_argfunction .else !!
$!! !! .test_greater 50 230
assertion (!! !! .test_greater 50 230) failed
call stack .throw .mapped_argfunction .else !!
$!  .test_less 5 2.3e1
assertion (! .test_less 5 2.3e1) failed
call stack .throw .mapped_argfunction .if !
$!x .test_less 5 2.3e1
assertion (! .test_less 5 2.3e1) failed
call stack .throw .mapped_argfunction .else !x
$!! !x .test_less 5 2.3e1
assertion (!! !x .test_less 5 2.3e1) failed
call stack .throw .mapped_argfunction .else !!
$!x !! .test_less 5 2.3e1
assertion (! !! .test_less 5 2.3e1) failed
call stack .throw .mapped_argfunction .else !x
$!! .test_less 5 2.3e1
$!! !! .test_less 5 2.3e1
$!  !  .test_executable_exists !!!
assertion (! ! .test_executable_exists !!!) failed
call stack .throw .mapped_argfunction .if !
$!! !  !  .test_executable_exists !!!
assertion (!! ! ! .test_executable_exists !!!) failed
call stack .throw .mapped_argfunction .else !!
$!  !! !  .test_executable_exists !!!
assertion (! !! ! .test_executable_exists !!!) failed
call stack .throw .mapped_argfunction .if !
$!  !  !! .test_executable_exists !!!
assertion (! ! !! .test_executable_exists !!!) failed
call stack .throw .mapped_argfunction .if !
$!  !x .test_executable_exists !!!
assertion (! !x .test_executable_exists !!!) failed
call stack .throw .mapped_argfunction .if !
$!! !  !x .test_executable_exists !!!
assertion (!! ! !x .test_executable_exists !!!) failed
call stack .throw .mapped_argfunction .else !!
$!  !! !x .test_executable_exists !!!
assertion (! !! !x .test_executable_exists !!!) failed
call stack .throw .mapped_argfunction .if !
$!  !x !! .test_executable_exists !!!
assertion (! !x !! .test_executable_exists !!!) failed
call stack .throw .mapped_argfunction .if !
$!x !  .test_executable_exists !!!
assertion (! ! .test_executable_exists !!!) failed
call stack .throw .mapped_argfunction .else !x
$!! !x !  .test_executable_exists !!!
assertion (!! !x ! .test_executable_exists !!!) failed
call stack .throw .mapped_argfunction .else !!
$!x !! !  .test_executable_exists !!!
assertion (! !! ! .test_executable_exists !!!) failed
call stack .throw .mapped_argfunction .else !x
$!x !  !! .test_executable_exists !!!
assertion (! ! !! .test_executable_exists !!!) failed
call stack .throw .mapped_argfunction .else !x
$!x !x .test_executable_exists !!!
assertion (! !x .test_executable_exists !!!) failed
call stack .throw .mapped_argfunction .else !x
$!! !x !x .test_executable_exists !!!
assertion (!! !x !x .test_executable_exists !!!) failed
call stack .throw .mapped_argfunction .else !!
$!x !! !x .test_executable_exists !!!
assertion (! !! !x .test_executable_exists !!!) failed
call stack .throw .mapped_argfunction .else !x
$!x !x !! .test_executable_exists !!!
assertion (! !x !! .test_executable_exists !!!) failed
call stack .throw .mapped_argfunction .else !x
$!  !  .whence_function !!!
!!! : command not found ( !!! .whence_function .if ! .if ! )
$!x !x .whence_function !!!
!!! : command not found ( !!! .whence_function .else_if_not !x .else_if_not !x )
$!  !  .test_not_empty 0
$!  !x .test_not_empty 0
$!x !  .test_not_empty 0
$!x !x .test_not_empty 0
$!  !  !  .test_in 0 0
assertion (! ! ! .test_in 0 0) failed
call stack .throw .mapped_argfunction .if !
$!  !  !  .test_in 0
$!  !  !  !  .test_in 0
assertion (! ! ! ! .test_in 0) failed
call stack .throw .mapped_argfunction .if !
$!  !  !x !  .test_in 0
assertion (! ! !x ! .test_in 0) failed
call stack .throw .mapped_argfunction .if !
$!  !x !  !  .test_in 0
assertion (! !x ! ! .test_in 0) failed
call stack .throw .mapped_argfunction .if !
$!  !x !x !  .test_in 0
assertion (! !x !x ! .test_in 0) failed
call stack .throw .mapped_argfunction .if !
$!x !  !  !  .test_in 0
assertion (! ! ! ! .test_in 0) failed
call stack .throw .mapped_argfunction .else !x
$!x !  !x !  .test_in 0
assertion (! ! !x ! .test_in 0) failed
call stack .throw .mapped_argfunction .else !x
$!x !x !  !  .test_in 0
assertion (! !x ! ! .test_in 0) failed
call stack .throw .mapped_argfunction .else !x
$!x !x !x !  .test_in 0
assertion (! !x !x ! .test_in 0) failed
call stack .throw .mapped_argfunction .else !x
$!  !  !  !  .test_in 0 0
$!  !  !x !  .test_in 0 0
$!  !x !  !  .test_in 0 0
$!  !x !x !  .test_in 0 0
$!x !  !  !  .test_in 0 0
$!x !  !x !  .test_in 0 0
$!x !x !  !  .test_in 0 0
$!x !x !x !  .test_in 0 0
$se {.if .test_string_equal 42 420e-1 {echo if}; .else {echo else}}
else
$se {.if .test_number_equal 42 420e-1 {echo if}; .else {echo else}}
if
$se {.if !  .test_greater 50 230 {echo if}; .else {echo else}}
if
$se {.if !x .test_greater 50 230 {echo if}; .else {echo else}}
if
$se {.if !! !  .test_greater 50 230 {echo if}; .else {echo else}}
if
$se {.if !  !! .test_greater 50 230 {echo if}; .else {echo else}}
if
$se {.if !! .test_greater 50 230 {echo if}; .else {echo else}}
else
$se {.if !  .test_less 5 2.3e1 {echo if}; .else {echo else}}
else
$se {.if !x .test_less 5 2.3e1 {echo if}; .else {echo else}}
else
$se {.if !! !x .test_less 5 2.3e1 {echo if}; .else {echo else}}
else
$se {.if !x !! .test_less 5 2.3e1 {echo if}; .else {echo else}}
else
$se {.if !! .test_less 5 2.3e1 {echo if}; .else {echo else}}
if
$se {.if !  !  .test_executable_exists !!! {echo if}; .else {echo else}}
else
$se {.if !  !x .test_executable_exists !!! {echo if}; .else {echo else}}
else
$se {.if !x !  .test_executable_exists !!! {echo if}; .else {echo else}}
else
$se {.if !x !x .test_executable_exists !!! {echo if}; .else {echo else}}
else
$se {.if !  !  .whence_function !!! {echo if}; .else {echo else}}
!!! : command not found ( !!! .whence_function .if ! .if ! .if .scope se )
$se {.if !x !x .whence_function !!! {echo if}; .else {echo else}}
!!! : command not found ( !!! .whence_function .else_if_not !x .else_if_not !x .if .scope se )
$se {.if !  !  .test_not_empty 0 {echo if}; .else {echo else}}
if
$se {.if !  !x .test_not_empty 0 {echo if}; .else {echo else}}
if
$se {.if !x !  .test_not_empty 0 {echo if}; .else {echo else}}
if
$se {.if !x !x .test_not_empty 0 {echo if}; .else {echo else}}
if
$se {.if !  !  !  .test_in 0 0 {echo if}; .else {echo else}}
else
$se {.if !  !  !  .test_in 0 {echo if}; .else {echo else}}
if
$se {.if !  !  !  !  .test_in 0 {echo if}; .else {echo else}}
else
$se {.if !  !  !x !  .test_in 0 {echo if}; .else {echo else}}
else
$se {.if !  !x !  !  .test_in 0 {echo if}; .else {echo else}}
else
$se {.if !  !x !x !  .test_in 0 {echo if}; .else {echo else}}
else
$se {.if !x !  !  !  .test_in 0 {echo if}; .else {echo else}}
else
$se {.if !x !  !x !  .test_in 0 {echo if}; .else {echo else}}
else
$se {.if !x !x !  !  .test_in 0 {echo if}; .else {echo else}}
else
$se {.if !x !x !x !  .test_in 0 {echo if}; .else {echo else}}
else
$se {.if !  !  !  !  .test_in 0 0 {echo if}; .else {echo else}}
if
$se {.if !  !  !x !  .test_in 0 0 {echo if}; .else {echo else}}
if
$se {.if !  !x !  !  .test_in 0 0 {echo if}; .else {echo else}}
if
$se {.if !  !x !x !  .test_in 0 0 {echo if}; .else {echo else}}
if
$se {.if !x !  !  !  .test_in 0 0 {echo if}; .else {echo else}}
if
$se {.if !x !  !x !  .test_in 0 0 {echo if}; .else {echo else}}
if
$se {.if !x !x !  !  .test_in 0 0 {echo if}; .else {echo else}}
if
$se {.if !x !x !x !  .test_in 0 0 {echo if}; .else {echo else}}
if
$
$# properly sequenced un-nested conditionals where everything succeeds
$se {
  if_true {echo if_true printing}
  else_if_true {echo else_if_true not printing when condition true}
  else_if_not_false {echo else_if_not_false not printing when condition true}
  else_if_false {echo else_if_false not printing when condition true}
  else_if_not_true {echo else_if_not_false not printing when condition true}
  obscured_else {echo obscured_else not printing when condition true}}
if_true printing
$se {
  if_false {echo if_false not printing}
  else_if_false {echo else_if_false not printing when condition false}
  else_if_not_true {echo else_if_not_true not printing when condition false}
  obscured_else {echo obscured_else is printing when condition false}}
obscured_else is printing when condition false
$se {
  if_false {echo if_false not printing}
  else_if_true {echo else_if_true printing when condition false}
  obscured_else {echo obscured_else not printing when condition true}}
else_if_true printing when condition false
$se {
  if_false {echo if_false not printing}
  else_if_not_false {echo else_if_not_false printing when condition false}
  obscured_else {echo obscured_else not printing when condition true}}
else_if_not_false printing when condition false
$se {
  if_with_body .test_not_empty a
  else_if_with_body .test_not_empty a
  else_with_body}
the afore-mentioned body
$se {
  if_with_body .test_not_empty ()
  else_if_with_body .test_not_empty ()
  else_with_body text expanded}
the afore-mentioned text expanded
$se {
  if_with_body .test_not_empty ()
  else_if_with_body .test_not_empty a
  else_with_body text}
the afore-mentioned body
$
$# nested conditionals
$se {
  .if conditional_true {echo conditional_true printing}
  .else {echo else not printing when condition true}}
in_conditional_if
conditional_true printing
$se {
  .if conditional_false {echo conditional_false not printing}
  .else {echo else is printing when condition false}}
in_conditional_else
else is printing when condition false
$se {
  .if ${conditional_echo .test_is_number 71}$ {echo conditional_echo printing}
  .else {echo else not printing when condition true}}
conditional_echo printing
$se {
  .if ${conditional_echo .test_is_number pi}$ {echo conditional_echo not printing}
  .else {echo else is printing when condition false}}
else is printing when condition false
$se {
  if_true {echo ${conditional_echo print this}}
  .else {echo else not printing when condition true}}
(print this)
$se {
  if_false {echo ${conditional_echo .test_not_empty ()}}
  .else {echo else is printing when condition false}}
else is printing when condition false
$se {
  .if conditional_true {echo ${conditional_echo print this}}
  .else {echo ${conditional_echo not printing}}}
in_conditional_if
(print this)
$se {
  .if conditional_false {echo ${conditional_echo not printing}}
  .else {echo ${conditional_echo print this}}}
in_conditional_else
(print this)
$
$# improperly sequenced conditionals and conditional block exception
$.else {echo top level else without if}
else without if with call stack: .else
$.collect_errors_except .nop {
  .if else_with_body {echo else without if in condition}
  else_if_true {echo else_if ignored after exception}
  else_if_false {echo else_if ignored after exception}
  else_if_not_true {echo else_if_not ignored after exception}
  else_if_not_false {echo else_if_not ignored after exception}
  obscured_else {echo else skipped when properly closing block}
  echo end collect errors}
end collect errors
else without if with call stack: .else else_with_body .if .collect_errors_except
$.collect_errors_except .nop {
  if_true {.else {echo else without if in body}}
  echo else is skipped without issue (expecting exception avoided it)}
else is skipped without issue (expecting exception avoided it)
else without if with call stack: .else .mapped_argfunction .if if_true .collect_errors_except
$.collect_errors_except .nop {
  if_false {echo set up}
  else_if_true {else_if_true {else_if without if}}
  else_with_body}
else without if with call stack: .else_if else_if_true .mapped_argfunction .else_if else_if_true .collect_errors_except
$.collect_errors_except .nop {
  double_if_with_body .test_in if following another top-level if
  if_true {echo if_true printing though it is the third if}
  else_with_body}
the first body
if_true printing though it is the third if
two .if commands without a .else between them with call stack : .if double_if_with_body .collect_errors_except
$.collect_errors_except .nop {
  if_with_body double_if_with_body .test_in double if in condition
  obscured_else {echo else skipped when properly closing block}}
two .if commands without a .else between them with call stack : .if double_if_with_body .if if_with_body .collect_errors_except
$.collect_errors_except .nop {
  if_false {}
  .else {double_if_with_body .test_in double if in body}
  .else {echo double else is an exception even when first throws}
  if_true {echo if_true printing immediately after an else that threw}
  else_with_body}
if_true printing immediately after an else that threw
two .if commands without a .else between them with call stack : .if double_if_with_body .mapped_argfunction .else .collect_errors_except
else without if with call stack: .else .collect_errors_except
$.collect_errors_except .nop {
  if_true {.else {echo else without if}}
  .else {echo ignored because it is at the level of the if
         echo not the else that it immediately follows (if-else ambiguity)}
  if_false {echo if ignored because the condition is false}
  else {echo else run after the properly closed if-else}}
else run after the properly closed if-else
else without if with call stack: .else .mapped_argfunction .if if_true .collect_errors_except
$.collect_errors_except .nop {
  if_false {}
  obscured_else {if_false {echo bad_if_nest in condition body}}
  else_if_true {echo exception for else_if after else that threw}
  else_if_not_false {
    echo else_if_not ignored after else_if that threw without else following}
  .if if_with_body if_with_body .test_in innermost if {echo is not matched}}
nested .if without .else with call stack: .else .scope .scope obscured_else .collect_errors_except
else without if with call stack: .else_if else_if_true .collect_errors_except
nested .if without .else with call stack: .if if_with_body .if .collect_errors_except
$if_false {echo if block not closed}
conditional not finished within preceeding block
$.if if_with_body conditional_true {echo middle if is not matched}
in_conditional_if
the afore-mentioned body
nested .if without .else with call stack: .if
$.if if_else_if_not_with_body .test_in else if without else {
  echo body is not run with exception in condition}
the first body
nested .if without .else with call stack: .if
$.collect_errors_except .nop {
  if_false {}
  obscured_else {if_else_if_not_with_body .test_in else_if without else in body}}
the second body
nested .if without .else with call stack: .else .scope .scope obscured_else .collect_errors_except
$.collect_errors_except .nop {
  if_false {}
  .else {if_true {if_true {echo unmatched if doubled in body}}}}
unmatched if doubled in body
nested .if without .else with call stack: .if if_true .mapped_argfunction .else .collect_errors_except
$.collect_errors_except .nop {
  if_false {}
  .else {.if if_with_body .test_in unmatched {echo if in condition of body}}}
nested .if without .else with call stack: .if .mapped_argfunction .else .collect_errors_except
$.collect_errors_except .nop {
  .try_catch_recursive echo {
    .if silent_throw in if {echo definitely should not print}
    .else {echo skipped because non-.false exception thrown earlier}}}
exception in if .throw .collect_errors_only silent_throw .if .try_catch_recursive(body)
$.collect_errors_except .nop {
  .try_catch_recursive echo {
    .if caught_silent_throw in if {echo still should not print}
    .else {echo not skipped because only .false were thrown earlier}}}
exception in if .throw .collect_errors_only silent_throw .try_catch_recursive(body)
not skipped because only .false were thrown earlier
$
$# exception thrown in argfunction
$se {
  .if ${conditional_echo unfindable anywhere}$ {echo also a failed substitution}
  .else {echo else skipped when condition threw an exception}}
unfindable : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction .if .scope se
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction .if .scope se
unfindable : command not found ( unfindable anywhere .if .scope se )
$se {
  if_true {echo &&&{unfindable anywhere}}
  .else {echo else not printing when condition true and if body threw}}
unfindable : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction .mapped_argfunction .mapped_argfunction .if if_true .scope se
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction .mapped_argfunction .mapped_argfunction .if if_true .scope se
unfindable : command not found ( unfindable anywhere .mapped_argfunction .mapped_argfunction .if if_true .scope se )
substitution (&{unfindable anywhere}) failed
call stack: .mapped_argfunction .if if_true .scope se
$if_true {echo &{unfindable anywhere}}
unfindable : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction .interpret
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction .interpret
unfindable : command not found ( unfindable anywhere .interpret )
substitution (&{unfindable anywhere}) failed
$.else {echo else throws an exception because we never got into the if}
else without if with call stack: .else
$if_only .nop {.for .break ex {if_only .nop {.throw $ex properly nested}}}
$
$# .if .else_if .else_if_not .else
$.collect_errors_except .nop {
  .if
  whence .if
  .else_if .test_is_number 0 {echo do not run after an exception}
  whence .else_if
  .else_if_not .test_is_number false {echo do not run after an exception}
  .else_if
  whence .else_if_not
  .else_if_not
  whence .else
  .else {echo do not run after an exception}}
.if -- condition ... .{argfunction}
.else_if -- condition ... .{argfunction}
.else_if_not -- condition ... .{argfunction}
.else .{argfunction}
unacceptable arguments: for prototype -- condition ... .{argfunction},
 needed (condition),
( call) stack: (.if .collect_errors_except)
.if requires an argfunction
stack .collect_errors_except
else without if with call stack: .else_if .collect_errors_except
unacceptable arguments: for prototype -- condition ... .{argfunction},
 needed (condition),
( call) stack: (.else_if .collect_errors_except)
.else_if requires an argfunction
stack .collect_errors_except
unacceptable arguments: for prototype -- condition ... .{argfunction},
 needed (condition),
( call) stack: (.else_if_not .collect_errors_except)
.else_if_not requires an argfunction
stack .collect_errors_except
$.if missing argfunction
.if requires an argfunction
$.else_if missing argfunction
.else_if requires an argfunction
$.else_if_not missing argfunction
.else_if_not requires an argfunction
$.else
.else requires an argfunction
$se {
  .if .test_is_number 0 {}
  .else {echo first else for if}
  .else {echo second else for if}}
else without if with call stack: .else .scope se
$se {
  .if .test_is_number 0 {echo if true}
  .else {echo else 0 not a number}}
if true
$se {
  .if .test_is_number false {echo if false}
  .else {echo else false is not a number}}
else false is not a number
$.else {}
else without if with call stack: .else
$.else_if .test_is_number 0 {echo not this one}
else without if with call stack: .else_if
$.else {}
$.else_if_not .test_is_number false {echo nor this}
else without if with call stack: .else_if_not
$
$# .internal_features .internal_functions .internal_vars
$.internal_features 1 {excess argfunc}
unacceptable arguments: for prototype ,
 found (1) excess
( call) stack: .internal_features
.internal_features does not accept an argfunction with call stack: .internal_features
$.internal_functions 1
unacceptable arguments: for prototype ,
 found (1) excess
( call) stack: .internal_functions
$.internal_functions {excess argfunc}
.internal_functions does not accept an argfunction with call stack: .internal_functions
$.internal_vars 1 {excess argfunc}
unacceptable arguments: for prototype ,
 found (1) excess
( call) stack: .internal_vars
.internal_vars does not accept an argfunction with call stack: .internal_vars
$.internal_features
.after_command .before_command .run_logic
$.internal_functions
.ambiguous_prototype_dash_dash
.arguments_for_argfunction
.autofunction
.bad_argfunction_style
.bad_args
.bad_if_nest
.binary_does_not_exist
.binary_not_found
.break
.continue
.dash_dash_argument
.dash_star_argument
.directory_not_found
.divide_by_zero
.double_redirection
.duplicate_parameter
.elipsis_first_arg
.elipsis_out_of_option_group
.else_without_if
.epsilon
.excess_argfunction
.excessive_exceptions_collected
.excessive_exceptions_in_catch
.excessive_nesting
.exec_failed
.executable_already_exists
.failed_substitution
.false
.file_open_failure
.file_not_found
.fixed_argument
.flag_in_elipsis
.function_not_found
.global_would_be_masked
.if_before_else
.illegal_function_name
.illegal_variable_name
.input_range
.internal_error
.interrupted_sleep
.invalid_word_selection
.mismatched_brace
.mismatched_bracket
.mismatched_parenthesis
.missing_argfunction
.multiple_argfunctions
.not_a_directory
.not_a_function
.not_a_number
.not_catching_exception
.not_executable
.not_soon_enough
.number_not_an_integer
.raw_command
.return_code
.result_range
.post_elipsis_option
.post_dash_dash_flag
.prompt
.selection_not_found
.shutdown
.sighup
.sigint
.sigquit
.sigpipe
.sigterm
.sigtstp
.sigcont
.sigchld
.sigusr1
.sigusr2
.sigunknown
.tardy_flag
.unchecked_variable
.unclosed_brace
.unclosed_parenthesis
.undeclared_variable
.undefined_variable
.unfinished_if_block
.unreadable_dir
.unrecognized_flag
.unused_before_set
.unused_variable
.variable_already_exists
.version_incompatible
$.internal_vars
FIGNORE
$
$# .is_default_input .is_default_output .is_default_error
$.is_default_input 1
unacceptable arguments: for prototype ,
 found (1) excess
( call) stack: .is_default_input
$.is_default_input {excess argfunc}
.is_default_input does not accept an argfunction with call stack: .is_default_input
$se {.is_default_input <dummy_file}
assertion is_default_input failed
call stack .is_default_input .scope se
$se {.is_default_input}
$.is_default_output 1
unacceptable arguments: for prototype ,
 found (1) excess
( call) stack: .is_default_output
$.is_default_output {excess argfunc}
.is_default_output does not accept an argfunction with call stack: .is_default_output
$e ${.is_default_output; .echo $?}
assertion is_default_output failed
call stack .is_default_output .interpret
substitution (${.is_default_output; .echo $?}) failed
$se {.is_default_output >dummy_file}
assertion is_default_output failed
call stack .is_default_output .scope se
$se {.is_default_output}
$.is_default_error 1
unacceptable arguments: for prototype ,
 found (1) excess
( call) stack: .is_default_error
$.is_default_error {excess argfunc}
.is_default_error does not accept an argfunction with call stack: .is_default_error
$se {.is_default_error}
$
$# .list_executables
$.list_executables excess
unacceptable arguments: for prototype ,
 found (excess) excess
( call) stack: .list_executables
$.list_executables {excess argfunc}
.list_executables does not accept an argfunction with call stack: .list_executables
$forj ${.list_executables}$ {.combine $j $nl}
!
!!
!x
#
#!
##
%
*
+
-
./rwsh
./test_files/../rwsh
.a
.after_command
.ambiguous_prototype_dash_dash
.argc
.arguments_for_argfunction
.autofunction
.bad_argfunction_style
.bad_args
.bad_if_nest
.before_command
.binary
.binary_does_not_exist
.binary_not_found
.break
.cd
.collect_errors_except
.collect_errors_only
.combine
.continue
.dash_dash_argument
.dash_star_argument
.directory_not_found
.disable_readline
.divide_by_zero
.double_redirection
.duplicate_parameter
.echo
.elipsis_first_arg
.elipsis_out_of_option_group
.else
.else_if
.else_if_not
.else_without_if
.enable_readline
.epsilon
.error
.excess_argfunction
.excessive_exceptions_collected
.excessive_exceptions_in_catch
.excessive_nesting
.exec
.exec_failed
.executable_already_exists
.execution_count
.exit
.failed_substitution
.fallback_handler
.false
.file_not_found
.file_open_failure
.fixed_argument
.flag_in_elipsis
.for
.for_each_line
.fork
.function
.function_not_found
.get_fallback_message
.get_max_collectible_exceptions
.get_max_extra_exceptions
.get_max_nesting
.getpid
.getppid
.global
.global_would_be_masked
.help
.if
.if_before_else
.illegal_function_name
.illegal_variable_name
.init
.input_range
.internal_error
.internal_features
.internal_functions
.internal_vars
.interrupted_sleep
.invalid_word_selection
.is_default_error
.is_default_input
.is_default_output
.last_exception
.last_execution_time
.list_environment
.list_executables
.list_locals
.local
.local_declare
.ls
.mismatched_brace
.mismatched_bracket
.mismatched_parenthesis
.missing_argfunction
.multiple_argfunctions
.nop
.not_a_directory
.not_a_function
.not_a_number
.not_catching_exception
.not_executable
.not_soon_enough
.number_not_an_integer
.post_dash_dash_flag
.post_elipsis_option
.prompt
.raw_command
.reinterpret
.replace_exception
.result_range
.return_code
.rm_executable
.scope
.selection_not_found
.selection_set
.set
.set_fallback_message
.set_max_collectible_exceptions
.set_max_extra_exceptions
.set_max_nesting
.shutdown
.sigchld
.sigcont
.sighup
.siginfo
.sigint
.sigpipe
.sigquit
.sigterm
.sigtstp
.sigunknown
.sigusr1
.sigusr2
.source
.stepwise
.store_output
.tardy_flag
.test_executable_exists
.test_file_exists
.test_greater
.test_in
.test_is_number
.test_less
.test_not_empty
.test_number_equal
.test_string_equal
.test_string_unequal
.throw
.toggle_readline
.total_execution_time
.try_catch_recursive
.type
.unchecked_variable
.unclosed_brace
.unclosed_parenthesis
.undeclared_variable
.undefined_variable
.unfinished_if_block
.unreadable_dir
.unrecognized_flag
.unset
.unused_before_set
.unused_variable
.usleep
.usleep_overhead
.var_add
.var_divide
.var_exists
.var_modulo
.var_multiply
.var_subtract
.variable_already_exists
.vars
.version
.version_compatible
.version_incompatible
.waiting_for_binary
.waiting_for_shell
.waiting_for_user
.whence_function
.which_path
.while
/
/bin/cat
/bin/echo
/bin/false
/bin/rm
/bin/true
/usr/bin/env
a
af
b
c
caught_silent_throw
collecting_handler
conditional_echo
conditional_false
conditional_true
do_while
double_if_with_body
e
echo
echo-comments
echo-i-y
echoe
echow
elif
else
else_if_false
else_if_not_false
else_if_not_true
else_if_true
else_if_with_body
else_with_body
env
exec
fIJ
false
fn
fns
foreok
forj
g
h
if_else_if_not_with_body
if_false
if_only
if_only_not
if_true
if_with_body
ll
ln
ntimes
obscured_else
outer_break
outer_continue
outer_for
outer_while
paren_if_words
polish
rpn
sa
se
setf
silent_throw
single
test
test_files/../rwsh
test_var_greater
test_var_not_equal
true
type
var_exists
var_in
var_less
var_val
whence
whichp
while_and_one_more
$
$# .ls
$.ls
unacceptable arguments: for prototype -- paths ...,
 needed (paths),
( call) stack: .ls
$.ls /bin {excess argfunc}
.ls does not accept an argfunction with call stack: .ls
$.ls /bin/usr/
could not find file /bin/usr/
call stack .ls
$.ls /bi  /us /nr
could not find file (/bi /us /nr)
call stack .ls
$.ls /bin /usr/
/bin
/usr/
$
$# .nop
$whence .nop
.nop -- [args ...] [.{argfunction}]
$.nop
$.nop {optional argfunc}
$.nop 1 2 3 4 5
$
$# .replace_exception
$.replace_exception
unacceptable arguments: for prototype -- args ... [.{argfunction}],
 needed (args),
( call) stack: .replace_exception
$.replace_exception echo not in exception handler
.replace_exception called outside of an exception handler
call stack: .replace_exception
$.try_catch_recursive .replace_exception {
  .throw .replace_exception echo now in exception handler}
now in exception handler .throw .try_catch_recursive(body) .replace_exception .try_catch_recursive
$.try_catch_recursive .replace_exception {
  .throw .replace_exception forj {echo $j is on the call stack}}
.throw is on the call stack
.try_catch_recursive(body) is on the call stack
.replace_exception is on the call stack
.try_catch_recursive is on the call stack
$
$# .scope .reinterpret prototype.cc
$.scope
unacceptable arguments: for prototype -- [list ...] prototype .{argfunction},
 needed (prototype),
( call) stack: .scope
.scope requires an argfunction
$.reinterpret {e $foo}
unacceptable arguments: for prototype -- [list ...] prototype,
 needed (prototype),
( call) stack: .reinterpret
.reinterpret does not accept an argfunction with call stack: .reinterpret
$.scope () {.scope foo}
.scope requires an argfunction
stack .scope
$.scope a (y y) {echo illegal duplicate required parameter}
duplicated parameter in function definition: y
call stack: .scope
$.scope a ([-x] [-x]) {echo illegal duplicate flag parameter}
duplicated parameter in function definition: -x
call stack: .scope
$.scope a ([x x]) {echo illegal duplicate optional parameter}
duplicated parameter in function definition: x
call stack: .scope
$.scope a ([-x arg bar] [-y arg]) {echo illegal duplicate flag argument}
duplicated parameter in function definition: arg
call stack: .scope
$.scope a (-x [-x]) {echo evil duplication between flags positional}
duplicated parameter in function definition: -x
call stack: .scope
$.scope -- -- {echo -- as a prototype forbids even -- as arguments}
unacceptable arguments: for prototype --,
 found (--) excess
( call) stack: .scope
$.scope -- () {echo but ${.list_locals} is acceptable for empty prototype}
but -- is acceptable for empty prototype
$.scope () {echo no arguments are also good for empty prototype}
no arguments are also good for empty prototype
$.scope a (-- --) {echo -- cannot be a duplicate parameter}
duplicated parameter in function definition: --
call stack: .scope
$.scope a ([--] [--]) {echo [--] cannot be a duplicate flag parameter}
duplicated parameter in function definition: --
call stack: .scope
$.scope a ([--] --) {echo -- and [--] cannot both be parameters}
duplicated parameter in function definition: --
call stack: .scope
$.scope a ([-- arg]) {echo -- cannot take arguments}
optional -- parameter cannot take arguments ( ([-- arg]) ) with call stack: .scope
$.scope a ([arg -- foo]) {echo -- cannot be an argument}
optional -- parameter cannot take arguments ( ([arg -- foo]) ) with call stack: .scope
$.scope (args ...) {foreok ${.list_locals}$ j {.combine $j = $$j $nl}}
unacceptable arguments: for prototype args ...,
 needed (args),
( call) stack: .scope
$.scope ([args ...]) {foreok ${.list_locals}$ j {.combine $j = $$j $nl}}
$.scope () (args ...) {foreok ${.list_locals}$ j {.combine $j = $$j $nl}}
args=()
$.scope () ([args ...]) {foreok ${.list_locals}$ j {.combine $j = $$j $nl}}
args=()
$.scope -x -y a b ([-?] args ...) {
  forj ${.list_locals}$ {.combine $j = $$j \ }; .echo $nl}
-*=-x -y -?=-x -y args=a b 
$.scope .foo {echo fixed arguments not yet supported}
.foo : fixed arguments are not supported at this time
call stack .scope
$.scope a ([-? bad] arg) {e -? cannot currently take arguments}
optional -* parameter cannot take arguments ( ([-? bad]) ) with call stack: .scope
$.scope a ([-* bad] arg) {e -* (aka -?) cannot currently take arguments}
optional -* parameter cannot take arguments ( ([-* bad]) ) with call stack: .scope
$.scope -a -* -b a ([-?] a) {
  forj ${.list_locals}$ {.combine $j = $$j \ }; .echo $nl}
-*=-a -* -b -?=-a -* -b a=a 
$.scope bar foo {echo aa $foo bb}
aa bar bb
$.scope baz bax (foo bar) {
  forj ${.list_locals}$ {.combine $j = $$j \ }; .echo $nl}
bar=bax foo=baz 
$.scope foo bar baz bax (args ...) {echo aa $args$2 bb $args$1 cc}
aa baz bb bar cc
$.scope single ([-x] [--long-opt y] second) {
  var_val ${.list_locals}$; .echo $nl}
-*() second(single) 
$.reinterpret [jj]
jj was not declared
call stack: .reinterpret
$.scope [-x] {.reinterpret -x bar ([-x kk])}
kk was not declared
call stack: .reinterpret .scope
-x was not checked with call stack .scope
$.scope ([n y]) {.scope local_val x {.reinterpret insufficient (n y)}}
unacceptable arguments: for prototype n y,
 assigned n=insufficient ,
 but needed (y),
( call) stack: (.reinterpret .scope .scope)
$.scope one two (a b [c]) {
  .reinterpret $a $b (c [b] a)
  echo $a$ $c$}
two one
b was not checked with call stack .scope
$fn arg_req .{argfunction} {
  echo before argfunction
  .scope () {.argfunction}}
$arg_req {echo the argfunction}
before argfunction
the argfunction
$arg_req not an argfunction
unacceptable arguments: for prototype .{argfunction},
 found (not an argfunction) excess
( call) stack: arg_req
arg_req requires an argfunction
$fn arg_opt [.{argfunction}] {
  .test_executable_exists .argfunction {.argfunction}
  .scope () {.argfunction}}
$arg_opt {echo the argfunction}
the argfunction
$arg_opt
assertion (executable exists: .argfunction) failed
call stack .test_executable_exists arg_opt
$arg_opt not an argfunction
unacceptable arguments: for prototype [.{argfunction}],
 found (not an argfunction) excess
( call) stack: arg_opt
$fn arg_none {echo argfunction will not be accepted}
$arg_none bad arguments {echo will not print}
unacceptable arguments: for prototype ,
 found (bad arguments) excess
( call) stack: arg_none
arg_none does not accept an argfunction with call stack: arg_none
$arg_none
argfunction will not be accepted
$.function a [-x] [--long-opt y] second {
  forj ${.list_locals}$ {.combine $j \( $$j \) \ }
  .combine $nl}
$whence a
.function a [--long-opt y] [-x] second {
  forj ${.list_locals}$ {.combine $j \( $$j \) ( )}
  .combine $nl}
$.function pt -- args ... {
  .scope $args$ ([-x] [--long-opt y] second) {
    forj ${.list_locals}$ {.combine $j \( $$j \) \ }}
  .combine $nl
  .scope $args$ ( [-?] [--long-opt y] second) {
    forj ${.list_locals}$ {.combine $j \( $$j \) \ }}
  .combine $nl}
$whence pt
.function pt -- args ... {
  .scope $args$ ([-x] [--long-opt y] second) {
    forj ${.list_locals}$ {.combine $j \( $$j \) ( )}}
  .combine $nl
  .scope $args$ ( [-?] [--long-opt y] second) {
    forj ${.list_locals}$ {.combine $j \( $$j \) ( )}}
  .combine $nl}
$a
unacceptable arguments: for prototype [--long-opt y] [-x] second,
 assigned -*=() ,
 but needed (second),
( call) stack: a
$a single
-*() second(single) 
$pt single
-*() second(single) 
-*() -?() second(single) 
$a -x single
-*(-x) -x(-x) second(single) 
$pt -x single
-*(-x) -x(-x) second(single) 
-*(-x) -?(-x) second(single) 
$a --long-opt arg single
-*(--long-opt arg) --long-opt(--long-opt arg) second(single) y(arg) 
$pt --long-opt arg single
-*(--long-opt arg) --long-opt(--long-opt arg) second(single) y(arg) 
-*(--long-opt arg) --long-opt(--long-opt arg) -?() second(single) y(arg) 
$a --long-opt single
unacceptable arguments: for prototype [--long-opt y] [-x] second,
 assigned -*=(--long-opt single) --long-opt=(--long-opt single) y=single ,
 but needed (second),
( call) stack: a
$pt --long-opt single
unacceptable arguments: for prototype [--long-opt y] [-x] second,
 assigned -*=(--long-opt single) --long-opt=(--long-opt single) y=single ,
 but needed (second),
( call) stack: (.scope pt)
$a --long-opt first -x --long-opt second single
-*(--long-opt first -x --long-opt second) --long-opt(--long-opt first --long-opt second) -x(-x) second(single) y(first second) 
$pt --long-opt first -x --long-opt second single
-*(--long-opt first -x --long-opt second) --long-opt(--long-opt first --long-opt second) -x(-x) second(single) y(first second) 
-*(--long-opt first -x --long-opt second) --long-opt(--long-opt first --long-opt second) -?(-x) second(single) y(first second) 
$.function a [-?] [-first] {
  forj ${.list_locals}$ {.combine $j \( $$j \) \ }
  echo nothing_required}
$whence a
.function a [-?] [-first] {
  forj ${.list_locals}$ {.combine $j \( $$j \) ( )}
  echo nothing_required}
$.function pts -- [args ...] {
  .if var_exists args {
    .scope $args$ ([-first] [-?]) {
      forj ${.list_locals}$ {.combine $j \( $$j \) \ }}
      echo nothing_required}
  else {.scope ([-first] [-?]) {
      forj ${.list_locals}$ {.combine $j \( $$j \) \ }}
      echo nothing_required}}
$whence pts
.function pts -- [args ...] {
  .if var_exists args {
    .scope $args$ ([-first] [-?]) {
      forj ${.list_locals}$ {.combine $j \( $$j \) ( )}}
      echo nothing_required}
  else {.scope ([-first] [-?]) {
      forj ${.list_locals}$ {.combine $j \( $$j \) ( )}}
      echo nothing_required}}
$a
-*() -?() nothing_required
$pts
-*() -?() nothing_required
$a excess
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=() -?=() ,
 but found (excess) excess
( call) stack: a
$pts excess
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=() -?=() ,
 but found (excess) excess
( call) stack: (.scope .mapped_argfunction .if pts)
$a -to
-*(-to) -?(-to) nothing_required
$pts -to
-*(-to) -?(-to) nothing_required
$a -first --
-*(-first --) --(--) -?(--) -first(-first) nothing_required
$pts -first --
-*(-first --) --(--) -?(--) -first(-first) nothing_required
$a -first excess
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=-first -?=() -first=-first ,
 but found (excess) excess
( call) stack: a
$pts -first excess
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=-first -?=() -first=-first ,
 but found (excess) excess
( call) stack: (.scope .mapped_argfunction .if pts)
$a -to -- -first
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=(-to --) --=-- -?=(-to --) ,
 but found (-first) excess
( call) stack: a
$pts -to -- -first
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=(-to --) --=-- -?=(-to --) ,
 but found (-first) excess
( call) stack: (.scope .mapped_argfunction .if pts)
$a -to -first
-*(-to -first) -?(-to) -first(-first) nothing_required
$pts -to -first
-*(-to -first) -?(-to) -first(-first) nothing_required
$
$# .selection_set
$.selection_set A
unacceptable arguments: for prototype -- var value ...,
 assigned var=A ,
 but needed (value),
( call) stack: .selection_set
$.selection_set A /usr {excess argfunc}
.selection_set does not accept an argfunction with call stack: .selection_set
$.selection_set A /usr
$echo $A$
/usr
$.selection_set A ./
$echo $A$
/usr/*
$.selection_set A local/include
$echo $A$
/usr/local/include
$.selection_set A ..
$echo $A$
/usr
$.selection_set A ()
$echo $A$
/usr
$.selection_set A ./local/../../bin
$echo $A$
/bin
$.selection_set A sbin etc
$echo $A$
/sbin etc
$
$# .set
$.set A
unacceptable arguments: for prototype -- var value ...,
 assigned var=A ,
 but needed (value),
( call) stack: .set
$.set 1 x
$1 cannot be set
call stack .set
$.scope [undefined] {.collect_errors_except .nop {
  .set undeclared is an error
  echo $undeclared}}
undeclared was not declared
call stack: .set .collect_errors_except .scope
undeclared was not declared
call stack: .collect_errors_except .scope
undefined was not checked with call stack .scope
$.scope [undefined] {.collect_errors_except .nop {
  .set undefined and also unchecked
  echo $undefined}}
(and also unchecked)
$.scope but_ignored [defined] {.collect_errors_except .nop {
  .set defined but also unchecked
  echo $defined}}
but_ignored
attempt to set defined before making use of its initial value
call stack .set .collect_errors_except .scope
$.scope unchanged [defined] {.collect_errors_except .nop {
  .set defined unchanged
  echo variable $defined by a set does not throw}}
variable unchanged by a set does not throw
$.scope [undefined] {.collect_errors_except .nop {
  if_only_not .var_exists undefined {.set undefined is checked}
  echo $undefined}}
(is checked)
$.set B x {excess argfunc}
.set does not accept an argfunction with call stack: .set
$.set A x
$echo $A
x
$
$# .try_catch_recursive .get_max_extra_exceptions .set_max_extra_exceptions
$.try_catch_recursive .function_not_found
.try_catch_recursive requires an argfunction
$.try_catch_recursive {.test_less 0 A}
unacceptable arguments: for prototype -- exception ... .{argfunction},
 needed (exception),
( call) stack: .try_catch_recursive
$fn e_after .{argfunction} {se {.argfunction}; echo after}
$e_after {.try_catch_recursive .not_a_number .function_not_found {
  .test_less 0 A}}
A is not a number
call stack: .test_less .try_catch_recursive(body)
after
$e_after {
  .try_catch_recursive .function_not_found .binary_not_found \
                       .failed_substitution {
    ..test_less 0 A}}
..test_less : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction .try_catch_recursive(body)
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction .try_catch_recursive(body)
..test_less : command not found ( ..test_less 0 A .try_catch_recursive(body) )
after
$e_after {.try_catch_recursive .not_a_number {.test_less 0 A}}
A is not a number
call stack: .test_less .try_catch_recursive(body)
after
$e_after {.try_catch_recursive .not_a_number {.cho A}}
.cho : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction .try_catch_recursive(body) .try_catch_recursive .scope se e_after
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction .try_catch_recursive(body) .try_catch_recursive .scope se e_after
.cho : command not found ( .cho A .try_catch_recursive(body) .try_catch_recursive .scope se e_after )
$e_after {.try_catch_recursive .not_a_number .function_not_found {echo A}}
A
after
$e_after {sa echo hi {.try_catch_recursive ${.internal_functions}$ {&&&args$}}}
hi
after
$.get_max_extra_exceptions excess
unacceptable arguments: for prototype ,
 found (excess) excess
( call) stack: .get_max_extra_exceptions
$.set_max_extra_exceptions
unacceptable arguments: for prototype -- maximum,
 needed (maximum),
( call) stack: .set_max_extra_exceptions
$.get_max_extra_exceptions {excess}
.get_max_extra_exceptions does not accept an argfunction with call stack: .get_max_extra_exceptions
$.set_max_extra_exceptions 1 {excess}
.set_max_extra_exceptions does not accept an argfunction with call stack: .set_max_extra_exceptions
$.set_max_extra_exceptions NaN
NaN is not a number
call stack: .set_max_extra_exceptions
$.set_max_extra_exceptions -1
value -1 is out of usable numeric range
call stack .set_max_extra_exceptions
$.scope () {.get_max_extra_exceptions; .echo $nl}
1
$.set_max_extra_exceptions 0
$.scope () {.get_max_extra_exceptions; .echo $nl}
0
$e_after {.try_catch_recursive .not_a_number {
  .try_catch_recursive .not_a_number {.test_less 0 A}}}
A is not a number
call stack: .test_less .try_catch_recursive(body) .try_catch_recursive .try_catch_recursive(body) .try_catch_recursive .scope se e_after
exceeded maximum number of exceptions ( 0 ) in try_catch.
call stack: .try_catch_recursive .try_catch_recursive(body) .try_catch_recursive .scope se e_after
$e_after {.try_catch_recursive .not_a_number {
  .try_catch_recursive .not_a_number {.test_less 0 A}}}
A is not a number
call stack: .test_less .try_catch_recursive(body) .try_catch_recursive .try_catch_recursive(body) .try_catch_recursive .scope se e_after
exceeded maximum number of exceptions ( 0 ) in try_catch.
call stack: .try_catch_recursive .try_catch_recursive(body) .try_catch_recursive .scope se e_after
$e_after {sa echo hi {.try_catch_recursive ${.internal_functions}$ {&&&args$}}}
hi
after
$.set_max_extra_exceptions 5
$.scope () {.get_max_extra_exceptions; .echo $nl}
5
$
$# .stepwise
$.function wrapper args ... {a $args$ two; a $args$ three}
$.function a args ... {echow $args$ one; echow $args$ two
  echow $args$ three}
$.function d args ... {echow $args$; .stepwise $args$ (cmd ...) {d $cmd$}}
$.stepwise {echo $argv$}
unacceptable arguments: for prototype -- command ... prototype .{argfunction},
 needed (command prototype),
( call) stack: .stepwise
$.stepwise wrapper 1 2 (cmd ...)
.stepwise requires an argfunction
$.stepwise stepwise (cmd ...) {echo $cmd}
stepwise : command not found ( stepwise .stepwise )
$.stepwise .stepwise (cmd ...) {echo $cmd}
$.stepwise ! (cmd ...) {echo $cmd}
unacceptable arguments: for prototype -- args ...,
 needed (args),
( call) stack: .stepwise
$.stepwise wrapper 1 2 (cmd ...) {echo $cmd$}
a 1 2 two
a 1 2 three
$.function wrapper args ... {a $args$ one
  a $args$ two; a $args$ three}
$wrapper 1 2
1 2 one one
1 2 one two
1 2 one three
1 2 two one
1 2 two two
1 2 two three
1 2 three one
1 2 three two
1 2 three three
$.stepwise wrapper 1 2 (cmd ...) {d $cmd$}
a 1 2 one
echow 1 2 one one
.echo 1 2 one one
.combine 

echow 1 2 one two
.echo 1 2 one two
.combine 

echow 1 2 one three
.echo 1 2 one three
.combine 

a 1 2 two
echow 1 2 two one
.echo 1 2 two one
.combine 

echow 1 2 two two
.echo 1 2 two two
.combine 

echow 1 2 two three
.echo 1 2 two three
.combine 

a 1 2 three
echow 1 2 three one
.echo 1 2 three one
.combine 

echow 1 2 three two
.echo 1 2 three two
.combine 

echow 1 2 three three
.echo 1 2 three three
.combine 

$.stepwise wrapper 1 2 (argv ...) {
  echo current line: $argv$
  if_only .test_string_equal $4 two {
    .collect_errors_except .nop {
      .throw .continue
      .throw .break
      .throw .continue}}
  .throw .continue
  echo not printed}
current line: a 1 2 one
current line: a 1 2 two
$.stepwise wrapper 1 2 (argv ...) {echoe $argv$ $nl}
a 1 2 one 
a 1 2 two 
a 1 2 three 
$.function a {echo -x allowed; echo -y allowed; echo -z rejected}
$.stepwise a (cmd [-x] [-y] comment) {$cmd $-* $comment}
-x allowed
-y allowed
-z flag is unrecognized for ([-x] [-y] cmd comment)
call stack: .stepwise(body) .stepwise
$
$# .test_file_exists
$.test_file_exists
unacceptable arguments: for prototype -- path ...,
 needed (path),
( call) stack: .test_file_exists
$.test_file_exists dummy_file {excess argfunc}
.test_file_exists does not accept an argfunction with call stack: .test_file_exists
$.test_file_exists /b /in
assertion ( -e /b -e /in) failed
call stack .test_file_exists
$.test_file_exists /b /bin /in
$
$# .test_string_equal .test_string_unequal .test_not_empty .test_in
$.test_string_equal x
unacceptable arguments: for prototype -- left_string right_string,
 assigned left_string=x ,
 but needed (right_string),
( call) stack: .test_string_equal
$.test_string_equal x x x
unacceptable arguments: for prototype -- left_string right_string,
 assigned left_string=x right_string=x ,
 but found (x) excess
( call) stack: .test_string_equal
$.test_string_equal x x {excess argfunc}
.test_string_equal does not accept an argfunction with call stack: .test_string_equal
$.test_string_unequal x
unacceptable arguments: for prototype -- left_string right_string,
 assigned left_string=x ,
 but needed (right_string),
( call) stack: .test_string_unequal
$.test_string_unequal x x x
unacceptable arguments: for prototype -- left_string right_string,
 assigned left_string=x right_string=x ,
 but found (x) excess
( call) stack: .test_string_unequal
$.test_string_unequal x x {excess argfunc}
.test_string_unequal does not accept an argfunction with call stack: .test_string_unequal
$.test_not_empty
assertion ( -n ) failed
call stack .test_not_empty
$.test_not_empty x x
$.test_not_empty x {excess argfunc}
.test_not_empty does not accept an argfunction with call stack: .test_not_empty
$.test_string_equal x y
assertion (x == y) failed
call stack .test_string_equal
$.test_string_equal x x
$.test_string_unequal x y
$.test_string_unequal x x
assertion (x != x) failed
call stack .test_string_unequal
$.test_not_empty \
assertion ( -n ) failed
call stack .test_not_empty
$.test_not_empty x
$.test_not_empty x ()
$.test_not_empty () x
$.test_not_empty () () ()
assertion ( -n ) failed
call stack .test_not_empty
$.test_in
unacceptable arguments: for prototype -- focus [list ...],
 needed (focus),
( call) stack: .test_in
$.test_in x
assertion (x in) failed
call stack .test_in
$.test_in x x
$.test_in z y z
$.test_in w x y z
assertion (w in x y z) failed
call stack .test_in
$.test_in y x y z
$
$# .test_is_number .test_number_equal .test_greater .test_less
$.test_is_number
unacceptable arguments: for prototype -- value,
 needed (value),
( call) stack: .test_is_number
$.test_is_number 42 {excess argfunc}
.test_is_number does not accept an argfunction with call stack: .test_is_number
$.test_is_number ()
assertion (is_number  - NaN) failed
call stack .test_is_number
$.test_is_number 42a
assertion (is_number 42a - NaN) failed
call stack .test_is_number
$.test_is_number 42
$.test_is_number -0.314
$.test_is_number 6.022e9000000000
assertion (is_number 6.022e9000000000 - range) failed
call stack .test_is_number
$.test_is_number 6.022e23
$.test_number_equal 42
unacceptable arguments: for prototype -- lhs rhs,
 assigned lhs=42 ,
 but needed (rhs),
( call) stack: .test_number_equal
$.test_number_equal 42 42 {excess argfunc}
.test_number_equal does not accept an argfunction with call stack: .test_number_equal
$.test_number_equal 42 42a
42a is not a number
call stack: .test_number_equal
$.test_number_equal 42b 42
42b is not a number
call stack: .test_number_equal
$.test_number_equal 0 0.000000000000000000000000001
assertion (0 -eq 0.000000000000000000000000001) failed
call stack .test_number_equal
$.test_number_equal 1e-9000000000 1e-9000000001
value 1e-9000000000 is out of usable numeric range
call stack .test_number_equal
value 1e-9000000001 is out of usable numeric range
call stack .test_number_equal
$.test_number_equal 0 0.0
$.test_number_equal 42 42.01
assertion (42 -eq 42.01) failed
call stack .test_number_equal
$.test_number_equal 42 42
$.test_number_equal 6.022e9000000000 .6022e24
value 6.022e9000000000 is out of usable numeric range
call stack .test_number_equal
$.test_number_equal 6.022e23 .6022e9000000001
value .6022e9000000001 is out of usable numeric range
call stack .test_number_equal
$.test_number_equal 6.022e23 6.022e2
assertion (6.022e23 -eq 6.022e2) failed
call stack .test_number_equal
$.test_number_equal 6.022e23 .6022e24
$.test_greater 6.022e23
unacceptable arguments: for prototype -- lhs rhs,
 assigned lhs=6.022e23 ,
 but needed (rhs),
( call) stack: .test_greater
$.test_greater 6.022e23c 6.022e23 {excess argfunc}
.test_greater does not accept an argfunction with call stack: .test_greater
$.test_greater 6.022e23c 6.022e23e
6.022e23c is not a number
call stack: .test_greater
6.022e23e is not a number
call stack: .test_greater
$.test_greater 6.022e9000000000 .6022e23
value 6.022e9000000000 is out of usable numeric range
call stack .test_greater
$.test_greater 6.022e23 .6022e9000000001
value .6022e9000000001 is out of usable numeric range
call stack .test_greater
$.test_greater 6.022e2 6.022e23
assertion (6.022e2 -gt 6.022e23) failed
call stack .test_greater
$.test_greater 6.022e23 .6022e24
assertion (6.022e23 -gt .6022e24) failed
call stack .test_greater
$.test_greater 6.022e23 6.022e2
$.test_less 6.022e23
unacceptable arguments: for prototype -- lhs rhs,
 assigned lhs=6.022e23 ,
 but needed (rhs),
( call) stack: .test_less
$.test_less 6.022b23 6.022e23 {excess argfunc}
.test_less does not accept an argfunction with call stack: .test_less
$.test_less 6.022b23 6.022a23
6.022b23 is not a number
call stack: .test_less
6.022a23 is not a number
call stack: .test_less
$.test_less 6.022e9000000000 .6022e23
value 6.022e9000000000 is out of usable numeric range
call stack .test_less
$.test_less 6.022e23 .6022e9000000001
value .6022e9000000001 is out of usable numeric range
call stack .test_less
$.test_less 6.022e23 6.022e2
assertion (6.022e23 -lt 6.022e2) failed
call stack .test_less
$.test_less 6.022e23 .6022e24
assertion (6.022e23 -lt .6022e24) failed
call stack .test_less
$.test_less 6.022e2 6.022e23
$
$# .enable_readline .disable_readline .toggle_readline
$.toggle_readline excess
unacceptable arguments: for prototype ,
 found (excess) excess
( call) stack: .toggle_readline
$.toggle_readline {excess}
.toggle_readline does not accept an argfunction with call stack: .toggle_readline
$.enable_readline excess
unacceptable arguments: for prototype ,
 found (excess) excess
( call) stack: .enable_readline
$.enable_readline {excess}
.enable_readline does not accept an argfunction with call stack: .enable_readline
$.disable_readline excess
unacceptable arguments: for prototype ,
 found (excess) excess
( call) stack: .disable_readline
$.disable_readline {excess}
.disable_readline does not accept an argfunction with call stack: .disable_readline
$.nop .enable_readline
$.nop .disable_readline
$.nop .toggle_readline
$.nop .toggle_readline
$
$# .test_executable_exists .type .whence_function
$# Arg_script::str() but only an unknown fraction of the lines
$# Arg_spec::str() (except trailing whitespace) only through SOON case
$.test_executable_exists
unacceptable arguments: for prototype -- command [.{argfunction}],
 needed (command),
( call) stack: .test_executable_exists
$.test_executable_exists j
assertion (executable exists: j) failed
call stack .test_executable_exists
$.test_executable_exists #
$.test_executable_exists .nop
$.test_executable_exists /bin/cat
$.test_executable_exists .mapped_argfunction
assertion (executable exists: .mapped_argfunction) failed
call stack .test_executable_exists
$.test_executable_exists .mapped_argfunction {.argfunction}
$.type
unacceptable arguments: for prototype -- command [.{argfunction}],
 needed (command),
( call) stack: .type
$.type j
j : command not found ( j .type )
$.type #
function
$.type .nop
builtin
$.type /bin/cat
file
$.type .mapped_argfunction
.mapped_argfunction : command not found ( .mapped_argfunction .type )
$.type .mapped_argfunction {.argfunction}
argfunction
$type .nop .mapped_argfunction j # {.argfunction}
.nop is builtin
.mapped_argfunction is .mapped_argfunction : command not found ( .mapped_argfunction .type .try_catch_recursive(body) )
j is j : command not found ( j .type .try_catch_recursive(body) )
# is function
$type -t .nop .mapped_argfunction j # {.argfunction}
builtin
.mapped_argfunction : command not found ( .mapped_argfunction .type .try_catch_recursive(body) )
j : command not found ( j .type .try_catch_recursive(body) )
function
$.whence_function
unacceptable arguments: for prototype -- command [.{argfunction}],
 needed (command),
( call) stack: .whence_function
$.whence_function j
j : command not found ( j .whence_function )
$.whence_function #
.function # -- [ignored ...] [.{argfunction}] {.nop $ignored$}
$.whence_function .nop
.nop -- [args ...] [.{argfunction}]
$.whence_function /bin/cat
/bin/cat
$.whence_function .mapped_argfunction
.mapped_argfunction : command not found ( .mapped_argfunction .whence_function )
$.whence_function .mapped_argfunction {.argfunction}
{.argfunction}
$whence .mapped_argfunction {.nop 1 () \ \\ \$ \@ \) \(}
{.nop 1 () ( \\) \$ \@ \) \(}
$whence .mapped_argfunction {.nop 1 () \  \\ \$ \@ \) \(}
{.nop 1 () ( ) \\ \$ \@ \) \(}
$whence .mapped_argfunction {@a @$a @$1 @$* @$*2}
{@a @$a @$1 @$*1 @$*2}
$whence .mapped_argfunction {>dummy_file}
{>dummy_file}
$# new tests here
$.whence_function .mapped_argfunction {{&&{&&x &&{e}}$$$ ${&&x ${e}}$$$ {&&&x &&&{e} {&&&&x &&&&{e}}}}}
{{&{&x &{e}}$$$ ${&x ${e}}$$$ {&&x &&{e} {&&&x &&&{e}}}}}
$whence .mapped_argfunction {$A $$A $0 $$$1 $# $* $*2 $A$$$ $A$10 $$*$ $$$*12$}
{$A $$A $0 $$$1 $# $* $*2 $A$$$ $A$10 $$*$ $$$*12$}
$.whence_function .mapped_argfunction {&&A &&0 &&* &&*3 &&$A$$$ &&$A$10 &&*$ &&*6$ {&&&A$ &&&A$10}}
{&A &0 &* &*3 &$A$$$ &$A$10 &*$ &*6$ {&&A$ &&A$10}}
$.function wm [args ...] .{argfunction} {
   .whence_function .mapped_argfunction {.argfunction}
   .scope $args$ (a1 a2 a3) {.argfunction}}
$wm (aa ab ac) bb cc {
  echoe x &&a1 &&2 $a3 y &&a1$1 z &&a1$2; .nop $a2
  sa &&a1$ {echoe () w $args$ $#; echoe $nl}}
{
  echoe x &a1 &2 $a3 y &a1$1 z &a1$2; .nop $a2
  sa &a1$ {echoe () w $args$ $#; echoe $nl}}
x aa ab ac bb cc y ab z ac w aa ab ac 4
$.scope (aa ab ac) bb cc (args more ...) {.scope $args $more$ (args more ...) {
  sa &&1 {echo $args$ $#}
  sa &&args {echo $args$ $#}
  sa &&&args {echo $args$ $#}
  sa $args {echo $args$ $#}
  sa $args$ {echo $args$ $#}
  sa $more$ {echo $args$ $#}}}
(aa ab ac) 2
(aa ab ac) 2
(aa ab ac) 2
(aa ab ac) 2
aa ab ac 4
bb cc 3
$.function wm [args ...] .{argfunction} {
   whence .mapped_argfunction {.argfunction}
   .nop $args
   se {.argfunction}
   .echo $nl}
$wm () {.echo \\\ \ \\\ \\\\ \ \\|\\\ \  \  \\ \( \) \\\)}
{.echo (\\  \\ \\\\) ( \\|\\  ) ( ) \\ \( \) \\)}
\  \ \\  \|\     \ ( ) \)
$wm () {.echo (\\  \\ \\\\) ( \\|\\  ) ( ) (\\) (\() (\)) (\\\))}
{.echo (\\  \\ \\\\) ( \\|\\  ) ( ) \\ \( \) \\)}
\  \ \\  \|\     \ ( ) \)
$wm () {.echo a\\bc\\d\\\\e fg\\|\\hij klm \\ \) \( \\\(}
{.echo a\\bc\\d\\\\e fg\\|\\hij klm \\ \) \( \\(}
a\bc\d\\e fg\|\hij klm \ ) ( \(
$wm () {
.echo \( \) \\( \\) \\\( \\\) \\\\( \\\\) \\\\\( \\\\\)}
{
.echo \( \) \\( \\) \\( \\) \\\\( \\\\) \\\\( \\\\)}
( ) \( \) \( \) \\( \\) \\( \\)
$wm () {
.echo \) \( \\) \\( \\\) \\\( \\\\) \\\\( \\\\\) \\\\\(}
{
.echo \) \( \\) \\( \\) \\( \\\\) \\\\( \\\\) \\\\(}
) ( \) \( \) \( \\) \\( \\) \\(
$wm () {.echo () xx(yy \$ \@ \$$ \@@ }
{.echo () xx(yy \$ \@ $$ @@}
 xx(yy $ @ $$ @@
$wm () {.echo (  ) (	) (
)}
{.echo (  ) (	) (
)}
   	 

$whence .mapped_argfunction {.nop 1}
{.nop 1}
$whence .mapped_argfunction {@a @$a @$1 @$* @$*2}
{@a @$a @$1 @$*1 @$*2}
$whence .mapped_argfunction {>dummy_file}
{>dummy_file}
$
$# .waiting_for_shell .waiting_for_user .waiting_for_binary
$# actual use of these builtins is in test_inconsistent.sh
$.waiting_for_shell j
unacceptable arguments: for prototype ,
 found (j) excess
( call) stack: .waiting_for_shell
$.waiting_for_shell {excess argfunc}
.waiting_for_shell does not accept an argfunction with call stack: .waiting_for_shell
$# .waiting_for_shell
$.waiting_for_user j
unacceptable arguments: for prototype ,
 found (j) excess
( call) stack: .waiting_for_user
$.waiting_for_user {excess argfunc}
.waiting_for_user does not accept an argfunction with call stack: .waiting_for_user
$# .waiting_for_user
$.waiting_for_binary j
unacceptable arguments: for prototype ,
 found (j) excess
( call) stack: .waiting_for_binary
$.waiting_for_binary {excess argfunc}
.waiting_for_binary does not accept an argfunction with call stack: .waiting_for_binary
$# .waiting_for_binary
$
$# .last_exception
$.last_exception .last_exception
.function_not_found /bn/echo .last_exception /bn/echo
$.last_exception .nop

$.last_exception
unacceptable arguments: for prototype -- command,
 needed (command),
( call) stack: .last_exception
$.last_exception .try_catch_recursive {excess argfunc}
.last_exception does not accept an argfunction with call stack: .last_exception
$.last_exception .last_exception
.excess_argfunction .last_exception .try_catch_recursive {excess argfunc}
$.last_exception function_that_does_not_exist
function_that_does_not_exist : command not found ( function_that_does_not_exist .last_exception )
$.last_exception .try_catch_recursive
.not_a_number A .test_less .try_catch_recursive(body) .try_catch_recursive .try_catch_recursive(body) .try_catch_recursive .not_a_number {
  .try_catch_recursive .not_a_number {.test_less 0 A}}; .excessive_exceptions_in_catch 0 .try_catch_recursive .try_catch_recursive(body) .try_catch_recursive .not_a_number {
  .try_catch_recursive .not_a_number {.test_less 0 A}}
$.last_exception .last_execution_time

$.last_exception /bin/which
/bin/which : command not found ( /bin/which .last_exception )
$.last_exception /bin/cat
.file_open_failure non_existent_file /bin/cat <non_existent_file
$.last_exception /bin/echo

$.last_exception e

$.last_exception test_var_greater
.false 0 -gt 0 .test_greater test_var_greater n 0
$
$# .usleep .execution_count .last_execution_time .total_execution_time
$.usleep_overhead excess
unacceptable arguments: for prototype ,
 found (excess) excess
( call) stack: .usleep_overhead
$.usleep_overhead {excess argfunc}
.usleep_overhead does not accept an argfunction with call stack: .usleep_overhead
$.usleep_overhead
() is not a number
call stack: .usleep_overhead
$.usleep
unacceptable arguments: for prototype -- milliseconds,
 needed (milliseconds),
( call) stack: .usleep
$.usleep 800 {excess argfunc}
.usleep does not accept an argfunction with call stack: .usleep
$.usleep -6
value -6 is out of usable numeric range
call stack .usleep
$.usleep 5i
5i is not a number
call stack: .usleep
$.usleep 800
$# .usleep_overhead
$.execution_count
unacceptable arguments: for prototype -- command,
 needed (command),
( call) stack: .execution_count
$.execution_count j
j : command not found ( j .execution_count )
$.scope () {
  .execution_count .mapped_argfunction {echo not tracked}; .echo $nl}
.execution_count does not accept an argfunction with call stack: .execution_count .scope
$.scope () {
  .execution_count .usleep; .echo $nl}
5
$.last_execution_time
unacceptable arguments: for prototype -- command,
 needed (command),
( call) stack: .last_execution_time
$.last_execution_time j
j : command not found ( j .last_execution_time )
$.scope () {
  .last_execution_time .mapped_argfunction {echo not tracked}; .echo $nl}
.last_execution_time does not accept an argfunction with call stack: .last_execution_time .scope
$# .last_execution_time .usleep
$.total_execution_time
unacceptable arguments: for prototype -- command,
 needed (command),
( call) stack: .total_execution_time
$.scope () {
  .total_execution_time .mapped_argfunction {echo not tracked}; .echo $nl}
.total_execution_time does not accept an argfunction with call stack: .total_execution_time .scope
$.total_execution_time j
j : command not found ( j .total_execution_time )
$# .total_execution_time .usleep
$
$# .which_path
$echo ${.which_path cat}
unacceptable arguments: for prototype -- command PATH,
 assigned command=cat ,
 but needed (PATH),
( call) stack: (.which_path .interpret)
substitution (${.which_path cat}) failed
$echo ${.which_path cat /bin {excess argfunc}}
.which_path does not accept an argfunction with call stack: .which_path .interpret
substitution (${.which_path cat /bin {excess argfunc}}) failed
$echo ${.which_path cat \ }
cat : binary not found in ( )
call stack: .which_path .interpret
substitution (${.which_path cat ( )}) failed
$echo ${.which_path does<not>exist /bin:/usr/bin}
does<not>exist : binary not found in /bin:/usr/bin
call stack: .which_path .interpret
substitution (${.which_path does<not>exist /bin:/usr/bin}) failed
$echo ${.which_path cat :/bin:/usr/bin}
/bin/cat
$echo ${.which_path cat /usr/bin/:/bin/:}
/bin/cat
$echo ${.which_path /bin/cat /usr/bin/:/bin/:}
/bin/cat
$echo ${.which_path rwsh /usr/bin:/bin}
/bin/rwsh
$echo ${.which_path rwsh .:/usr/bin:/bin}
./rwsh
$echo ${.which_path rwsh /usr/bin:/bin:.}
/bin/rwsh
$echo ${.which_path ./rwsh /usr/bin:/bin}
./rwsh : binary not found in /usr/bin:/bin
call stack: .which_path .interpret
substitution (${.which_path ./rwsh /usr/bin:/bin}) failed
$echo ${.which_path ./rwsh /bin:.}
./rwsh
$echo ${.which_path ../bin/rwsh /usr/bin:/bin}
../bin/rwsh : binary not found in /usr/bin:/bin
call stack: .which_path .interpret
substitution (${.which_path ../bin/rwsh /usr/bin:/bin}) failed
$echo ${.which_path rwsh :/usr/bin::/usr/bin:}
rwsh : binary not found in :/usr/bin::/usr/bin:
call stack: .which_path .interpret
substitution (${.which_path rwsh :/usr/bin::/usr/bin:}) failed
$echo ${.which_path rwsh /usr/bin:.}
./rwsh
$
$# .while
$.while {e ARGS}
unacceptable arguments: for prototype -- command ... .{argfunction},
 needed (command),
( call) stack: .while
$.while var_less A 4
.while requires an argfunction
$.scope 0 A {.while var_less A 4 {echo printed; .throw .break; echo skipped}}
printed
$.scope 0 A {.while var_less A 4 {echo printed; .set A 4}}
printed
$.scope 4 A {.while var_less A 4 {echo skipped}}
$.while .nop {.throw echo exception within while}
exception within while .throw .mapped_argfunction .while
$.while silent_throw within condition {e body skipped}
exception within condition .throw .collect_errors_only silent_throw .while
$.while .throw .false because {echo body skipped}
$.scope 0 A {.while .throw .break {echo condition cannot break}}
.break thrown outside of control flow body
call stack: .throw .while .scope
A was unused with call stack .scope
$.scope 0 A {.while .throw .continue {echo condition cannot continue}}
.continue thrown outside of control flow body
call stack: .throw .while .scope
A was unused with call stack .scope
$.scope 0 A {.while var_less A 4 {echo body can break; .throw .break}}
body can break
$.scope 0 A {.while var_less A 4 {echoe in .while argfunction $A $nl; .var_add A 1}}
in .while argfunction 0 
in .while argfunction 1 
in .while argfunction 2 
in .while argfunction 3 
$.scope 0 A {.while var_in A 1 2 {echo A is $A; .var_add A 1}}
$.scope 0 A {do_while var_in A 1 2 {echo A is $A; .var_add A 1}}
A is 0
A is 1
A is 2
$.scope 1 A {.while var_in A 1 2 {echo A is $A; .var_add A 1}}
A is 1
A is 2
$.scope 1 A {while_and_one_more var_in A 1 2 {echo A is $A; .var_add A 1}}
A is 1
A is 2
A is 3
$fn throw_the_kitchen_sink cmd ... {
  $cmd$ {
    echo early in argfunction $A
    .var_add A 1
    if_only .test_less $A 3 {.throw .continue}
    .collect_errors_except .nop {
      .throw .continue
      .throw .break
      .throw .continue}
    echo late in .while argfunction $A}
  echo after $cmd$0
  .throw .break
  echo do not echo after a .break thrown outside control flow}
$.scope 0 A {throw_the_kitchen_sink .while var_less A 4}
early in argfunction 0
early in argfunction 1
early in argfunction 2
after .while
.break thrown outside of control flow body
call stack: .throw throw_the_kitchen_sink .scope
$.scope 0 A {throw_the_kitchen_sink do_while var_less A 4}
early in argfunction 0
.continue thrown outside of control flow body
call stack: .throw .mapped_argfunction .if if_only .try_catch_recursive(body)
early in argfunction 1
early in argfunction 2
after do_while
.break thrown outside of control flow body
call stack: .throw throw_the_kitchen_sink .scope
$.scope 3 A {throw_the_kitchen_sink do_while var_less A 6}
early in argfunction 3
.continue thrown outside of control flow body
call stack: .throw .collect_errors_except .try_catch_recursive(body)
.continue thrown outside of control flow body
call stack: .throw .collect_errors_except .try_catch_recursive(body)
.break thrown outside of control flow body
call stack: .throw .collect_errors_except .try_catch_recursive(body) .try_catch_recursive .try_catch_recursive(body)
after do_while
.break thrown outside of control flow body
call stack: .throw throw_the_kitchen_sink .scope
$.scope 0 A {throw_the_kitchen_sink while_and_one_more var_less A 4}
early in argfunction 0
early in argfunction 1
early in argfunction 2
early in argfunction 3
.continue thrown outside of control flow body
call stack: .throw .collect_errors_except .try_catch_recursive(body)
.continue thrown outside of control flow body
call stack: .throw .collect_errors_except .try_catch_recursive(body)
.break thrown outside of control flow body
call stack: .throw .collect_errors_except .try_catch_recursive(body) .try_catch_recursive .try_catch_recursive(body)
after while_and_one_more
.break thrown outside of control flow body
call stack: .throw throw_the_kitchen_sink .scope
$.function tf N {.test_less $A $N}
$.scope 0 A {.while tf 4 {
  .if .test_number_equal 0 $A {.set A 1}
  .else {.function tf N {.throw .false $N}}
  echo in overwriting argfunction}}
in overwriting argfunction
in overwriting argfunction
$.set_max_nesting 30
$fn IJK outer middle inner {
  .scope 0 I {
    .local sum 0
    .nop $sum
    $outer var_less I 5 {
      .var_add I 1
      .scope 0 J {
        $middle var_less J 2 {
          .var_add J 1
          if_only_not .test_string_equal ${e $I $J} (1 1) {.combine $nl}
          .combine $I . $J :
          .scope 0 K {
            $inner var_less K 30 {
              .var_add K 1
              if_only .test_less 1 $K {.echo ,}
              .echo $K
              .set sum ${+ $I + $J $K}
              .if .test_less 5 $sum$ {.throw outer_break}
              .else_if .test_less 4 $sum$ {.throw outer_continue}
              .else {}}}}}}}
  .echo $nl}
$IJK      .while      .while      .while
1.1:1,2,3Exception for failed handler. Original exception with call stack:
outer_continue .throw .mapped_argfunction .else_if .mapped_argfunction .while .scope .mapped_argfunction .while .scope .mapped_argfunction .while .scope IJK
.continue thrown outside of control flow body
call stack: .throw .mapped_argfunction .else_if .mapped_argfunction .while .scope .mapped_argfunction .while .scope .mapped_argfunction .while .scope IJK .replace_exception outer_continue
$IJK outer_while      .while      .while
1.1:1,2,3
2.1:1,2
3.1:1
4.1:1
$IJK      .while outer_while      .while
1.1:1,2,3
1.2:1,2
2.1:1,2
2.2:1
3.1:1
3.2:1
4.1:1
5.1:1
$IJK      .while      .while outer_while
1.1:1,2,3,4
1.2:1,2,3
2.1:1,2,3
2.2:1,2
3.1:1,2
3.2:1
4.1:1
4.2:1
5.1:1
5.2:1
$IJK outer_while outer_while outer_while
1.1:1,2,3,4
1.2:1,2,3
2.1:1,2,3
2.2:1,2
3.1:1,2
3.2:1
4.1:1
4.2:1
5.1:1
5.2:1
$.set_max_nesting 20
$
$fn var_op_val_echo -- var_val op val {
  .scope $var_val (-- var) {.collect_errors_except .nop {
    $op var $val
    echo $var}}}
$
$# .var_add
$.var_add
unacceptable arguments: for prototype -- var value,
 needed (var value),
( call) stack: .var_add
$.var_add A 1 2 {excess argfunc}
unacceptable arguments: for prototype -- var value,
 assigned value=1 var=A ,
 but found (2) excess
( call) stack: .var_add
.var_add does not accept an argfunction with call stack: .var_add
$.var_add B B
B was not declared
call stack: .var_add
$.scope [undefined] {.var_add undefined 1}
optional variable undefined was not defined
call stack: .var_add .scope
undefined was not checked with call stack .scope
$var_op_val_echo A .var_add 42C
A
A is not a number
call stack: .var_add .collect_errors_except .scope var_op_val_echo
42C is not a number
call stack: .var_add .collect_errors_except .scope var_op_val_echo
$var_op_val_echo NaN .var_add nan
NaN
NaN is not a number
call stack: .var_add .collect_errors_except .scope var_op_val_echo
nan is not a number
call stack: .var_add .collect_errors_except .scope var_op_val_echo
$var_op_val_echo 3000000000 .var_add 2
3000000000
2 is too small relative to 3000000000 to modify its value
call stack: .var_add .collect_errors_except .scope var_op_val_echo
$var_op_val_echo 3000000000 .var_add 0
3e+09
$var_op_val_echo 1e309 .var_add -1e309
1e309
value 1e309 is out of usable numeric range
call stack .var_add .collect_errors_except .scope var_op_val_echo
value -1e309 is out of usable numeric range
call stack .var_add .collect_errors_except .scope var_op_val_echo
$var_op_val_echo -1e308 .var_add -1e308
-1e308
result of .var_add with arguments -1e308 and -1e308 is out of range
call stack: .var_add .collect_errors_except .scope var_op_val_echo
$var_op_val_echo -1e308 .var_add 1e308
0
$var_op_val_echo 0 .var_add 1e308
1e+308
$var_op_val_echo 1e+308 .var_add 1e308
1e+308
result of .var_add with arguments 1e+308 and 1e308 is out of range
call stack: .var_add .collect_errors_except .scope var_op_val_echo
$var_op_val_echo 1e+308 .var_add -1e308
0
$var_op_val_echo 0 .var_add \
0
() is not a number
call stack: .var_add .collect_errors_except .scope var_op_val_echo
$
$# .var_divide
$.var_divide A
unacceptable arguments: for prototype -- var value,
 assigned var=A ,
 but needed (value),
( call) stack: .var_divide
$.var_divide A 1 2 {excess argfunc}
unacceptable arguments: for prototype -- var value,
 assigned value=1 var=A ,
 but found (2) excess
( call) stack: .var_divide
.var_divide does not accept an argfunction with call stack: .var_divide
$.var_divide B B
B was not declared
call stack: .var_divide
$.scope [undefined] {.var_divide undefined 1}
optional variable undefined was not defined
call stack: .var_divide .scope
undefined was not checked with call stack .scope
$var_op_val_echo A .var_divide 42C
A
A is not a number
call stack: .var_divide .collect_errors_except .scope var_op_val_echo
42C is not a number
call stack: .var_divide .collect_errors_except .scope var_op_val_echo
$var_op_val_echo NaN .var_divide nan
NaN
NaN is not a number
call stack: .var_divide .collect_errors_except .scope var_op_val_echo
nan is not a number
call stack: .var_divide .collect_errors_except .scope var_op_val_echo
$var_op_val_echo 1e3000000000 .var_divide 2e3000000000
1e3000000000
value 1e3000000000 is out of usable numeric range
call stack .var_divide .collect_errors_except .scope var_op_val_echo
value 2e3000000000 is out of usable numeric range
call stack .var_divide .collect_errors_except .scope var_op_val_echo
$var_op_val_echo 1e3000000000 .var_divide 0
1e3000000000
value 1e3000000000 is out of usable numeric range
call stack .var_divide .collect_errors_except .scope var_op_val_echo
attempt to divide 1e3000000000 by 0 with call stack: .var_divide .collect_errors_except .scope var_op_val_echo
$var_op_val_echo 16.8 .var_divide 4.2
4
$var_op_val_echo 1.8e-20 .var_divide 1e308
1.8e-20
result of .var_divide with arguments 1.8e-20 and 1e308 is out of range
call stack: .var_divide .collect_errors_except .scope var_op_val_echo
$var_op_val_echo 0 .var_divide 3
0
$var_op_val_echo 3 .var_divide 1
3
$var_op_val_echo 9.9999995e-1 .var_divide 1.0000001
9.9999995e-1
1.0000001 is too small relative to 9.9999995e-1 to modify its value
call stack: .var_divide .collect_errors_except .scope var_op_val_echo
$
$# .var_modulo
$.var_modulo A
unacceptable arguments: for prototype -- var value,
 assigned var=A ,
 but needed (value),
( call) stack: .var_modulo
$.var_modulo A 1 2 {excess argfunc}
unacceptable arguments: for prototype -- var value,
 assigned value=1 var=A ,
 but found (2) excess
( call) stack: .var_modulo
.var_modulo does not accept an argfunction with call stack: .var_modulo
$.var_modulo B B
B was not declared
call stack: .var_modulo
$.scope [undefined] {.var_modulo undefined 1}
optional variable undefined was not defined
call stack: .var_modulo .scope
undefined was not checked with call stack .scope
$var_op_val_echo A .var_modulo 42C
A
A is not a number
call stack: .var_modulo .collect_errors_except .scope var_op_val_echo
42C is not a number
call stack: .var_modulo .collect_errors_except .scope var_op_val_echo
$var_op_val_echo NaN .var_modulo nan
NaN
NaN is not a number
call stack: .var_modulo .collect_errors_except .scope var_op_val_echo
nan is not a number
call stack: .var_modulo .collect_errors_except .scope var_op_val_echo
$var_op_val_echo 1e15 .var_modulo 0
1e15
value 1e15 is out of usable numeric range
call stack .var_modulo .collect_errors_except .scope var_op_val_echo
attempt to divide 1e15 by 0 with call stack: .var_modulo .collect_errors_except .scope var_op_val_echo
$var_op_val_echo 16.8 .var_modulo 4.2
16.8
16.8 is a number but not an integer
call stack: .var_modulo .collect_errors_except .scope var_op_val_echo
4.2 is a number but not an integer
call stack: .var_modulo .collect_errors_except .scope var_op_val_echo
$var_op_val_echo 1.8e30 .var_modulo 1.000000001
1.8e30
1.8e30 is a number but not an integer
call stack: .var_modulo .collect_errors_except .scope var_op_val_echo
1.000000001 is a number but not an integer
call stack: .var_modulo .collect_errors_except .scope var_op_val_echo
$var_op_val_echo 0 .var_modulo 3
0
$var_op_val_echo 3 .var_modulo 1
0
$var_op_val_echo 257 .var_modulo 8
1
$var_op_val_echo 2.55e2 .var_modulo 8.000
7
$var_op_val_echo -5 .var_modulo 3
-2
$var_op_val_echo 6 .var_modulo -4
2
$
$# .var_multiply
$.var_multiply A
unacceptable arguments: for prototype -- var value,
 assigned var=A ,
 but needed (value),
( call) stack: .var_multiply
$.var_multiply A 1 2 {excess argfunc}
unacceptable arguments: for prototype -- var value,
 assigned value=1 var=A ,
 but found (2) excess
( call) stack: .var_multiply
.var_multiply does not accept an argfunction with call stack: .var_multiply
$.var_multiply B B
B was not declared
call stack: .var_multiply
$.scope [undefined] {.var_multiply undefined 1}
optional variable undefined was not defined
call stack: .var_multiply .scope
undefined was not checked with call stack .scope
$var_op_val_echo A .var_multiply 42C
A
A is not a number
call stack: .var_multiply .collect_errors_except .scope var_op_val_echo
42C is not a number
call stack: .var_multiply .collect_errors_except .scope var_op_val_echo
$var_op_val_echo NaN .var_multiply nan
NaN
NaN is not a number
call stack: .var_multiply .collect_errors_except .scope var_op_val_echo
nan is not a number
call stack: .var_multiply .collect_errors_except .scope var_op_val_echo
$var_op_val_echo 1e3000000000 .var_multiply 2e3000000000
1e3000000000
value 1e3000000000 is out of usable numeric range
call stack .var_multiply .collect_errors_except .scope var_op_val_echo
value 2e3000000000 is out of usable numeric range
call stack .var_multiply .collect_errors_except .scope var_op_val_echo
$var_op_val_echo 1.6 .var_multiply 1.6
2.56
$var_op_val_echo 1.8e-20 .var_multiply 1e308
1.8e+288
$var_op_val_echo -1e308 .var_multiply -1e308
-1e308
result of .var_multiply with arguments -1e308 and -1e308 is out of range
call stack: .var_multiply .collect_errors_except .scope var_op_val_echo
$var_op_val_echo 1e308 .var_multiply -1e308
1e308
result of .var_multiply with arguments 1e308 and -1e308 is out of range
call stack: .var_multiply .collect_errors_except .scope var_op_val_echo
$var_op_val_echo 0.00 .var_multiply 1e308
0
$var_op_val_echo 0 .var_multiply 3
0
$var_op_val_echo 3 .var_multiply 1
3
$var_op_val_echo 9.9999995e-1 .var_multiply 9.9999995e-1
9.9999995e-1
9.9999995e-1 is too small relative to 9.9999995e-1 to modify its value
call stack: .var_multiply .collect_errors_except .scope var_op_val_echo
$
$# .var_subtract
$.var_subtract
unacceptable arguments: for prototype -- var value,
 needed (var value),
( call) stack: .var_subtract
$.var_subtract A 1 2 {excess argfunc}
unacceptable arguments: for prototype -- var value,
 assigned value=1 var=A ,
 but found (2) excess
( call) stack: .var_subtract
.var_subtract does not accept an argfunction with call stack: .var_subtract
$.var_subtract B B
B was not declared
call stack: .var_subtract
$.scope [undefined] {.var_subtract undefined 1}
optional variable undefined was not defined
call stack: .var_subtract .scope
undefined was not checked with call stack .scope
$var_op_val_echo A .var_subtract 42C
A
A is not a number
call stack: .var_subtract .collect_errors_except .scope var_op_val_echo
42C is not a number
call stack: .var_subtract .collect_errors_except .scope var_op_val_echo
$var_op_val_echo NaN .var_subtract nan
NaN
NaN is not a number
call stack: .var_subtract .collect_errors_except .scope var_op_val_echo
nan is not a number
call stack: .var_subtract .collect_errors_except .scope var_op_val_echo
$var_op_val_echo 3000000000 .var_subtract 2
3000000000
2 is too small relative to 3000000000 to modify its value
call stack: .var_subtract .collect_errors_except .scope var_op_val_echo
$var_op_val_echo 3000000000 .var_subtract 0
3e+09
$var_op_val_echo 1e308 .var_subtract -1e308
1e308
result of .var_subtract with arguments 1e308 and -1e308 is out of range
call stack: .var_subtract .collect_errors_except .scope var_op_val_echo
$var_op_val_echo -2147483648 .var_subtract 3000000000
-5.14748e+09
$var_op_val_echo -5.14748e+09 .var_subtract -2147483648
-3e+09
$var_op_val_echo -3e+09 .var_subtract 2147483647
-5.14748e+09
$var_op_val_echo -5.14748e+09 .var_subtract 2147483647
-7.29496e+09
$var_op_val_echo -7.29496e+09 .var_subtract 2147483647
-9.44244e+09
$var_op_val_echo -9.44244e+09 .var_subtract -2147483648
-7.29496e+09
$var_op_val_echo -7294960000 .var_subtract \
-7294960000
() is not a number
call stack: .var_subtract .collect_errors_except .scope var_op_val_echo
$
$# .version .version_compatible
$.version 1.0
unacceptable arguments: for prototype ,
 found (1.0) excess
( call) stack: .version
$.version {excess argfunc}
.version does not accept an argfunction with call stack: .version
$.version_compatible
unacceptable arguments: for prototype -- candidate_version,
 needed (candidate_version),
( call) stack: .version_compatible
$.version_compatible 1.0 1.0
unacceptable arguments: for prototype -- candidate_version,
 assigned candidate_version=1.0 ,
 but found (1.0) excess
( call) stack: .version_compatible
$.version_compatible 1.0 {excess argfunc}
.version_compatible does not accept an argfunction with call stack: .version_compatible
$echo ${.version}
0.3+
$.version_compatible 1.0
this shell is not compatible with requested version 1.0
call stack: .version_compatible
$.version_compatible 0.3+
$
$# internal functions
$# .after_command .raw_command .prompt
$# all of these are used as part of the test itself, though no longer in a
$# significant way.
$whence .after_command
.function .after_command -- args ... [.{argfunction}] {.nop $args}
$whence .prompt
.function .prompt  {.echo \$}
$whence .raw_command
.function .raw_command -- cmd {.echo $cmd; .echo (
)}
$
$# .before_command
$fn .before_command args ... {.echo $0 $args$; .echo $nl}
$.rm_executable .before_command
.before_command .rm_executable .before_command
$
$# .double_redirection
$# se {e hi #>dummy_file >dummy_file}
$# se {e hi >dummy_file}
$# se {e &{e hi #>dummy_file}}
$
$# .function_not_found
$se {not_a_thing; e should not be printed}
not_a_thing : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction .scope se
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction .scope se
not_a_thing : command not found ( not_a_thing .scope se )
$.rm_executable .function_not_found
$.whence_function .function_not_found
Exception for failed handler. Original exception with call stack:
.function_not_found .function_not_found .whence_function
Exception for failed handler. Original exception with call stack:
.function_not_found .function_not_found .function_not_found .whence_function
.function_not_found : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction
$whence not_a_thing
not_a_thing : command not found ( not_a_thing .whence_function .try_catch_recursive(body) )
$not_a_thing
not_a_thing : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction
not_a_thing : command not found ( not_a_thing )
$.whence_function .function_not_found
.function .function_not_found cmd [args ...] {.echo $cmd (: command not found) \( $cmd $args$ \); .echo (
)}
$
$# .help .internal_error
$.help
this is the default configuration for rwsh (or something copied from it), documentation should be available at rwsh.sf.net or rwsh.org
$.internal_error techincally this is untestable
internal error: techincally this is untestable
$
$# .mapped_argfunction .argfunction .escaped_argfunction
$.mapped_argfunction 1 2 3 {echo a $* a}
a 1 2 3 a
$.mapped_argfunction
.mapped_argfunction : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction
.mapped_argfunction : command not found ( .mapped_argfunction )
$fn g .{argfunction} {.nop
     .whence_function .argfunction {.argfunction}
     .whence_function .argfunction {.escaped_argfunction}}
$g {.whence_function .argfunction {}
     .whence_function .argfunction {.argfunction}
     .whence_function .argfunction {.escaped_argfunction}}
{.whence_function .argfunction {}
     .whence_function .argfunction {.argfunction}
     .whence_function .argfunction {.escaped_argfunction}}
{.argfunction}
$g {}
{}
{.argfunction}
$
$# .throw
$.throw
unacceptable arguments: for prototype -- exception ... [.{argfunction}],
 needed (exception),
( call) stack: .throw
$.throw .nop
$.throw .not_a_number 7
7 is not a number
call stack: .throw
$se {if_only .test_is_number 0 {
  .throw sa {echo even from $args$ 7 is a number}}}
even from .throw .mapped_argfunction .if if_only .scope se 7 is a number
$.throw .throw echo innocently
Exception for failed handler. Original exception with call stack:
.throw echo innocently .throw
innocently .throw .throw
$.throw .throw exception_bomb
Exception for failed handler. Original exception with call stack:
.throw exception_bomb .throw
Exception for failed handler. Original exception with call stack:
exception_bomb .throw .throw
exception_bomb : command not found ( exception_bomb .throw .throw )
exception_bomb : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction
$se {.try_catch_recursive echo {
      echo first
      .throw echo failing successfully
      echo second}
   echo third}
first
failing successfully .throw .try_catch_recursive(body)
third
$fn tribble [args ...] {
  .replace_exception tribble $args$
  .replace_exception tribble $args$
  echo the multiplication has begun $#}
$.try_catch_recursive tribble {.throw tribble}
the multiplication has begun 3
the multiplication has begun 5
the multiplication has begun 5
the multiplication has begun 8
Exception for failed handler. Original exception with call stack:
tribble .throw .try_catch_recursive(body) .replace_exception tribble .replace_exception tribble .try_catch_recursive
Exception for failed handler. Original exception with call stack:
tribble .throw .try_catch_recursive(body) .replace_exception tribble .replace_exception tribble .try_catch_recursive .replace_exception tribble
Exception for failed handler. Original exception with call stack:
tribble .throw .try_catch_recursive(body) .replace_exception tribble .replace_exception tribble .try_catch_recursive
Exception for failed handler. Original exception with call stack:
tribble .throw .try_catch_recursive(body) .replace_exception tribble .replace_exception tribble .try_catch_recursive
Exception for failed handler. Original exception with call stack:
tribble .throw .try_catch_recursive(body) .replace_exception tribble .replace_exception tribble .try_catch_recursive
exceeded maximum number of exceptions ( 5 ) in try_catch.
call stack: .try_catch_recursive
Exception for failed handler. Original exception with call stack:
tribble .throw .try_catch_recursive(body) .replace_exception tribble .replace_exception tribble .try_catch_recursive .replace_exception tribble
$.throw tribble
the multiplication has begun 2
Exception for failed handler. Original exception with call stack:
tribble .throw
Exception for failed handler. Original exception with call stack:
tribble .throw .replace_exception tribble
Exception for failed handler. Original exception with call stack:
tribble .throw .replace_exception tribble
$fn neverending [args ...] {.replace_exception neverending $args$}
$.throw neverending
Exception for failed handler. Original exception with call stack:
neverending .throw
Exception for failed handler. Original exception with call stack:
neverending .throw .replace_exception neverending
$.try_catch_recursive neverending {.throw neverending}
Exception for failed handler. Original exception with call stack:
neverending .throw .try_catch_recursive(body) .replace_exception neverending .replace_exception neverending .replace_exception neverending .replace_exception neverending .replace_exception neverending .try_catch_recursive
Exception for failed handler. Original exception with call stack:
neverending .throw .try_catch_recursive(body) .replace_exception neverending .replace_exception neverending .replace_exception neverending .replace_exception neverending .replace_exception neverending .try_catch_recursive .replace_exception neverending
exceeded maximum number of exceptions ( 5 ) in try_catch.
call stack: .try_catch_recursive
$fn sneaky [args ...] {
  .try_catch_recursive sneaky {.replace_exception sneaky $args$}}
$.try_catch_recursive sneaky {.throw sneaky}
Exception for failed handler. Original exception with call stack:
sneaky .throw .try_catch_recursive(body) .replace_exception .try_catch_recursive(body) .try_catch_recursive sneaky .replace_exception .try_catch_recursive(body) .try_catch_recursive sneaky .replace_exception .try_catch_recursive(body) .try_catch_recursive sneaky .replace_exception .try_catch_recursive(body) .try_catch_recursive sneaky .replace_exception .try_catch_recursive(body) .try_catch_recursive sneaky .try_catch_recursive
Exception for failed handler. Original exception with call stack:
sneaky .throw .try_catch_recursive(body) .replace_exception .try_catch_recursive(body) .try_catch_recursive sneaky .replace_exception .try_catch_recursive(body) .try_catch_recursive sneaky .replace_exception .try_catch_recursive(body) .try_catch_recursive sneaky .replace_exception .try_catch_recursive(body) .try_catch_recursive sneaky .replace_exception .try_catch_recursive(body) .try_catch_recursive sneaky .try_catch_recursive .replace_exception .try_catch_recursive(body) .try_catch_recursive sneaky
exceeded maximum number of exceptions ( 5 ) in try_catch.
call stack: .try_catch_recursive
$
$# .run_logic
$fn .run_logic flag cmd ... {
  .if .test_number_equal 0 $flag {.nop}
  .else_if $cmd$ {.nop}
  .else {.nop}}
$0 echo don't print nuthin'
$1 echo do print
do print
$1 .rm_executable .run_logic
$1 e executable not found
1 : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction
1 : command not found ( 1 e executable not found )
$
$# .vars
$.vars
FIGNORE
$
$## recursive function testing
$fn -n -- [args ...] {$args$; echo after $args$}
$-n -n -n -n
after
after -n
after -n -n
after -n -n -n
$-n -n -n echo -n
-n
after echo -n
after -n echo -n
after -n -n echo -n
$fn -n [-x] ignored -- [args ...] {
  echo before $args flags $-x$
  $args$
  .nop $ignored}
$-n -x -x a -n -x a -n a -n -x a
before (-n -x a -n a -n -x a) flags -x -x
before (-n a -n -x a) flags -x
before (-n -x a) flags
-x was unused with call stack -n -n -n -n
-* was unused with call stack -n -n -n -n
ignored was unused with call stack -n -n -n -n
args was not checked with call stack -n -n -n -n
optional variable args was not defined
call stack: -n -n -n -n
ignored was unused with call stack -n -n -n
ignored was unused with call stack -n -n
ignored was unused with call stack -n
$-n -x -x a -n -x a -n a echo -n -x a
before (-n -x a -n a echo -n -x a) flags -x -x
before (-n a echo -n -x a) flags -x
before (echo -n -x a) flags
-n -x a
$single .nop
unacceptable arguments: for prototype result,
 needed (result),
( call) stack: (.scope single)
$single - - 40 10 - 7 2 1
unacceptable arguments: for prototype result,
 assigned result=25 ,
 but found (1) excess
( call) stack: (.scope single)
$single - 40 10
30
$single * 2 - 40 10
60
$single - 40 - 10 2
32
$single / - + 40 10 2 2
24
$single - 40 - * 2 5 - 7 2
35
$.function excessive-commentary arg {#! shebang
  $arg first comment before a blank line

  echo not a $arg; .nop second; echo either}
$excessive-commentary #
not a #
either
$echo-comments excessive-commentary #
#! shebang
# first comment before a blank line
.nop second
$
$# ln
$ln -s test_files/fibb
assertion ( -e test_files/fibb) failed
call stack .test_file_exists .for(body) .for .mapped_argfunction
.fork returned 255 : call stack .fork ln
$readlink ixxx
added readlink to executable map in test suite
/bin/readlink returned 1 : call stack /bin/readlink readlink
$ln -s test_files/ixxx
$readlink ixxx
test_files/ixxx
this readlink function has been brought to you by .autofunction
$/bin/rm ixxx
$ln -s -t test_files/ rwshlib.h plumber.h builtin.h
assertion ( -e rwshlib.h) failed
call stack .test_file_exists .for(body) .for .mapped_argfunction
.fork returned 255 : call stack .fork ln
$readlink test_files/rwshlib.h test_files/plumber.h test_files/builtin.h
/bin/readlink returned 1 : call stack /bin/readlink readlink
$ln -s -t test_files/ ../rwshlib.h ../plumber.h ../builtin.h
$readlink test_files/rwshlib.h test_files/plumber.h test_files/builtin.h
../rwshlib.h
../plumber.h
../builtin.h
this readlink function has been brought to you by .autofunction
$/bin/rm test_files/rwshlib.h test_files/plumber.h test_files/builtin.h
$
$## environment testing i don't want to mess up everything else
$# check for extraneous variables and that export_env doesn't bless
$.scope M val (N necessary) {.nop $necessary
  printenv -- .var_exists -* ? A C PATH SHELL TESTABILITY args N necessary nl}
added printenv to executable map in test suite
must be requested to be checked
-to
/bin/readlink returned 1
x
(external) () ( ) internal(parenthesis)
/bin:/usr/bin:.
/bin/rwsh
an=external var(iable)
-- .var_exists -* ? A C PATH SHELL TESTABILITY args N necessary nl
M
val


this printenv function has been brought to you by .autofunction
N was unused with call stack .scope
$
$# .list_environment
$.set SHELL unmodified
$.list_environment x
unacceptable arguments: for prototype ,
 found (x) excess
( call) stack: .list_environment
$.list_environment {excess argfunc}
.list_environment does not accept an argfunction with call stack: .list_environment
$.for ${.list_environment}$ (-- var val) {
  .if .test_in $var ? FIGNORE SHELL {echo $var : $$var to $val}
  .else {.global $var $val}}
FIGNORE : *de* to ()
SHELL : unmodified to /bin/rwsh
$.combine $TESTABILITY $nl
an=external var(iable)
$echo $SHELL
unmodified
$.unset TESTABILITY
$.for ${.list_environment}$ (-- j ...) {
  .scope $j$ (-- var val) {setf $var $val; .nop $$var}}
$.combine $TESTABILITY $nl
an=external var(iable)
$echo $SHELL
/bin/rwsh
$printenv -- -* .var_exists ? A C PATH SHELL TESTABILITY args argv broken nl
-to
must be requested to be checked
/bin/readlink returned 1
x
(external) () ( ) internal(parenthesis)
/bin:/usr/bin:.
/bin/rwsh
an=external var(iable)
-- -* .var_exists ? A C PATH SHELL TESTABILITY args argv broken nl
./rwsh -to
extra_close) (extra_open


this printenv function has been brought to you by .autofunction
$whence printenv
.function printenv -- [args ...] {
      /usr/bin/printenv $args$
      echo this printenv function has been brought to you by .autofunction}
$
$if_only_not test -z z {echo test throwing a .false exception}
added /usr/bin/test to executable map in test suite
test throwing a .false exception
$
$## unused variables
$# bless_unused_variables
$.scope () {}
$.scope -- () {}
$.scope -- () {echo $--}
--
$.scope -- (-- [a]) {}
a was unused with call stack .scope
$.scope () {.local a n; .local b o; .local c p}
a was unused with call stack .scope
b was unused with call stack .scope
c was unused with call stack .scope
$.scope () {
  .local a n; .local b o; .local c p
  echo $a $b $c $d
  .local d too_late}
d was not declared
call stack: .scope
$.scope () {
  .local a n; .local b o; .local c p
  echo $d $a $b $c
  .local d too_late}
a was unused with call stack .scope
b was unused with call stack .scope
c was unused with call stack .scope
d was not declared
call stack: .scope
$.scope n o p q (a b c d) {echo $a $b $c $d}
n o p q
$.scope n o p q (a b c d) {echo a b c d}
a b c d
a was unused with call stack .scope
b was unused with call stack .scope
c was unused with call stack .scope
d was unused with call stack .scope
$.scope n o (a [b] c [d]) {echo $a $c }
n o
b was not checked with call stack .scope
d was not checked with call stack .scope
$.scope n o ([a] b [c] d) {echo $b $d; .var_exists a}
n o
assertion (var exists: a) failed
call stack .var_exists .scope
c was not checked with call stack .scope
$.scope n o ([a] b [c] d) {echo $b; .var_exists c}
n
assertion (var exists: c) failed
call stack .var_exists .scope
a was not checked with call stack .scope
d was unused with call stack .scope
$.scope n ([a1 a2 a3 a4] b [c] [d1 d2] [e ...]) {echo $b}
n
a1 was not checked with call stack .scope
a2 was not checked with call stack .scope
a3 was not checked with call stack .scope
a4 was not checked with call stack .scope
c was not checked with call stack .scope
d1 was not checked with call stack .scope
d2 was not checked with call stack .scope
e was not checked with call stack .scope
$.scope n ([a1 a2 a3 a4] b [c] [d1 d2] [e ...]) {echo $b; .var_exists a4 d2 e c}
n
assertion (var exists: a4 d2 e c) failed
call stack .var_exists .scope
$.scope n ([a1 a2 a3 a4] b [c] [d1 d2] [e ...]) {echo $b; .var_exists a3 d1}
n
assertion (var exists: a3 d1) failed
call stack .var_exists .scope
c was not checked with call stack .scope
e was not checked with call stack .scope
$.scope n ([a1 a2 a3 a4] b [c] [d1 d2] [e ...]) {echo ${.list_locals} $b}
b n
$.scope n o p q r s ([a1 a2 a3 a4] b [c] [d1 d2] [e ...]) {echo ${.list_locals} $b}
(a1 a2 a3 a4 b c) r
a1 was unused with call stack .scope
a2 was unused with call stack .scope
a3 was unused with call stack .scope
a4 was unused with call stack .scope
c was unused with call stack .scope
$.scope n o p q r s t u ([a1 a2 a3 a4] b [c] [d1 d2]) {echo $a1 $d2}
n u
a2 was unused with call stack .scope
a3 was unused with call stack .scope
a4 was unused with call stack .scope
b was unused with call stack .scope
c was unused with call stack .scope
d1 was unused with call stack .scope
$.scope n o p q r s t u ([a1 a2 a3 a4] b [c] [d1 d2]) {
  echo $a1 $a2 $a3 $a4 $c $d1 $d2}
n o p q s t u
b was unused with call stack .scope
$.scope ([-a a1 a2 a3] [-b] [-c] [-d d1]) {}
-a was not checked with call stack .scope
a1 was not checked with call stack .scope
a2 was not checked with call stack .scope
a3 was not checked with call stack .scope
-b was not checked with call stack .scope
-c was not checked with call stack .scope
-d was not checked with call stack .scope
d1 was not checked with call stack .scope
-* was unused with call stack .scope
$.scope ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {}
-a was not checked with call stack .scope
a1 was not checked with call stack .scope
a2 was not checked with call stack .scope
a3 was not checked with call stack .scope
-b was not checked with call stack .scope
-c was not checked with call stack .scope
-d was not checked with call stack .scope
d1 was not checked with call stack .scope
-? was unused with call stack .scope
-* was unused with call stack .scope
$.scope ([-a a1 a2 a3] [-b] [-c] [-d d1]) {.var_exists -a -b -c -d}
assertion (var exists: -a -b -c -d) failed
call stack .var_exists .scope
$.scope ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {echo $-?; .var_exists -a -b -c -d}
()
assertion (var exists: -a -b -c -d) failed
call stack .var_exists .scope
$.scope ([-a a1 a2 a3] [-b] [-c] [-d d1]) {.list_locals; .echo $nl}
-*
$.scope -b -d darg ([-a a1 a2 a3] [-b] [-c] [-d d1]) {.list_locals; echo ()}
-* -b -d d1()
d1 was unused with call stack .scope
-d was unused with call stack .scope
-* was unused with call stack .scope
$.scope ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {echo ${.list_locals} $-?}
(-* -?) ()
$.scope -b -d darg -v ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {echo ${.list_locals} $-?}
(-* -? -b -d d1) -v
d1 was unused with call stack .scope
-d was unused with call stack .scope
-* was unused with call stack .scope
$.scope ([-a a1 a2 a3] [-d d1 d2]) {.var_exists a2 d2}
assertion (var exists: a2 d2) failed
call stack .var_exists .scope
$.scope ([-?] [-a a1 a2 a3] [-d d1 d2]) {.var_exists -? a3 d1}
-? was unused with call stack .scope
-* was unused with call stack .scope
$.scope ([-a a1 a2 a3] [-b] [-c] [-d d1]) {echo $-*}
()
$.scope ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {echo $-*}
()
$.scope n ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1] [e] f) {.local loc lval; echo $-*}
()
e was not checked with call stack .scope
f was unused with call stack .scope
loc was unused with call stack .scope
$.scope -c ([-a a1 a2 a3] [-b] [-c] [-d d1]) {echo $-c}
-c
-a was not checked with call stack .scope
a1 was not checked with call stack .scope
a2 was not checked with call stack .scope
a3 was not checked with call stack .scope
-b was not checked with call stack .scope
-d was not checked with call stack .scope
d1 was not checked with call stack .scope
-* was unused with call stack .scope
$.scope -b -c ([-a a1 a2 a3] [-b] [-c] [-d d1]) {echo $-c; .var_exists -a -b -d}
-c
$.scope -b -c ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {
  echo $-c; .var_exists -a -b -d -?}
-c
-? was unused with call stack .scope
-* was unused with call stack .scope
$.scope -b -c ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {
  echo $-c $-?; .var_exists -a -b -d}
-c ()
$.scope -b -c ([-a a1 a2 a3] [-b] [-c] [-d d1]) {echo $-b; .var_exists a2 d1}
-b
assertion (var exists: a2 d1) failed
call stack .var_exists .scope
-c was unused with call stack .scope
-* was unused with call stack .scope
$.scope -a n o p -b -c -d q ([-a a1 a2 a3] [-b] [-c] [-d d1]) {
  echo $-c; .var_exists -a -b -d}
-c
a1 was unused with call stack .scope
a2 was unused with call stack .scope
a3 was unused with call stack .scope
-a was unused with call stack .scope
d1 was unused with call stack .scope
-d was unused with call stack .scope
-* was unused with call stack .scope
$.scope -a n o p -b -c -d q ([-a a1 a2 a3] [-b] [-c] [-d d1]) {
  echo $-b; .var_exists a2 d1}
-b
a1 was unused with call stack .scope
a2 was unused with call stack .scope
a3 was unused with call stack .scope
-a was unused with call stack .scope
-c was unused with call stack .scope
d1 was unused with call stack .scope
-d was unused with call stack .scope
-* was unused with call stack .scope
$.scope -a n o p -b -c -d q ([-a a1 a2 a3] [-b] [-c] [-d d1]) {
  echo $-a $-b $-c $-d}
(-a n o p) -b -c (-d q)
$.scope -a n o p -b -c -d q ([-a a1 a2 a3] [-b] [-c] [-d d1]) {
  echo $a1 $a2 $a3 $d1; .var_exists -b -c}
n o p q
$.scope -a n o p -b -c -d q ([-a a1 a2 a3] [-b] [-c] [-d d1]) {
  echo $-*}
(-a n o p -b -c -d q)
$.scope -v -a n o p -b -c -d q ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {
  echo $a1 $a2 $a3 $d1; .var_exists -b -c}
n o p q
-? was unused with call stack .scope
-* was unused with call stack .scope
$.scope -v -a n o p -b -c -d q ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {echo $-?}
-v
a1 was unused with call stack .scope
a2 was unused with call stack .scope
a3 was unused with call stack .scope
-a was unused with call stack .scope
-b was unused with call stack .scope
-c was unused with call stack .scope
d1 was unused with call stack .scope
-d was unused with call stack .scope
-* was unused with call stack .scope
$.scope -v -a n o p -b -c -d q ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {echo $-*}
(-v -a n o p -b -c -d q)
$.scope -a n o p ([-a a1 a2 a3]) {echo $a1 $a3}
n p
a2 was unused with call stack .scope
-a was unused with call stack .scope
-* was unused with call stack .scope
$.scope x y z (x y z) {.reinterpret $x (x [y] z)}
unacceptable arguments: for prototype x [y] z,
 assigned x=x ,
 but needed (z),
( call) stack: (.reinterpret .scope)
$.scope w x (w x) {.local y y; .reinterpret $w $x (w [x y])}
unacceptable arguments: for prototype w [x y],
 assigned w=w x=x ,
 but needed (y),
( call) stack: (.reinterpret .scope)
$
$# .excessive_nesting Base_executable::exception_handler
$fn g {h}
$fn h {g}
$g
function exceeded max nesting ( 20 ). call stack: (h g h g h g h g h g h g h g h g h g h g h g)
$.stepwise g (argv ...) {echoe $argv$ $nl; $*}
h 
function exceeded max nesting ( 20 ). call stack: (g h g h g h g h g h g h g h g h g h g h .stepwise(body) .stepwise)
$fn .excessive_nesting args ... {.nop $args; h}
$g
Exception for failed handler. Original exception with call stack:
.excessive_nesting h g h g h g h g h g h g h g h g h g h g h g
Exception for failed handler. Original exception with call stack:
.excessive_nesting h g h g h g h g h g h g h g h g h g h g h .excessive_nesting
$fn .excessive_nesting args ... {.nop $args; echoe &&{.throw .nop}}
$fn .failed_substitution args ... {.nop $args; echoe $Z}
$g
Exception for failed handler. Original exception with call stack:
.excessive_nesting h g h g h g h g h g h g h g h g h g h g h g
Exception for failed handler. Original exception with call stack:
.failed_substitution &{.throw .nop} .excessive_nesting
Z was not declared
call stack: .failed_substitution
$.set_max_extra_exceptions 0
$e_after {.try_catch_recursive .undeclared_variable .excessive_nesting .failed_substitution {g}}
Exception for failed handler. Original exception with call stack:
.excessive_nesting g h g h g h g h g h g h g h g h g .try_catch_recursive(body) .try_catch_recursive .scope se e_after
Exception for failed handler. Original exception with call stack:
.failed_substitution &{.throw .nop} .excessive_nesting
Z was not declared
call stack: .failed_substitution
exceeded maximum number of exceptions ( 0 ) in try_catch.
call stack: .try_catch_recursive .scope se e_after
$.set_max_extra_exceptions 5
$e_after {.try_catch_recursive .undeclared_variable .excessive_nesting .failed_substitution {g}}
Z was not declared
call stack: .failed_substitution
Exception for failed handler. Original exception with call stack:
.excessive_nesting g h g h g h g h g h g h g h g h g .try_catch_recursive(body) .try_catch_recursive .scope se e_after
Exception for failed handler. Original exception with call stack:
.failed_substitution &{.throw .nop} .excessive_nesting
Z was not declared
call stack: .failed_substitution
Exception for failed handler. Original exception with call stack:
.failed_substitution &{.throw .nop} .excessive_nesting .try_catch_recursive .scope se e_after
$e_after {.try_catch_recursive .undeclared_variable .failed_substitution {
  e ${.throw .nop}}}
Z was not declared
call stack: .failed_substitution
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.throw .nop} .try_catch_recursive(body) .try_catch_recursive .scope se e_after
Z was not declared
call stack: .failed_substitution
$fn .else_without_if args ... {.nop $args; e ${.throw .nop}}
$e_after {.try_catch_recursive .undeclared_variable .else_without_if {
  .else {}}}
Exception for failed handler. Original exception with call stack:
.else_without_if .else .try_catch_recursive(body) .try_catch_recursive .scope se e_after
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.throw .nop} .else_without_if
Z was not declared
call stack: .failed_substitution
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.throw .nop} .else_without_if .try_catch_recursive .scope se e_after
$fn .failed_substitution args ... {.nop $args; e ${.throw echo foo}}
$e_after {.try_catch_recursive .undeclared_variable .failed_substitution {
  e ${.throw .nop}}}
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.throw .nop} .try_catch_recursive(body) .try_catch_recursive .scope se e_after
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.throw echo foo} .failed_substitution
foo .throw .failed_substitution .failed_substitution .try_catch_recursive .scope se e_after
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.throw echo foo} .failed_substitution .try_catch_recursive .scope se e_after
foo .throw .failed_substitution .failed_substitution .try_catch_recursive .scope se e_after
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.throw echo foo} .failed_substitution .try_catch_recursive .scope se e_after
foo .throw .failed_substitution .failed_substitution .try_catch_recursive .scope se e_after
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.throw echo foo} .failed_substitution .try_catch_recursive .scope se e_after
exceeded maximum number of exceptions ( 5 ) in try_catch.
call stack: .try_catch_recursive .scope se e_after
foo .throw .failed_substitution .failed_substitution
$fn .else_without_if args ... {.nop $args; e $Z}
$e_after {.try_catch_recursive .undeclared_variable .else_without_if {
  .else {}}}
Z was not declared
call stack: .else_without_if
Exception for failed handler. Original exception with call stack:
.else_without_if .else .try_catch_recursive(body) .try_catch_recursive .scope se e_after
Z was not declared
call stack: .else_without_if
$fn .failed_substitution args ... {.nop $args; .test_less 0 Z}
$e_after {.try_catch_recursive .not_a_number .failed_substitution {
  e ${.throw .nop}}}
Z is not a number
call stack: .test_less .failed_substitution
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.throw .nop} .try_catch_recursive(body) .try_catch_recursive .scope se e_after
Z is not a number
call stack: .test_less .failed_substitution
$
$# .getpid .getppid .sighup
$.getpid excess
unacceptable arguments: for prototype ,
 found (excess) excess
( call) stack: .getpid
$.getpid {excess argfunc}
.getpid does not accept an argfunction with call stack: .getpid
$.getppid excess
unacceptable arguments: for prototype ,
 found (excess) excess
( call) stack: .getppid
$.getppid {excess argfunc}
.getppid does not accept an argfunction with call stack: .getppid
$se {.fork se {
      /bin/kill -HUP ${.getppid}
      echo after the signal in subshell}
    echo after the signal in parent}
added /bin/kill to executable map in test suite
after the signal in subshell
received SIGHUP
after the signal in parent
$se {.fork se {
      /bin/kill -HUP ${.getpid}
      echo after the signal in subshell}
    echo after the signal in parent}
added /bin/kill to executable map in test suite
received SIGHUP
after the signal in subshell
after the signal in parent
$.while .nop {
  echo before signals
  /bin/kill -PIPE ${.getpid}
  echo after sigpipe
  /bin/kill ${.getpid}
  echo should not continue beyond SIGTERM}
before signals
added /bin/kill to executable map in test suite
received SIGPIPE
after sigpipe
(
) received SIGTERM .throw .sigterm /bin/kill .mapped_argfunction .while
$.while .nop {
  echo before signals
  /bin/kill -USR1 ${.getpid}
  echo after sigusr1
  /bin/kill -INT ${.getpid}
  echo should not continue beyond SIGINT}
before signals
received SIGUSR1
after sigusr1
(
) received SIGINT .throw .sigint /bin/kill .mapped_argfunction .while
$
$# exiting
$# .shutdown .exit
$.exit
unacceptable arguments: for prototype -- return_code,
 needed (return_code),
( call) stack: .exit
$.exit 1 {excess argfunction}
.exit does not accept an argfunction with call stack: .exit
$.exit not_a_number
not_a_number is not a number
call stack: .exit
$.fork .exit 256
value 256 is out of usable numeric range
call stack .exit
.fork returned 255 : call stack .fork
$.fork .exit -2560
value -2560 is out of usable numeric range
call stack .exit
.fork returned 255 : call stack .fork
$.fork .exit -2
.fork returned 254 : call stack .fork
$fn exit_exception args ... {echo $args$; .exit 0}
$.collect_errors_except .nop {
  .try_catch_recursive exit_exception {
    .collect_errors_only exit_exception {
      .throw exit_exception
      echo print expected after having collected exit exception}}
  echo after having run .exit (will not print)}
print expected after having collected exit exception
.throw .collect_errors_only .try_catch_recursive(body)

now terminating normally
