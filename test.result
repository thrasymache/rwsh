init file /non-existent/file/to/test/failure does not exist
call stack .source .try_catch_recursive(body)
.global A \

.nop .function_all_flags .run_logic -- cmd [args ...] {
  .signal_handler &{.internal_functions}$ {&&* {.argfunction}}
  .mapped_argfunction {&&* {.argfunction}}
  &&* {.argfunction}}
.function_all_flags .before_command -- args ... {.nop $args}
.function_all_flags .after_command -- args ... {.nop $args}
.function_all_flags .prompt {.echo \$}
.function_all_flags .vars {.internal_vars}
.source /etc/rwshrc-basic
.function_all_flags # -- [ignored ...] {.nop $ignored$}
.function_all_flags fn -- prototype ... {
  .function_all_flags $prototype$ {.argfunction}}

# set up environment
.set_max_collectible_exceptions 10
.set_max_extra_exceptions 5
.global nl (
)
.if .var_exists ? {}
.else {.global ? (); .nop $?}

# internal functions
.function_all_flags .ambiguous_prototype_dash_dash prototype stack ... {
  .echo $prototype is an ambiguous location for a prototype --
  .combine ( (it requests reading the user's mind) ) \( stack: $stack \) $nl}
.function_all_flags .arguments_for_argfunction name {
  echo cannot specify arguments for $name directly}
.function_all_flags .bad_argc required needed optional [stack ...] {
  .echo unacceptable argument count: received $required non-optional
  echo , but needed $needed \(with $optional optional\) for $stack$}
.function_all_flags .bad_argfunction_style style {
  echo $style is neither an argfunction nor a substitution nor a brace literal}
.function_all_flags .bad_args -- proto assigned needed excess call_stack ... {
  .combine (unacceptable arguments: for prototype ) $proto , $nl
  if_only .test_not_empty $assigned {
    .combine ( assigned )
    .for $assigned$ {.combine $1$0 = ${paren_if_words $1$1} ( )}
    .combine , $nl ( but)}
  if_only .test_not_empty $needed {
    .combine ( needed \() $needed \), $nl
    if_only .test_not_empty $excess {.combine ( and)}}
  if_only .test_not_empty $excess {
    .combine ( found \() $excess (\) excess) $nl}
  echo \ call stack:  $call_stack}
.function_all_flags .bad_if_nest stack ... {
  echo nested .if without .else with call stack: $stack$}
.function_all_flags .binary_does_not_exist name [stack ...] {
  echo $name : binary does not exist
  if_only .var_exists stack {echo call stack: $stack}}
.function_all_flags .binary_not_found name path stack ... {
  echo $name : binary not found in $path
  echo call stack: $stack$}
.function_all_flags .break stack ... {
  echo .break thrown outside of control flow body
  echo call stack: $stack$}
.function_all_flags .continue stack ... {
  echo .continue thrown outside of control flow body
  echo call stack: $stack$}
.function_all_flags .dash_dash_argument args stack ... {
  echo optional -- parameter cannot take arguments \( $args \) with call stack: $stack$}
.function_all_flags .dash_star_argument args stack ... {
  echo optional -* parameter cannot take arguments \( $args \) with call stack: $stack$}
.function_all_flags .directory_not_found -- dir stack ... {
  .combine $dir ( directory does not exist) $nl
  echo call stack $stack}
.function_all_flags .divide_by_zero numerator stack ... {
  echo attempt to divide $numerator by 0 with call stack: $stack$}
.function_all_flags .double_redirection first second [stack ...] {
  echo double redirection is not supported at this time: $first and $second
  if_only .var_exists stack {echo call stack: $stack$}}
.function_all_flags .duplicate_parameter -- parameter stack ... {
  echo duplicated parameter in function definition: $parameter
  echo call stack: $stack$}
.function_all_flags .elipsis_first_arg -- elipsis stack ... {
  echo $elipsis elipsis cannot be the first argument in a prototype
  echo call stack: $stack$}
.function_all_flags .elipsis_out_of_option_group -- group stack ... {
  echo $group for elipsis to apply to option it must occur within the brackets
  echo call stack: $stack$}
.function_all_flags .else_without_if stack ... {
  echo else without if with call stack: $stack$}
.function_all_flags .excess_argfunction cmd [stack ...] {
  echo $cmd does not accept an argfunction with call stack: $cmd $stack$}
.function_all_flags .excessive_exceptions_collected max stack ... {
  echo exceeded maximum number of exceptions \( $max \) in collect_errors.
  echo call stack: $stack$}
.function_all_flags .excessive_exceptions_in_catch max stack ... {
  echo exceeded maximum number of exceptions \( $max \) in try_catch.
  echo call stack: $stack$}
.function_all_flags .excessive_nesting stack ... {
  echo function exceeded max nesting \( ${.get_max_nesting} \). call stack: $stack}
.function_all_flags .exec_failed binary errno stack ... {
  .combine (.exec failed for ) $binary ( with errno ) $errno $nl
  echo call stack $stack}
.function_all_flags .executable_already_exists -- binary stack ... {
  echo $binary is already an executable in the hash table $nl
  echo call stack $stack}
.function_all_flags .failed_substitution substitution [stack ...] {
  echo substitution $substitution failed
  if_only .var_exists stack {echo call stack: $stack$}}
.function_all_flags .false test [stack ...] {
  echo assertion $test failed
  echo call stack $stack$}
.function_all_flags .file_not_found -- file stack ... {
  echo could not find file $file
  echo call stack $stack}
.function_all_flags .file_open_failure -- file stack ... {
  echo could not open file $file
  echo call stack $stack}
.function_all_flags .flag_in_elipsis -- flag stack ... {
  echo found flag $flag while collecting arguments for elipsis
  echo call stack $stack$}
.function_all_flags .function_not_found -- cmd [stack ...] {
  echo $cmd : command not found \( $cmd $stack$ \)}
.function_all_flags .global_would_be_masked name stack ... {
  .echo requested global $name already exists as a local
  echo . It would be masked by the local and inaccessible from here
  echo call stack $stack$}
.function_all_flags .help [args ...] {
  .nop $args$
  .echo this is the default configuration for rwsh \(or something copied from it
  echo \), documentation should be available at rwsh.sf.net or rwsh.org}
.function_all_flags .if_before_else stack ... {
  echo two .if commands without a .else between them with call stack : $stack$}
.function_all_flags .illegal_function_name name stack ... {
  .combine \$ $name ( cannot be a function) $nl
  echo call stack $stack}
.function_all_flags .illegal_variable_name name stack ... {
  .combine \$ $name ( cannot be set) $nl
  echo call stack $stack}
.function_all_flags .input_range -- value stack ... {
  echo value $value is out of usable numeric range
  echo call stack $stack$}
.function_all_flags .internal_error -- [args ...] {
  echo internal error: $args$}
.function_all_flags .interrupted_sleep [stack ...] {
  echo sleep was interrupted
  echo call stack $stack$}
.function_all_flags .invalid_word_selection selection [stack ...] {
  echo $selection is not a valid word selection
  echo call stack $stack$}
.function_all_flags .mismatched_brace context [stack ...] {
  echo mismatched brace: $context $stack$}
.function_all_flags .mismatched_bracket context [stack ...] {
  echo mismatched bracket: $context
  if_only .var_exists stack {echo call stack: $stack$}}
.function .mismatched_parenthesis {
  .echo signal triggered: $0 \( $* \); .combine $nl
  echo mismatched parenthesis: $1
  echo call stack: $*2}
.function_all_flags .missing_argfunction cmd [add_stack ...] {
  echo $cmd requires an argfunction
  if_only .var_exists add_stack {echo stack $add_stack$}}
.function_all_flags .multiple_argfunctions {
  echo multiple argfunctions not supported at this time}
.function_all_flags .not_a_directory file stack ... {
  .combine $file ( is not a directory) $nl
  echo call stack $stack}
.function_all_flags .not_a_function executable stack ... {
  .combine $executable ( is not a function) $nl
  echo call stack $stack}
.function_all_flags .not_a_number -- nan stack ... {
  echo $nan is not a number
  echo call stack: $stack$}
.function_all_flags .not_catching_exception stack ... {
  echo .replace_exception called outside of an exception handler
  echo call stack: $stack$}
.function_all_flags .not_executable file stack ... {
  echo $file is not executable
  echo call stack: $stack$}
.function_all_flags .not_soon_enough too_late [stack ...] {
  echo $too_late attempts to substitute after the command has been run
  if_only .var_exists stack {echo call stack $stack}}
.function_all_flags .post_elipsis_option -- flag stack ... {
  echo option $flag coming after an elipsis has no meaning
  echo call stack: $stack$}
.function_all_flags .post_dash_dash_flag -- flag stack ... {
  echo flag option $flag occurs after -- in the prototype
  echo call stack: $stack$}
.function_all_flags .result_range -- lhs rhs op [stack ...] {
  echo result of $op with arguments $lhs and $rhs is out of range
  echo call stack: $op $stack$}
.function_all_flags .return_code code cmd [add_stack ...] {
  .if .test_in $cmd /usr/bin/test /bin/false {
    .replace_exception .false $cmd
    .nop $code $add_stack$}
  .else {
    .set ? $cmd returned $code
    echo $?$ : call stack $cmd $add_stack$}}
.function_all_flags .selection_not_found not_found selection [stack ...] {
  .echo no file matching pattern $not_found
  if_only .test_string_unequal $not_found $selection {
    .echo () for selection $selection}
  .echo $nl
  if_only .var_exists stack {echo call stack: $stack$}}
.function_all_flags .sigcont {
  echo received SIGCONT}
.function_all_flags .sigchld {
  echo received SIGCHLD}
.function_all_flags .sighup {
  echo received SIGHUP}
.function_all_flags .sigint {
  .throw echo $nl received SIGINT}
.function_all_flags .sigquit {
  echo received SIGQUIT}
.function_all_flags .sigpipe {
  echo received SIGPIPE}
.function_all_flags .sigterm {
  .throw echo $nl received SIGTERM}
.function_all_flags .sigtstp {
  echo received SIGTSTP}
.function_all_flags .siginfo {
  echo received SIGINFO}
.function_all_flags .sigusr1 {
  echo received SIGUSR1}
.function_all_flags .sigusr2 {
  echo received SIGUSR2}
.function_all_flags .sigunknown {
  echo received unknown unix signal}
.function_all_flags .shutdown -- args ... {
  .nop $args
  .combine $nl (now terminating normally) $nl}
.function_all_flags .tardy_flag -- flag stack ... {
  echo $flag flag comes too late in command
  echo call stack: $stack$}
.function_all_flags .unchecked_variable -- var [stack ...] {
  echo $var was not checked with call stack $stack$}
.function_all_flags .undeclared_variable -- name [stack ...] {
  echo $name was not declared
  echo call stack: $stack$}
.function_all_flags .undefined_variable -- name [stack ...] {
  echo optional variable $name was not defined
  echo call stack: $stack$}
.function_all_flags .unfinished_if_block [stack ...] {
  echo conditional not finished within preceeding block
  if_only .var_exists stack {echo call stack: $stack$}}
.function_all_flags .unreadable_dir dir errno [stack ...] {
  .combine (cannot read directory ) $dir \ \(errno\  $errno \) $nl
  echo call stack: $stack$}
.function_all_flags .unrecognized_flag -- flag cmd [add_stack ...] {
  echo $flag flag is unrecognized for $cmd
  echo call stack: $cmd $add_stack$}
.function_all_flags .unused_before_set -- var [stack ...] {
  echo attempt to set $var before making use of its initial value
  echo call stack $stack$}
.function_all_flags .unused_variable -- var [stack ...] {
  echo $var was unused with call stack $stack$}
.function_all_flags .variable_already_exists name stack ... {
  echo variable $name already exists
  echo call stack $stack$}
.function_all_flags .version_incompatible version stack ... {
  echo this shell is not compatible with requested version $version
  echo call stack: $stack$}

# ability of functions to act as builtin wrappers
.function_all_flags ! args ... {
  .if $args$ {.throw .false ${.echo ! $args}}
  .else {.nop}}
.function_all_flags af -- [argv ...] {.argfunction}
.function_all_flags c -- text ... {.combine $text$}
.function_all_flags e -- text ... {.echo $text}
.function_all_flags do_while argv ... {
  .try_catch_recursive .break {
    .nop $argv
    .try_catch_recursive .continue {.argfunction}
    .while $argv$ {.argfunction}}}
.function_all_flags echo -- text ... {.echo $text; .combine $nl}
.function_all_flags echo-comments cmd ... {
  .stepwise $cmd$ {if_only .test_in $1 .nop # #! ## {echo &&&*}}}
.function_all_flags exec -- argv ... {.exec $argv$}
.function_all_flags elif command ... {.else_if $command$ {.argfunction}}
.function_all_flags else {.else {.argfunction}}
fn false {.try_catch_recursive .return_code {${whichp false}}}
.function_all_flags fns -- name args ... {
  .function_all_flags $name [-*] $args$ {.argfunction}}
.function_all_flags if_only -- args ... {
  .if $args$ {.argfunction}; .else {.nop}}
.function_all_flags if_only_not -- args ... {
  .if $args$ {.nop}; .else {.argfunction}}
fn ntimes n {
  .while test_var_greater n 0 {
    .mapped_argfunction {.argfunction}
    .var_subtract n 1}}
.function_all_flags outer_break stack ... {
  .replace_exception .break $stack$}
.function_all_flags outer_continue stack ... {
  .replace_exception .continue $stack$}
.function_all_flags scope_for var vals ... {
  .for $vals$ {
    .scope $1 $var {.argfunction}}}
.function_all_flags outer_for var vals ... {
  .for $vals$ {
    .scope $1 $var {
      .try_catch_recursive outer_break outer_continue {.argfunction}}}}
.function_all_flags outer_while argv ... {
  .while $argv$ {
    .try_catch_recursive outer_break outer_continue {.argfunction}}}
.function_all_flags setf var value {
  .if .var_exists $var {.set $var $value}
  .else {.global $var $value}}
fn single -- args ... {.scope ${$args$}$ result {echo $result}}
fn test -- args ... {
  .try_catch_recursive .return_code {${whichp test} $args$}}
fn test_var_not_equal var value {.test_string_unequal $$var $value}
fn test_var_greater -- var value {.test_greater $$var $value}
fn type [-t] args ... {
  .for $args$ {
    .try_catch_recursive .function_not_found {
      if_only_not .var_exists -t {.echo &&&1 is ()}
      .type &&&1 {.argfunction}}}}
fn whence command {
  .try_catch_recursive .function_not_found {
    .whence_function $command {.argfunction}}}
fn whichp binary {.which_path $binary $PATH}
.function_all_flags while_and_one_more argv ... {
  .try_catch_recursive .break {
    .while $argv$ {.argfunction}
    .try_catch_recursive .continue {.argfunction}}}
.function_all_flags var_exists -- var {.var_exists $var}
.function_all_flags var_in var set ... {.test_in $$var $set$}
.function_all_flags var_less var N {.test_less $$var $N}
.function_all_flags var_val -- [var ...] {
  .if .var_exists var {.for $var$ {.combine $1 \( $$1 \) \ }}
  .else {.nop}}
.function_all_flags paren_if_words -- value {
  .if .test_number_equal ${.argc $value$} 1 {.combine $value}
  .else {.combine \( $value \)}}
fn polish -- operator builtin {
  fn &&operator -- lhs rhs ... {
    if_only .test_in $lhs + - / {
      .scope ${$lhs $rhs$}$ (-- l r ...) {
        .set lhs $l
        .set rhs $r}}
    .scope $rhs$ (rhs [extra ...]) {
      .if .test_in $rhs + - / {
        .scope ${$rhs $extra$}$ (rhs [extra ...]) {
          &&builtin lhs $rhs
          echo $lhs $extra$}}
      .else {
        &&builtin lhs $rhs
        echo $lhs $extra$}}}}
polish - .var_subtract
polish + .var_add
polish / .var_divide
.else_if .test_string_equal $2 -c {
  .for ${.list_environment}$ {
    .scope $1$ (-- var val) {
      .if .var_exists $var {.nop $val}
      .else {
        .global $var $val
        .nop $$var}}}
  .source /etc/rwshrc-basic
  .nop $FIGNORE
  .function_all_flags .shutdown -- [args ...] {.nop $args}
  .function_all_flags .return_code code cmd [add_stack ...] {
    echo $cmd returned $code : call stack $cmd $add_stack$
    .exit $code}
  .collect_errors_except .nop {
    .mapped_argfunction &3 {$1$}
    .exit 0}}
.else {
  .echo unexpected command line: &* (
)
  .source /etc/rwshrc-default}
$.binary /bin/cat
$/bin/cat /tmp/lcl
/etc/rwshrc ./rwsh test_init.sh 
$.function_all_flags ## [args ...] {.nop $args}
$#
$.nop beware the empty comment
$
$## argm
$# .source
$.nop
$     .nop
$.nop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
$echo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
$.echo  ()    1                2       $# $nl
 1 2 6 
$.echo \escaped internal\ space $# $nl
escaped internal space 5 
$.echo now \ external\  $# $nl
now  external  5 
$.echo a \  space $# $nl
a   space 6 
$echo \$tokens \} \{ \; \\ \) \(
$tokens } { ; \ ) (
$.echo a \
a $line continuation (or it was supposed to be)
PATH was not declared
call stack: .autofunction .autofunction
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction
line : command not found ( line continuation (or it was supposed to be) )
$ echo ignore leading space
ignore leading space
$	echo ignore leading tab
ignore leading tab
$.mapped_argfunction {	   echo ignore leading tab in argfunction}
ignore leading tab in argfunction
$.whence_function .mapped_argfunction {.nop}
{.nop}
$.whence_function .argfunction {
  multiple line argfunction }
{
  multiple line argfunction}
$.nop .argfunction .mismatched_brace } &&&is$not$all
mismatched brace: (.nop .argfunction .mismatched_brace })
$not$all is not a valid word selection
call stack
&&&is$not$all attempts to substitute after the command has been run
$.source
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .source
$.source /etc/hosts {excess argfunc}
.source does not accept an argfunction with call stack: .source
$.source test_files/*fu*bar*
could not open file test_files/*fu*bar*
call stack .source
$.source /etc/hosts
/etc/hosts is not executable
call stack: .source
$.source test_files/unclosed_brace.rwsh
fn bar {echo baz

mismatched brace: (fn bar) .source
$.source test_files/unclosed_brace_without_newline.rwsh
fn bar {echo baz

mismatched brace: (fn bar) .source
$.source test_files/unclosed_dot_brace.rwsh
echo bar .{argfunction baz

mismatched brace: (echo bar ) .source
$.source test_files/unclosed_parenthesis.rwsh
echo bar (baz

signal triggered: .mismatched_parenthesis ( echo bar ( .source )
mismatched parenthesis: (echo bar ()
call stack: .source
$.source test_files/unclosed_parenthesis_without_newline.rwsh
echo bar (baz

signal triggered: .mismatched_parenthesis ( echo bar ( .source )
mismatched parenthesis: (echo bar ()
call stack: .source
$.source test_files/multiple_errors.rwsh
fn bar {echo &&&baz$$bax
  cat >something >else
  }
$$bax is not a valid word selection
call stack .source
&&&baz$$bax attempts to substitute after the command has been run
call stack .source
double redirection is not supported at this time: >something and >else
call stack: .source
$.source test_files/bad_substitution.rwsh
echo before error
before error
echo the error ${.throw echo nonexistent} was there
nonexistent .throw test_files/bad_substitution.rwsh .source
substitution (${.throw echo nonexistent}) failed
call stack: .source
$.nop multiple statements \; on a line
$.whence_function .argfunction {.multiple_argfunctions} {}
multiple argfunctions not supported at this time
$.whence_function .argfunction {.argfunction with text args}
cannot specify arguments for (.argfunction with text args!) directly
$.whence_function .argfunction {.argfunction {with a function arg}}
cannot specify arguments for (.argfunction {with a function arg}!) directly
$.whence_function x {.escaped_argfunction me}
cannot specify arguments for (.escaped_argfunction me!) directly
$.whence_function .argfunction {{{{{{{{{{{}}}}}}}}}}}
{{{{{{{{{{{}}}}}}}}}}}
$.whence_function .argfunction {
  .function_all_flags  x  { ${ .which_path  echo  $PATH }  something } }
{
  .function_all_flags x { ${ .which_path echo $PATH} something}}
$
$## ability of functions to perform custom control flow
$# rwshrc-basic
$.function e {.echo $*}
$.function om {.argfunction}
$.function_all_flags sa [args ...] {
  .scope $args$ ([args ...]) {.argfunction}}
$.function_all_flags se {.scope () {.argfunction}}
$.whence_function e
.function e {.echo $*}
$.whence_function om
.function om {.argfunction}
$.whence_function sa
.function_all_flags sa [args ...] {
  .scope $args$ ([args ...]) {.argfunction}}
$.whence_function se
.function_all_flags se  {.scope () {.argfunction}}
$whence e
.function e {.echo $*}
$whence echo
.function_all_flags echo -- text ... {.echo $text; .combine $nl}
$whence ee
ee : command not found ( ee .whence_function .try_catch_recursive(body) )
$whence () {}
.function_all_flags ()  {.nop}
$echo text that does not have a prompt appended
text that does not have a prompt appended
$se {echo again}
again
$if_only .test_is_number false {echo not printed}
$if_only .test_is_number 0 {echo printed without error}
printed without error
$.function_all_flags for -- [items ...] {
  .if .var_exists items {.for $items$ {.argfunction}}
  .else {.nop}}
$for {echo skipped without error}
$for 1 2 3 {echo loop $*}
loop 1
loop 2
loop 3
$
$## arg_script.cc and arg_spec.cc
$# Arg_spec::FIXED, Arg_script::add_quote
$echo 5 4 3 2 1
5 4 3 2 1
$e a (tight string created by parentheses $#) $# $nl
a tight string created by parentheses $# 5 
$e a ( spaced string created by parentheses $# ) $# $nl
a  spaced string created by parentheses $#  5 
$echo some escaped \) \(parentheses $#
some escaped ) (parentheses 6
$e some (nested (parentheses) $#) $# $nl
some nested (parentheses) $# 5 
$e some ((((((((((repeated))))) parentheses))))) $# $nl
some (((((((((repeated))))) parentheses)))) 5 
$e a (multi-line parenthesis
  enclosed string) $# $nl
a multi-line parenthesis
  enclosed string 5 
$echo a )mismatched &&parenthesis
signal triggered: .mismatched_parenthesis ( echo a ) )
mismatched parenthesis: (echo a ))
call stack:
&&parenthesis attempts to substitute after the command has been run
$echo a (multi-line parenthesis
  mismatch))
signal triggered: .mismatched_parenthesis ( echo a (multi-line parenthesis
  mismatch)) )
mismatched parenthesis: (echo a (multi-line parenthesis
  mismatch)))
call stack:
$e (internal \)parenthesis \\ escape ( \))) $# $nl
internal )parenthesis \ escape ( )) 4 
$
$# star_var (argm_star_var)
$echo 1 2 $* 3 4
1 2 1 2 $* 3 4 3 4
$echo $*2 1 2
1 2 1 2
$
$# star_soon
$sa .nop 1 2 3 {
  .if $args$ {echo &*}
  .else {}}
.nop 1 2 3
$sa .nop 1 2 3 {
  .if $args$ {echo &*0}
  .else {}}
sa .nop 1 2 3
$
$# .init, rwshrc's autofunction, .binary
$whence .init
.function_all_flags .init -- [args ...] {.set_max_nesting 10
    .function_all_flags .file_open_failure name stack ... {        .combine (init file ) $name ( does not exist
call stack ) $stack (
)}
    .function_all_flags .raw_command -- args ... {.nop $args}
    .source /etc/rwshrc $args$
    .for &{.internal_functions}$ {      .if .test_executable_exists $1 {.nop}
      .else {.echo &&1 not defined (
)}}
    .if .test_executable_exists .help {      .if .test_not_empty ${.help} {.nop}
      .else {.echo .help produces no output (
)}}
    .else {.echo .help not defined (
)}}
$whence .autofunction
.function_all_flags .autofunction -- cmd [args ...] {
  .nop $args$
  .local full_path ${.which_path $cmd $PATH}
  if_only_not .test_executable_exists $full_path {.binary $full_path}
  if_only_not .test_string_equal $cmd $full_path {
    .function_all_flags $cmd -- [args ...] {
      &full_path $args$}}
  .error added $cmd to executable map $nl}
$.binary {e excess argfunction}
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .binary
.binary does not accept an argfunction with call stack: .binary
$.binary /bin/rzwsh
/bin/rzwsh : binary does not exist
call stack: .binary
$.binary /bin/cat
/bin/cat is already an executable in the hash table (
)
call stack .binary
$.global PATH /usr/bin
$/bin/true
/bin/true : binary not found in /usr/bin
call stack: .which_path .autofunction .autofunction
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction
/bin/true : command not found ( /bin/true )
$true
true : binary not found in /usr/bin
call stack: .which_path .autofunction .autofunction
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction
true : command not found ( true )
$.binary /bin/true
$true
true : binary not found in /usr/bin
call stack: .which_path .autofunction .autofunction
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction
true : command not found ( true )
$.rm_executable /bin/true
$.set PATH /bin:/usr/bin:.
$fals
fals : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction
fals : command not found ( fals )
$/bin/true add the binary by itself
$true add the function using existing binary
$.whence_function /usr/bin/env
/usr/bin/env : command not found ( /usr/bin/env .whence_function )
$env false add the function and the binary at once
/usr/bin/env returned 1 : call stack /usr/bin/env env
$.whence_function true
.function_all_flags true -- [args ...] {
      /bin/true $args$}
$/bin/echo this will add /bin/echo to the hash table
this will add /bin/echo to the hash table
$/bin/echo this will use the existing /bin/echo reference
this will use the existing /bin/echo reference
$echo this function is already defined
this function is already defined
$.autofunction ./rwsh
$.whence_function ./rwsh
./rwsh
$./rwsh -c (echo in a subshell)
in a subshell
$false
assertion /bin/false failed
call stack .replace_exception .mapped_argfunction .if .return_code .try_catch_recursive false
$if_only_not false {echo false throwing a .false exception}
false throwing a .false exception
$./rwsh -c (env false)
/usr/bin/env returned 1 : call stack /usr/bin/env env .mapped_argfunction .collect_errors_except .mapped_argfunction .else_if .source .init
./rwsh returned 1 : call stack ./rwsh
$./rwsh -c (.get_pid)
.get_pid : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction .mapped_argfunction .collect_errors_except .mapped_argfunction .else_if .source .init
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction .mapped_argfunction .collect_errors_except .mapped_argfunction .else_if .source .init
.get_pid : command not found ( .get_pid .mapped_argfunction .collect_errors_except .mapped_argfunction .else_if .source .init )
$./rwsh /non-existent/file/to/test/failure <test_files/pause_hello.rwsh
init file /non-existent/file/to/test/failure does not exist
call stack .source .mapped_argfunction .else_if .source .init
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
.undeclared_variable : command not found ( .undeclared_variable PATH .autofunction .autofunction )
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
.failed_substitution : command not found ( .failed_substitution ${.which_path $cmd $PATH} .autofunction )
.prompt : command not found ( .prompt )
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
.undeclared_variable : command not found ( .undeclared_variable PATH .autofunction .autofunction )
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
.failed_substitution : command not found ( .failed_substitution ${.which_path $cmd $PATH} .autofunction )
.prompt : command not found ( .prompt )
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
.undeclared_variable : command not found ( .undeclared_variable PATH .autofunction .autofunction )
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
.failed_substitution : command not found ( .failed_substitution ${.which_path $cmd $PATH} .autofunction )
.prompt : command not found ( .prompt )
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
hello world 
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
.undeclared_variable : command not found ( .undeclared_variable PATH .autofunction .autofunction )
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
.failed_substitution : command not found ( .failed_substitution ${.which_path $cmd $PATH} .autofunction )
.prompt : command not found ( .prompt )
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.unused_variable FIGNORE
.unused_variable : command not found ( .unused_variable FIGNORE )
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
.undeclared_variable : command not found ( .undeclared_variable PATH .autofunction .autofunction )
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
.failed_substitution : command not found ( .failed_substitution ${.which_path $cmd $PATH} .autofunction )
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
./rwsh returned 10 : call stack ./rwsh
$./rwsh test_files/pause_hello.rwsh <test_files/pause_hello.rwsh
hello world 
.ambiguous_prototype_dash_dash not defined 
.arguments_for_argfunction not defined 
.bad_argc not defined 
.bad_argfunction_style not defined 
.bad_args not defined 
.bad_if_nest not defined 
.binary_does_not_exist not defined 
.binary_not_found not defined 
.break not defined 
.continue not defined 
.dash_dash_argument not defined 
.dash_star_argument not defined 
.directory_not_found not defined 
.divide_by_zero not defined 
.double_redirection not defined 
.duplicate_parameter not defined 
.elipsis_first_arg not defined 
.elipsis_out_of_option_group not defined 
.else_without_if not defined 
.excess_argfunction not defined 
.excessive_exceptions_collected not defined 
.excessive_exceptions_in_catch not defined 
.excessive_nesting not defined 
.exec_failed not defined 
.executable_already_exists not defined 
.failed_substitution not defined 
.false not defined 
.file_not_found not defined 
.flag_in_elipsis not defined 
.function_not_found not defined 
.global_would_be_masked not defined 
.if_before_else not defined 
.illegal_function_name not defined 
.illegal_variable_name not defined 
.input_range not defined 
.internal_error not defined 
.interrupted_sleep not defined 
.invalid_word_selection not defined 
.mismatched_brace not defined 
.mismatched_bracket not defined 
.mismatched_parenthesis not defined 
.missing_argfunction not defined 
.multiple_argfunctions not defined 
.not_a_directory not defined 
.not_a_function not defined 
.not_a_number not defined 
.not_catching_exception not defined 
.not_executable not defined 
.not_soon_enough not defined 
.return_code not defined 
.result_range not defined 
.post_elipsis_option not defined 
.post_dash_dash_flag not defined 
.prompt not defined 
.selection_not_found not defined 
.sighup not defined 
.sigint not defined 
.sigquit not defined 
.sigpipe not defined 
.sigterm not defined 
.sigtstp not defined 
.sigcont not defined 
.sigchld not defined 
.sigusr1 not defined 
.sigusr2 not defined 
.sigunknown not defined 
.tardy_flag not defined 
.unchecked_variable not defined 
.undeclared_variable not defined 
.undefined_variable not defined 
.unfinished_if_block not defined 
.unreadable_dir not defined 
.unrecognized_flag not defined 
.unused_before_set not defined 
.unused_variable not defined 
.variable_already_exists not defined 
.version_incompatible not defined 
.help not defined 
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
.undeclared_variable : command not found ( .undeclared_variable PATH .autofunction .autofunction )
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
.failed_substitution : command not found ( .failed_substitution ${.which_path $cmd $PATH} .autofunction )
.prompt : command not found ( .prompt )
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
.undeclared_variable : command not found ( .undeclared_variable PATH .autofunction .autofunction )
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
.failed_substitution : command not found ( .failed_substitution ${.which_path $cmd $PATH} .autofunction )
.prompt : command not found ( .prompt )
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
.undeclared_variable : command not found ( .undeclared_variable PATH .autofunction .autofunction )
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
.failed_substitution : command not found ( .failed_substitution ${.which_path $cmd $PATH} .autofunction )
.prompt : command not found ( .prompt )
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
hello world 
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
.undeclared_variable : command not found ( .undeclared_variable PATH .autofunction .autofunction )
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
.failed_substitution : command not found ( .failed_substitution ${.which_path $cmd $PATH} .autofunction )
.prompt : command not found ( .prompt )
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.unused_variable FIGNORE
.unused_variable : command not found ( .unused_variable FIGNORE )
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
.undeclared_variable : command not found ( .undeclared_variable PATH .autofunction .autofunction )
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
.failed_substitution : command not found ( .failed_substitution ${.which_path $cmd $PATH} .autofunction )
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
Exception for failed handler. Original exception with call stack:
.undeclared_variable PATH .autofunction .autofunction
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.which_path $cmd $PATH} .autofunction
./rwsh returned 10 : call stack ./rwsh
$./rwsh test_files/signal_triggered.rwsh <test_files/pause_hello.rwsh
signal triggered: .raw_command ( .function_all_flags .shutdown -- [args ...] {.nop $args; .exit 255} )
signal triggered: .raw_command ( .else_if .test_string_equal $2 -c {
  .for ${.list_environment}$ {
    .scope $1$ (-- var val) {
      .if .var_exists $var {.nop $val}
      .else {
        .global $var $val
        .nop $$var}}}
  .source /etc/rwshrc-basic
  .nop $FIGNORE
  .function_all_flags .shutdown -- [args ...] {.nop $args}
  .function_all_flags .return_code code cmd [add_stack ...] {
    echo $cmd returned $code : call stack $cmd $add_stack$
    .exit $code}
  .collect_errors_except .nop {
    .mapped_argfunction &3 {$1$}
    .exit 0}} )
signal triggered: .raw_command ( .else {
  .echo unexpected command line: &* (
)
  .source /etc/rwshrc-default} )
.help not defined 
signal triggered: .prompt ( )
signal triggered: .raw_command ( #! /bin/rwsh )
signal triggered: .prompt ( )
signal triggered: .raw_command (  )
signal triggered: .prompt ( )
signal triggered: .raw_command ( .echo hello world (
) )
hello world 
signal triggered: .prompt ( )
signal triggered: .unused_variable ( FIGNORE )
./rwsh returned 255 : call stack ./rwsh
$.autofunction test_files/../rwsh
$whence test_files/../rwsh
.function_all_flags test_files/../rwsh -- [args ...] {
      ./test_files/../rwsh $args$}
$
$.function_all_flags .autofunction -- cmd [args ...] {
  # $args$ redefining .autofunction tested by subsequent usage
  .local full_path ${.which_path $cmd $PATH}
  if_only_not .test_executable_exists $full_path {.binary $full_path}
  if_only_not .test_string_equal $cmd $full_path {
    .function_all_flags $cmd -- [args ...] {
      &&full_path $args$
      echo this &&cmd function has been brought to you by .autofunction}}
  echo added $cmd to executable map in test suite}
$.binary /bin/rm
$
$# selection_read read_dir()
$echo @/etc
/etc
$echo @test_files/ixx
no file matching pattern test_files/ixx
$echo @test_files/i*xx
test_files/ixxx
$echo @test_files/i**xx
test_files/ixxx
$echo @test_files/ii**xx
no file matching pattern test_files/ii**xx
$echo @test_files/ix*xx
test_files/ixxx
$echo @test_files/ix*xx*
test_files/ixxx
$echo @test_files/ix*xxx
no file matching pattern test_files/ix*xxx
$echo @test_files/ix*xxx*
no file matching pattern test_files/ix*xxx*
$echo @test_files/*iixxx
no file matching pattern test_files/*iixxx
$echo @test_files/ix*x*x
test_files/ixxx
$echo @test_files/ix*xx*x
no file matching pattern test_files/ix*xx*x
$echo @test_files/ix*x*xx
no file matching pattern test_files/ix*x*xx
$.scope () {echo @test_files/i*xx/f*}
cannot read directory test_files/ixxx// (errno 20)
call stack: .scope
$.scope () {echo @/*selection_not_found*}
no file matching pattern /*selection_not_found*
call stack: .scope
$echo @/ur/bin/pwd
no file matching pattern /ur for selection /ur/bin/pwd
$echo @test_main.cc
no file matching pattern test_main.cc
$se {se {.for @e*c {echo $1}} >test_files/tmp}
$.global LC_ALL C
$.nop $LC_ALL
$sort test_files/tmp
added sort to executable map in test suite
executable.cc
executable_map.cc
this sort function has been brought to you by .autofunction
$whence sort
.function_all_flags sort -- [args ...] {
      /usr/bin/sort $args$
      echo this sort function has been brought to you by .autofunction}
$echo @test_files/*xx
test_files/ixxx
$echo @test_files/*x*x*x*x
no file matching pattern test_files/*x*x*x*x
$echo @test_files/*xyxy
test_files/ixyxyxy
$echo @/bin
/bin
$se {se {.for @/usr/*bin {echo $1}} >test_files/tmp}
$sort test_files/tmp
/usr/bin
/usr/sbin
this sort function has been brought to you by .autofunction
$se {se {.for @/etc/rwsh* {echo $1}} >test_files/tmp}
$sort test_files/tmp
/etc/rwshrc
/etc/rwshrc-basic
/etc/rwshrc-default
this sort function has been brought to you by .autofunction
$echo @/etc/rw*ic
/etc/rwshrc-basic
$echo @/etc/rwsh*a*
/etc/rwshrc-basic /etc/rwshrc-default
$.set FIGNORE rwshrc* rwshrc-bas rwshrc-default
$echo @/etc/rwshrc-*
/etc/rwshrc-basic
$echo @/etc/rwshrc*
/etc/rwshrc-basic /etc/rwshrc
$echo @/etc/rwshr*
no file matching pattern /etc/rwshr*
$.set FIGNORE *.cc
$echo @*cc
no file matching pattern *cc
$echo @*h.cc
rwsh.cc
$.set FIGNORE *de*
$echo @/etc/rwshrc-defa*
/etc/rwshrc-default
$echo @/etc/rwshrc-d*
no file matching pattern /etc/rwshrc-d*
$echo @/etc/rwsh*a*
/etc/rwshrc-basic
$echo @test_files/*i*x*y*y*x*
test_files/ixyxyxy
$echo @/etc/rw*-basi*si*
no file matching pattern /etc/rw*-basi*si*
$echo @test_main.sh
test_main.sh
$se {se {.for @test_files/*x* {echo $1}} >test_files/tmp}
$sort test_files/tmp
test_files/ixxx
test_files/ixyxyxy
this sort function has been brought to you by .autofunction
$.scope r*h.cc sel*.h (A ...) {echo @$A}
rwsh.cc selection.h
$
$# Arg_spec::REFERENCE, interpret(), evaluate_expansion(), evaluate_var()
$.nop $A
$.set A /bin
$.global B ( (zero   zero) ((one one  ) one   ) two three)
$.global C ((external) () ( ) internal(parenthesis))
$.global broken (extra_close\) \(extra_open)
$echo $A $0 @$A
/bin echo /bin
$echo A $1 1 $$3 $$$3
A A 1 A /bin
$echo A $1a
optional variable 1a was not defined
call stack:
$echo A 1 2 3 4 5 6 7 $$$$$$$$$8
A 1 2 3 4 5 6 7 /bin
$sa $UNDECLARED $ALSO_UNDECLARED {}
UNDECLARED was not declared
call stack:
$sa {echo $UNDECLARED $ALSO_UNDECLARED}
args was not checked with call stack .scope sa
UNDECLARED was not declared
call stack: .scope sa
$echo &UNDECLARED &ALSO_UNDECLARED
UNDECLARED was not declared
call stack:
$.scope [undefined] {echo $undefined and also unchecked}
undefined was not checked with call stack .scope
optional variable undefined was not defined
call stack: .scope
$.scope [udef] {echo but $udef$ can vanish}
but can vanish
$.scope ([-x foo bar]) {echo along with specific $-x$ flags}
along with specific flags
$.scope ([-x foo bar]) {echo note even one $bar$ prevents an error}
note even one prevents an error
$.scope [also_undefined] {echo even &&also_undefined$ in a soon}
even in a soon
$.scope undeclared ([leading_ud] ref) {echo references $$ref$ can throw}
leading_ud was not checked with call stack .scope
undeclared was not declared
call stack: .scope
$.scope leading_ud ([leading_ud] ref) {echo good $$ref$ ones are checked}
good ones are checked
$sa $B$$1x {echo $# $args$}
$$1x is not a valid word selection
call stack
$sa $B$$1$ {echo $# $args$}
$$1$ is not a valid word selection
call stack
$sa $B {e $# $args$ $nl}
2  (zero   zero) ((one one  ) one   ) two three 
$sa $B$ {e $# $args$ $nl}
5 zero   zero (one one  ) one    two three 
$sa $B$$ {e $# $args$ $nl}
7 zero zero one one   one two three 
$sa $B$$$$ {echo $# $args$}
8 zero zero one one one two three
$se {sa $B$$$$ {echo $# $args$}}
8 zero zero one one one two three
$sa $B$10 {echo $# $args$}
optional variable $B$10 was not defined
call stack:
$sa $B$1 {e $# $args$ $nl}
2 (one one  ) one    
$sa $B$$1 {echo $# $args$}
2 zero
$om $broken {e $# $* $nl}
2 extra_close) (extra_open 
$sa $broken$ {echo $# $args$}
signal triggered: .mismatched_parenthesis ( extra_close) )
mismatched parenthesis: extra_close)
call stack:
$sa $broken$$ {echo $# $args$}
signal triggered: .mismatched_parenthesis ( extra_close) )
mismatched parenthesis: extra_close)
call stack:
$sa $C {e $# $args$ $nl}
2 (external) () ( ) internal(parenthesis) 
$sa $C$ {e $# $args$ $nl}
5 external    internal(parenthesis) 
$sa $C$$ {echo $# $args$}
3 external internal(parenthesis)
$
$# Arg_spec::SOON, apply()
$echo A &1 1 &$3 &$$3
A A 1 A /bin
$echo &&A
&&A attempts to substitute after the command has been run
$se {e &&&A}
&&&A attempts to substitute after the command has been run
$se {@{} e &&&without$A $.{mismatched} {.argfunction brace} &&&{thrown}B
}
@ is neither an argfunction nor a substitution nor a brace literal
$A is not a valid word selection
call stack
&&&without$A attempts to substitute after the command has been run
$. is neither an argfunction nor a substitution nor a brace literal
cannot specify arguments for (.argfunction brace!) directly
(B
) is not a valid word selection
call stack
(&&&{thrown}B
) attempts to substitute after the command has been run
$echo &{e &&A}
&&A attempts to substitute after the command has been run
$echo &&{e &A}
(&&{e &A}) attempts to substitute after the command has been run
$echo &A
/bin
$.scope not_bin A {e &A &&A $A $nl; .scope otherwise A {echo &A &&A &&&A $A}}
/bin not_bin not_bin 
/bin not_bin otherwise otherwise
$se {sa &B$10 {e $# $args$}}
optional variable &B$10 was not defined
call stack:
$se {sa &B$$$$ {echo $# $args$}}
8 zero zero one one one two three
$se {sa &B$1 {e $# $args$} $nl}
3 (one one  ) one    
$se {sa &B$$1 {echo $# $args$}}
2 zero
$
$# Arg_spec::SUBSTITUTION and Arg_spec::SOON_SUBSTITUTION, apply(), interpret(),
$# evaluate_substitution()
$echo ${e $A}
/bin
$whence .argfunction {e ${e $A}}
{e ${e $A}}
$.scope not_bin A {
   e &{.echo $A} &&{.echo $A} $A $nl
   .scope otherwise A {
      echo &{.echo $A} &&{.echo $A} &&&{.echo $A} ${.echo $A} $A}}
/bin not_bin not_bin 
/bin not_bin otherwise otherwise otherwise
$.scope not_bin A {e &{.echo &A $A} &&{.echo &A &&A} ${.echo &A $A} $nl}
/bin /bin /bin not_bin /bin not_bin 
$sa &{.echo $A} {echo $args &1$}
/bin &{.echo $A}
$sa &{.throw .nop} {}
substitution (&{.throw .nop}) failed
$sa ${.throw .nop} {}
substitution (${.throw .nop}) failed
$se {e &{.throw .nop}}
substitution (&{.throw .nop}) failed
$se {e &&{.throw .nop}; e after}
substitution (&{.throw .nop}) failed
call stack: .scope se
$se {e &&{.throw .nop}; e after}
substitution (&{.throw .nop}) failed
call stack: .scope se
$.collect_errors_except .nop {
  ${.throw echo exception from inside substitution}
  echo after failed substitution}
after failed substitution
exception from inside substitution .throw .mapped_argfunction .collect_errors_except
substitution (${.throw echo exception from inside substitution}) failed
call stack: .collect_errors_except
$.collect_errors_only .failed_substitution echo {
  ${.throw echo exception from inside substitution}
  echo after failed substitution}
after failed substitution
exception from inside substitution .throw .mapped_argfunction .collect_errors_only
substitution (${.throw echo exception from inside substitution}) failed
call stack: .collect_errors_only
$.collect_errors_only .nop {
  ${.throw echo exception from inside substitution}
  echo after failed substitution}
exception from inside substitution .throw .mapped_argfunction .collect_errors_only
substitution (${.throw echo exception from inside substitution}) failed
call stack: .collect_errors_only
$echo before .{argfunction} between [.{argfunction}] after
before .{argfunction} between [.{argfunction}] after
$echo before ..{still bad} between [.{missing close} after
.. is neither an argfunction nor a substitution nor a brace literal
mismatched bracket: ([.{missing close})
$echo x{e bad argfunction style}
x is neither an argfunction nor a substitution nor a brace literal
$e x&&&{e x}
x&&& is neither an argfunction nor a substitution nor a brace literal
$e $+{e x}
$+ is neither an argfunction nor a substitution nor a brace literal
$e &+{e x}
&+ is neither an argfunction nor a substitution nor a brace literal
$e &&${e x}
&&$ is neither an argfunction nor a substitution nor a brace literal
(&&${e x}) attempts to substitute after the command has been run
$echo ${e 0 $nl}
(0 
)
$echo &{.echo 0}
0
$.echo nevermore &{/bin/echo quoth the raven} 
nevermore quoth the raven
$sa ${e $B}$@1 ${e $B}$1 ${e $B}XYZ {echo $# $args$}
@1 is not a valid word selection
call stack
XYZ is not a valid word selection
call stack
$sa ${e $B} {e $# $args$ $nl}
2  (zero   zero) ((one one  ) one   ) two three 
$sa &{e $B} {e $# $args$ $nl}
2  (zero   zero) ((one one  ) one   ) two three 
$sa ${e $B}$ {e $# $args$ $nl}
5 zero   zero (one one  ) one    two three 
$sa &{e $B}$ {e $# $args$ $nl}
5 zero   zero (one one  ) one    two three 
$e $# &{.echo $B}$ $nl
4 zero   zero (one one  ) one    two three 
$se {e $# &{e $B}$ $nl}
1 zero   zero (one one  ) one    two three 
$sa &{e $B}$$ {e $# $args$ $nl}
7 zero zero one one   one two three 
$sa ${e $B}$$ {e $# $args$ $nl}
7 zero zero one one   one two three 
$se {sa ${e $B}$1 {e $# $args$ $nl}}
2 (one one  ) one    
$se {sa &{e $B}$1 {.echo $# $args$ $nl}}
2 (one one  ) one    
$se {sa ${e $B}$$$1 {echo $# $args$}}
2 zero
$se {sa &{e $B}$$$1 {echo $# $args$}}
2 zero
$.unset A
$.unset B
$sa &{e ((zero zero) (one one) two three)}$10 {echo $# $args$}
optional variable (&{e ((zero zero) (one one) two three)}$10) was not defined
call stack:
$sa ${e (zero zero) \)one one two three}$1 {echo $# $args$}
signal triggered: .mismatched_parenthesis ( zero zero ) )
mismatched parenthesis: (zero zero ))
call stack:
$sa &{e (zero zero) \(one one two three}$1 {echo $# $args$}
signal triggered: .mismatched_parenthesis ( zero zero (one one two three )
mismatched parenthesis: (zero zero (one one two three)
call stack:
$om ${e (zero zero) \)one one two three} {e $# $* $nl}
2 zero zero )one one two three 
$c x &{.echo (y y)}$ x $nl
xyyx
$c x ${.echo ( y y )}$ x $nl
xyyx
$c x &{.echo (( y) (y ))}$ x $nl
x yy x
$c x ${.echo (    )}$ x $nl
xx
$c x &{.echo (
y
y
)}$ x $nl
xyyx
$
$# file redirection (but don't overwrite files that exist)
$# .for_each_line
$/bin/cat <non_existent_file
could not open file non_existent_file
call stack /bin/cat
$.for_each_line <non_existent_file {echo line of $# \( $* \)}
could not open file non_existent_file
call stack .for_each_line
$se {sa {echo hi >one >two} {cat <three <four}
}
double redirection is not supported at this time: >one and >two
multiple argfunctions not supported at this time
double redirection is not supported at this time: <three and <four
$se {
  .if .test_file_exists outfile {echo failed to remove outfile}
  .else {echo outfile properly removed}}
outfile properly removed
$se {echo hi >outfile}
$/bin/cat outfile
hi
$se {
  .if .test_is_number 0 {>outfile /bin/echo there}
  .else {.nop}}
$/bin/cat outfile
there
$se {se >outfile {e line 1 $nl; e line 2 longer $nl; .echo $nl; echo ending}}
$/bin/cat <outfile
line 1 
line 2 longer 

ending
$.for_each_line x {}
unacceptable argument count: received 1 non-optional, but needed 0 (with 0 optional) for .for_each_line
$.for_each_line <outfile
.for_each_line requires an argfunction
$.for_each_line <outfile <another A{}
double redirection is not supported at this time: <outfile and <another
A is neither an argfunction nor a substitution nor a brace literal
$.for_each_line <outfile {
  echo current line $*
  if_only .test_greater $2 1 {
    .collect_errors_except .nop {
      .throw .continue
      .throw .break
      .throw .continue}}
  .throw .continue
  echo not printed}
current line line 1
current line line 2 longer
$.for_each_line <outfile {
  e line of $# \( $* \) $nl; .throw echo exception in for_each_line}
line of 3 ( line 1 ) 
exception in for_each_line .throw .mapped_argfunction .for_each_line
$.for_each_line <outfile {e line of $# \( $* \) $nl}
line of 3 ( line 1 ) 
line of 4 ( line 2 longer ) 
line of 1 ( ) 
line of 2 ( ending ) 
$/bin/rm outfile
$
$# soon level promotion
$.global A 0
$.global OLD_NESTING ${.get_max_nesting}
$.set_max_nesting 46
$fn x {.var_add A 1
     se {.var_add A 1
        se {.var_add A 1
           se {.var_add A 1
              se {.var_add A 1
                 se {.argfunction}}}}}}
$.scope 00 A {x {echo &A &&A &&&A $A}}
0 00 5 5
$.scope 00 A {x {x {x {x {echo &A &&A &&&A &&&&A &&&&&A &&&&&&A $A}}}}}
0 00 5 10 15 20 20
$.scope 00 A {
  x {e &{.echo &A $A} . &&{.echo &A &&A $A} . &&&{.echo &A &&A &&&A $A} . ${
  .echo &A &&A &&&A $A} . $A $nl}}
0 0 . 0 00 00 . 0 00 5 5 . 0 00 5 5 . 5 
$.set A 0
$x {x {x {x {
  e &{.echo &A $A} . &&{.echo &A &&A $A} . &&&{.echo &A &&A &&&A $A} . &&&&{
  .echo &A &&A &&&A &&&&A $A} . &&&&&{.echo &A &&A &&&A &&&&A &&&&&A $A} . ${
  .echo &A &&A &&&A &&&&A &&&&&A $A} . $A $nl}}}}
0 0 . 0 5 5 . 0 5 10 10 . 0 5 10 15 15 . 0 5 10 15 20 20 . 0 5 10 15 20 20 . 20 
$.rm_executable x
$.function_all_flags not soon {&&&enough}
&&&enough attempts to substitute after the command has been run
$.set_max_nesting $OLD_NESTING
$.unset A
$.unset OLD_NESTING
$
$## builtin tests
$# .argc
$.argc {excess argfunc}
.argc does not accept an argfunction with call stack: .argc
$.scope () {.argc; .echo $nl}
0
$.scope () {.argc (); .echo $nl}
1
$.scope () {.argc (1 a) (2 b (c d)) (3 ((e () f))); .echo $nl}
3
$
$# .cd (.which_path ../)
$.cd
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .cd
$.cd /bin {excess argfunc}
.cd does not accept an argfunction with call stack: .cd
$.cd /bin /
unacceptable argument count: received 2 non-optional, but needed 1 (with 0 optional) for .cd
$.cd /bn
/bn directory does not exist
call stack .cd
$.cd /bin/rwsh
/bin/rwsh is not a directory
call stack .cd
$.fork .mapped_argfunction {
  .try_catch_recursive .binary_not_found {.which_path ../bin/rwsh /bin:.}
  .cd /bin
  .binary /bin/pwd
  echo directory is now ${/bin/pwd}$ in subshell
  .try_catch_recursive .binary_not_found {.which_path ../bin/rwsh /bin}
  .try_catch_recursive .binary_not_found {.which_path ../bin/rwsh /bin:.}
  .combine $nl}
../bin/rwsh : binary not found in /bin:.
call stack: .which_path .try_catch_recursive(body)
directory is now /bin in subshell
../bin/rwsh : binary not found in /bin
call stack: .which_path .try_catch_recursive(body)
../bin/rwsh
$
$# .combine
$.combine
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .combine
$.combine something {excess argfunc}
.combine does not accept an argfunction with call stack: .combine
$.combine on () e \ two ( ) $# $nl
one two 8
$
$# .echo .error
$.error
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .error
$.error something {excess argfunc}
.error does not accept an argfunction with call stack: .error
$.nop .error cannot test error with a diff until you can redirect it $nl
$.echo
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .echo
$.echo something {excess argfunc}
.echo does not accept an argfunction with call stack: .echo
$.echo these are fixed strings $nl
these are fixed strings 
$
$# .exec .fork Binary Old_argv_t .binary_not_found
$.fork
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .fork
$.fork echo text
text
$.fork .exit 127
.fork returned 127 : call stack .fork
$.fork sa 126 {sa $args$ {echo about to return $args$; .exit $args$}}
about to return 126
.fork returned 126 : call stack .fork
$.exec
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .exec
$.exec something {excess argfunc}
.exec does not accept an argfunction with call stack: .exec
$.exec /bin/ech does not exist
/bin/ech : binary does not exist
call stack: .exec
$.exec /etc/rwshrc-default config files are not interpreters
/etc/rwshrc-default is not executable
call stack: .exec
$.exec /bin cannot exec a directory
/bin is not executable
call stack: .exec
$.exec /bin/rwsh/insanity errno is ENOTDIR
.exec failed for /bin/rwsh/insanity with errno 20
call stack .exec
$.fork se {.exec /bin/rwsh/insanity errno is ENOTDIR}
.exec failed for /bin/rwsh/insanity with errno 20
call stack (.exec .scope se)
.fork returned 255 : call stack .fork
$.fork se {.exec /bin/echo something; /bin/echo else}
something
$.scope () {.fork se {.exec /bn/echo 1 2 3}}
/bn/echo : binary does not exist
call stack: (.exec .scope se)
.fork returned 255 : call stack .fork .scope
$.fork se {/bn/echo 1 2 3}
/bn/echo : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction .scope se
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction .scope se
/bn/echo : command not found ( /bn/echo 1 2 3 .scope se )
.fork returned 255 : call stack .fork
$.last_exception /bn/echo
/bn/echo : command not found ( /bn/echo .last_exception )
$.exec /bn/echo 1 2 3
/bn/echo : binary does not exist
call stack: .exec
$/bn/echo 1 2 3
/bn/echo : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction
/bn/echo : command not found ( /bn/echo 1 2 3 )
$.last_exception /bn/echo
/bn/echo : command not found ( /bn/echo .last_exception )
$.fork se {/bn/echo 1 2 3}
/bn/echo : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction .scope se
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction .scope se
/bn/echo : command not found ( /bn/echo 1 2 3 .scope se )
.fork returned 255 : call stack .fork
$.fork .exec /bn/echo 1 2 3
/bn/echo : binary does not exist
call stack: .exec
.fork returned 255 : call stack .fork
$/bn/echo 1 2 3
/bn/echo : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction
/bn/echo : command not found ( /bn/echo 1 2 3 )
$.exec /bn/echo 1 2 3
/bn/echo : binary does not exist
call stack: .exec
$/bin/echo 1 2 3
1 2 3
$
$# .fallback_handler .get_fallback_message .set_fallback_message
$.fallback_handler
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .fallback_handler
$.fallback_handler something {excess argfunc}
Exception for failed handler. Original exception with call stack:
something
$.get_fallback_message something 
unacceptable argument count: received 1 non-optional, but needed 0 (with 0 optional) for .get_fallback_message
$.get_fallback_message {excess argfunc}
.get_fallback_message does not accept an argfunction with call stack: .get_fallback_message
$.set_fallback_message
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .set_fallback_message
$.set_fallback_message something {excess argfunc}
.set_fallback_message does not accept an argfunction with call stack: .set_fallback_message
$.fallback_handler pretend_error
Exception for failed handler. Original exception with call stack:
pretend_error
$.local original_message &{.get_fallback_message}
$.set_fallback_message spaceless fallback message
$.fallback_handler second pretend error
spaceless fallback messagesecond pretend error
$.set_fallback_message (alternate fallback message: )
$.fallback_handler a third
alternate fallback message: a third
$.set_fallback_message $original_message
$.throw sa .throw {echo even from $args$ 7 is a number}
even from .throw .throw 7 is a number
$.fallback_handler .throw sa .throw {echo even from $args$ 7 is a number}
Exception for failed handler. Original exception with call stack:
.throw sa .throw
$.throw .throw sa {echo even from $args$ 7 is a number}
Exception for failed handler. Original exception with call stack:
.throw sa .throw
even from .throw .throw 7 is a number
$
$# .for
$.for {echo no arguments $1}
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .for
$.for no_argfunction
.for requires an argfunction
$.for 1 {echo one argument $1}
one argument 1
$.for 1 2 {echo one argument $1; .throw echo exception in for}
one argument 1
exception in for .throw .mapped_argfunction .for
$.for 1 2 3 4 {
  echo current arg $1
  if_only .test_greater $1 2 {
    .collect_errors_except .nop {
      .throw .continue
      .throw .break
      .throw .continue}}
  .throw .continue
  echo not printed}
current arg 1
current arg 2
current arg 3
$fn fIJ outer inner {
  .local sum 0
  .nop $sum
  $outer I 1 2 3 4 5 6 {
    if_only_not .test_string_equal $I 1 {.combine $nl}
    .combine $I :
    $inner J 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 {
      if_only .test_less 1 $J {.echo ,}
      .echo $J
      .set sum ${+ $I $J}
      .if .test_less 5 $sum$ {.throw outer_break}
      .else_if .test_less 3 $sum$ {.throw outer_continue}
      .else {}}}
  .echo $nl}
$fIJ scope_for scope_for
1:1,2,3Exception for failed handler. Original exception with call stack:
outer_continue .throw .mapped_argfunction .else_if .scope .mapped_argfunction .for scope_for .scope .mapped_argfunction .for scope_for fIJ
.continue thrown outside of control flow body
call stack: .throw .mapped_argfunction .else_if .scope .mapped_argfunction .for scope_for .scope .mapped_argfunction .for scope_for fIJ .replace_exception outer_continue
$fIJ outer_for scope_for
1:1,2,3
2:1,2
3:1
4:1
5:1
$fIJ scope_for outer_for
1:1,2,3,4,5
2:1,2,3,4
3:1,2,3
4:1,2
5:1
6:1
$fIJ outer_for outer_for
1:1,2,3,4,5
2:1,2,3,4
3:1,2,3
4:1,2
5:1
6:1
$.for 1 2 3 4 {e four arguments $1 $nl}
four arguments 1 
four arguments 2 
four arguments 3 
four arguments 4 
$
$# .function_all_flags .rm_executable
$.function_all_flags
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .function_all_flags
$.function_all_flags missing argfunction
.function_all_flags requires an argfunction
$.rm_executable {excess argfunction}
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .rm_executable
.rm_executable does not accept an argfunction with call stack: .rm_executable
$.function_all_flags .exit {.nop}
$.exit cannot be a function
call stack .function_all_flags
$.function_all_flags .escaped_argfunction {.nop}
$.escaped_argfunction cannot be a function
call stack .function_all_flags
$.rm_executable a
a : command not found ( a .rm_executable )
$.function_all_flags a {.nop}
$.whence_function a
.function_all_flags a  {.nop}
$a 1 2 3
unacceptable arguments: for prototype ,
 found (1 2 3) excess
( call) stack: a
$.rm_executable a
$.whence_function a
a : command not found ( a .whence_function )
$.global A \
$.echo () A () A () $# $nl
 A  A  8 
$.function_all_flags a arg {e 9 $A $arg @/usr $nl}
$.whence_function a
.function_all_flags a arg {e 9 $A $arg @/usr $nl}
$a \
9   /usr 
$a 1
9  1 /usr 
$a 1 2
unacceptable arguments: for prototype arg,
 assigned arg=1 ,
 but found (2) excess
( call) stack: a
$.function_all_flags a [args ...] {.nop $args$; e $*5 $* $*0 $nl}
$a
a 
$a 1
1 a 1 
$a 1 2
1 2 a 1 2 
$fn g name {.function_all_flags $name name {
  .function_all_flags $name {.argfunction}}}
$g a {e 3 2 1 $nl}
$whence a
.function_all_flags a name {
  .function_all_flags $name {e 3 2 1 $nl}}
$a b
$b
3 2 1 
$# a function redefining itself doesn't seg fault
$fn g {e hi $nl; fn g {e there $nl}; fn h {e nothing here}; g}
$g
hi 
there 
$.function_all_flags
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .function_all_flags
$.function_all_flags .exit {e cannot redefine a builtin as a function}
$.exit cannot be a function
call stack .function_all_flags
$.function_all_flags .a {can define a function for non-existant builtin}
$.function_all_flags .argfunction {e cannot define .argfunction}
$.argfunction cannot be a function
call stack .function_all_flags
$.function_all_flags a y y {e illegal duplicate required parameter}
duplicated parameter in function definition: y
call stack: .function_all_flags
$.function_all_flags a [-x] [-x] {e illegal duplicate flag parameter}
duplicated parameter in function definition: -x
call stack: .function_all_flags
$.function_all_flags a [x x] {e illegal duplicate optional parameter}
duplicated parameter in function definition: x
call stack: .function_all_flags
$.function_all_flags a [-x arg bar] [-y arg] {e illegal duplicate flag argument}
duplicated parameter in function definition: arg
call stack: .function_all_flags
$.function_all_flags a -x [-x] {e evil duplication between flags positional}
duplicated parameter in function definition: -x
call stack: .function_all_flags
$.function_all_flags a -- -- {e -- cannot be a duplicate parameter}
duplicated parameter in function definition: --
call stack: .function_all_flags
$.function_all_flags a [--] [--] {e [--] cannot be a duplicate parameter}
duplicated parameter in function definition: --
call stack: .function_all_flags
$.function_all_flags a [--] -- {e -- and [--] cannot both be parameters}
duplicated parameter in function definition: --
call stack: .function_all_flags
$.function_all_flags a [-- arg] {e -- cannot take arguments}
optional -- parameter cannot take arguments ( ([-- arg]) ) with call stack: .function_all_flags
$.function_all_flags a [arg -- foo] {e -- cannot take arguments}
optional -- parameter cannot take arguments ( ([arg -- foo]) ) with call stack: .function_all_flags
$.rm_executable nonsense
nonsense : command not found ( nonsense .rm_executable )
$whence test_var_greater
.function_all_flags test_var_greater -- var value {.test_greater $$var $value}
$.scope 5 n {test_var_greater n}
unacceptable arguments: for prototype -- var value,
 assigned var=n ,
 but needed (value),
( call) stack: (test_var_greater .scope)
n was unused with call stack .scope
$.scope 5 n {test_var_greater n 3 12}
unacceptable arguments: for prototype -- var value,
 assigned value=3 var=n ,
 but found (12) excess
( call) stack: (test_var_greater .scope)
n was unused with call stack .scope
$.scope 5 n {test_var_greater n 3}
$whence ntimes
.function_all_flags ntimes n {
  .while test_var_greater n 0 {
    .mapped_argfunction {.argfunction}
    .var_subtract n 1}}
$ntimes -- 3 {e $n remaining $nl}
3 remaining 
2 remaining 
1 remaining 
$ntimes 2 {ntimes 3 {e &&n and $n remaining $nl}}
2 and 3 remaining 
2 and 2 remaining 
2 and 1 remaining 
1 and 3 remaining 
1 and 2 remaining 
1 and 1 remaining 
$.function_all_flags a [-x] [-] [--long-opt y second {
  e mismatched bracket (i.e. missing close brakcet)}
mismatched bracket: ([--long-opt y second)
call stack: .function_all_flags
$.function_all_flags a [-?] [--] {.list_locals}
[-?] [--] is an ambiguous location for a prototype -- (it requests reading the user's mind) (stack:.function_all_flags)
$.function_all_flags a [-x] [--] foo {.list_locals}
[-x] [--] is an ambiguous location for a prototype -- (it requests reading the user's mind) (stack:.function_all_flags)
$.function_all_flags a [-?] -- foo {.list_locals}
[-?] -- is an ambiguous location for a prototype -- (it requests reading the user's mind) (stack:.function_all_flags)
$.function_all_flags a [-x] -- {.list_locals}
[-x] -- is an ambiguous location for a prototype -- (it requests reading the user's mind) (stack:.function_all_flags)
$.function_all_flags a [--] {.list_locals; .echo $nl}
$whence a
.function_all_flags a [--] {.list_locals; .echo $nl}
$a

$a --
--
$a foo
unacceptable arguments: for prototype [--],
 found (foo) excess
( call) stack: a
$.function_all_flags a [-x] [--long-opt y] second {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }; .echo $nl}
$whence a
.function_all_flags a [--long-opt y] [-x] second {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}; .echo $nl}
$a
unacceptable arguments: for prototype [--long-opt y] [-x] second,
 assigned -*=() ,
 but needed (second),
( call) stack: a
$a single
-*() second(single) 
$a -x single
-*(-x) -x(-x) second(single) 
$a --long-opt arg single
-*(--long-opt arg) --long-opt(--long-opt arg) second(single) y(arg) 
$a --long-opt single
unacceptable arguments: for prototype [--long-opt y] [-x] second,
 assigned -*=(--long-opt single) --long-opt=(--long-opt single) y=single ,
 but needed (second),
( call) stack: a
$a --long-opt first -x --long-opt second single
-*(--long-opt first -x --long-opt second) --long-opt(--long-opt first --long-opt second) -x(-x) second(single) y(first second) 
$.function_all_flags a [-q option1 option2] [-x o1 o2 o3 o4] required {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }; .echo $nl}
$whence a
.function_all_flags a [-q option1 option2] [-x o1 o2 o3 o4] required {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}; .echo $nl}
$a
unacceptable arguments: for prototype [-q option1 option2] [-x o1 o2 o3 o4] required,
 assigned -*=() ,
 but needed (required),
( call) stack: a
$a single
-*() required(single) 
$a -q one two
unacceptable arguments: for prototype [-q option1 option2] [-x o1 o2 o3 o4] required,
 assigned -*=(-q one two) -q=(-q one two) option1=one option2=two ,
 but needed (required),
( call) stack: a
$a -q opt and req
-*(-q opt and) -q(-q opt and) option1(opt) option2(and) required(req) 
$a -x opt and
unacceptable arguments: for prototype [-q option1 option2] [-x o1 o2 o3 o4] required,
 assigned -*=(-x opt and) -x=(-x opt and) o1=opt o2=and ,
 but needed (o3 o4 required),
( call) stack: a
$a -x first second third fourth req
-*(-x first second third fourth) -x(-x first second third fourth) o1(first) o2(second) o3(third) o4(fourth) required(req) 
$a -q one two -q three four five
-*(-q one two -q three four) -q(-q one two -q three four) option1(one three) option2(two four) required(five) 
$a -x one two three four -q five six seven
-*(-x one two three four -q five six) -q(-q five six) -x(-x one two three four) o1(one) o2(two) o3(three) o4(four) option1(five) option2(six) required(seven) 
$a -x one two three four five -q six seven
-*(-x one two three four -q six seven) -q(-q six seven) -x(-x one two three four) o1(one) o2(two) o3(three) o4(four) option1(six) option2(seven) required(five) 
$a one -x two three four five -q six seven
-*(-x two three four five -q six seven) -q(-q six seven) -x(-x two three four five) o1(two) o2(three) o3(four) o4(five) option1(six) option2(seven) required(one) 
$.function_all_flags a [optional0] -- [optional1 optional2 optional3] required {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }; .echo $nl}
$whence a
.function_all_flags a [optional0] -- [optional1 optional2 optional3] required {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}; .echo $nl}
$a
unacceptable arguments: for prototype [optional0] -- [optional1 optional2 optional3] required,
 needed (required),
( call) stack: a
$a single
required(single) 
$a one two
optional0(one) required(two) 
$a one two three
unacceptable arguments: for prototype [optional0] -- [optional1 optional2 optional3] required,
 assigned optional0=one optional1=two optional2=three ,
 but needed (optional3 required),
( call) stack: a
$a one two three four five
optional0(one) optional1(two) optional2(three) optional3(four) required(five) 
$a one two three four five six seven eight nine
unacceptable arguments: for prototype [optional0] -- [optional1 optional2 optional3] required,
 assigned optional0=one optional1=two optional2=three optional3=four required=five ,
 but found (six seven eight nine) excess
( call) stack: a
$.function_all_flags a -y [second] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }; .echo $nl}
$whence a
.function_all_flags a -y [second] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}; .echo $nl}
$a
unacceptable arguments: for prototype -y [second],
 needed (-y),
( call) stack: a
$a 1
-y(1) 
$a 1 2
-y(1) second(2) 
$a 1 2 3
unacceptable arguments: for prototype -y [second],
 assigned -y=1 second=2 ,
 but found (3) excess
( call) stack: a
$.function_all_flags a [-x] -y [--long-opt] second [--] [-] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }; .echo $nl}
$whence a
.function_all_flags a [--long-opt] [-x] -y second [--] [-] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}; .echo $nl}
$a --long-opt -xx over-long flag
-xx flag is unrecognized for a
call stack: a
$a -xx --long-opt over-long flag
-xx flag is unrecognized for a
call stack: a
$a --long-op short flag
--long-op flag is unrecognized for a
call stack: a
$a - --long-op short flag
--long-op flag is unrecognized for a
call stack: a
$a no flags
-*() -y(no) second(flags) 
$a deficient
unacceptable arguments: for prototype [--long-opt] [-x] -y second [--] [-],
 assigned -*=() -y=deficient ,
 but needed (second),
( call) stack: a
$a flagless but_has excess argument
unacceptable arguments: for prototype [--long-opt] [-x] -y second [--] [-],
 assigned -=excess -*=() -y=flagless second=but_has ,
 but found (argument) excess
( call) stack: a
$a -x with flag
-*(-x) -x(-x) -y(with) second(flag) 
$a -x -x doubled flag
-*(-x -x) -x(-x -x) -y(doubled) second(flag) 
$a accepted -x interlaced_flag -
-(-) -*(-x) -x(-x) -y(accepted) second(interlaced_flag) 
$a tardy flags_last - -x
-x flag comes too late in command
call stack: a
$a -x -- - flag_made_fixed_argument
-*(-x --) --(--) -x(-x) -y(-) second(flag_made_fixed_argument) 
$a -- - flag_again_made_fixed_argument
-*(--) --(--) -y(-) second(flag_again_made_fixed_argument) 
$a -x -- flag_and_fixed-x -x
-*(-x --) --(--) -x(-x) -y(flag_and_fixed-x) second(-x) 
$a -x just flags-x --long-opt
--long-opt flag comes too late in command
call stack: a
$a -x just flags-x -- --long-opt
-(--long-opt) -*(-x --) --(--) -x(-x) -y(just) second(flags-x) 
$a -x just flags-x --other
--other flag comes too late in command
call stack: a
$a -x just flags-x -- --other
-(--other) -*(-x --) --(--) -x(-x) -y(just) second(flags-x) 
$a -x with one excess argument
unacceptable arguments: for prototype [--long-opt] [-x] -y second [--] [-],
 assigned -=excess -*=-x -x=-x -y=with second=one ,
 but found (argument) excess
( call) stack: a
$a - with flag
-(flag) -*() -y(-) second(with) 
$a --long-opt with flag
-*(--long-opt) --long-opt(--long-opt) -y(with) second(flag) 
$a --long-opt -x - some_flags in_order
-(in_order) -*(--long-opt -x) --long-opt(--long-opt) -x(-x) -y(-) second(some_flags) 
$a - -x --long-opt some_flags reversed
-(reversed) -*(-x --long-opt) --long-opt(--long-opt) -x(-x) -y(-) second(some_flags) 
$a - --long-opt some_flags in_order
-(in_order) -*(--long-opt) --long-opt(--long-opt) -y(-) second(some_flags) 
$a --long-opt - some_flags reversed
-(reversed) -*(--long-opt) --long-opt(--long-opt) -y(-) second(some_flags) 
$a -x --long-opt some_flags in_order
-*(-x --long-opt) --long-opt(--long-opt) -x(-x) -y(some_flags) second(in_order) 
$a --long-opt -x some_flags reversed
-*(--long-opt -x) --long-opt(--long-opt) -x(-x) -y(some_flags) second(reversed) 
$a -x --long-opt deficient
unacceptable arguments: for prototype [--long-opt] [-x] -y second [--] [-],
 assigned -*=(-x --long-opt) --long-opt=--long-opt -x=-x -y=deficient ,
 but needed (second),
( call) stack: a
$a -x - --long-opt all_flags in_order
-(in_order) -*(-x --long-opt) --long-opt(--long-opt) -x(-x) -y(-) second(all_flags) 
$a --long-opt - -x all_flags reversed
-(reversed) -*(--long-opt -x) --long-opt(--long-opt) -x(-x) -y(-) second(all_flags) 
$a - --long-opt -x all_flags shuffled
-(shuffled) -*(--long-opt -x) --long-opt(--long-opt) -x(-x) -y(-) second(all_flags) 
$a - --long-opt -x -x some_flags doubled
-(doubled) -*(--long-opt -x -x) --long-opt(--long-opt) -x(-x -x) -y(-) second(some_flags) 
$a -x --long-opt -x --long-opt -x one_doubled one_tripled
-*(-x --long-opt -x --long-opt -x) --long-opt(--long-opt --long-opt) -x(-x -x -x) -y(one_doubled) second(one_tripled) 
$a --long-opt -x -x - --long-opt all_flags doubled
-(doubled) -*(--long-opt -x -x --long-opt) --long-opt(--long-opt --long-opt) -x(-x -x) -y(-) second(all_flags) 
$.function_all_flags a [-first] [-to] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }
  echo nothing_required}
$whence a
.function_all_flags a [-first] [-to] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}
  echo nothing_required}
$a
-*() nothing_required
$a excess
unacceptable arguments: for prototype [-first] [-to],
 assigned -*=() ,
 but found (excess) excess
( call) stack: a
$a -to
-*(-to) -to(-to) nothing_required
$a -first --
-*(-first --) --(--) -first(-first) nothing_required
$a -first excess
unacceptable arguments: for prototype [-first] [-to],
 assigned -*=-first -first=-first ,
 but found (excess) excess
( call) stack: a
$a -to -- -first -- stops flag parsing rather than being a flag
unacceptable arguments: for prototype [-first] [-to],
 assigned -*=(-to --) --=-- -to=-to ,
 but found (-first -- stops flag parsing rather than being a flag) excess
( call) stack: a
$a -to -first
-*(-to -first) -first(-first) -to(-to) nothing_required
$.function_all_flags a [-?] [-first] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }
  echo nothing_required}
$whence a
.function_all_flags a [-?] [-first] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}
  echo nothing_required}
$a
-*() -?() nothing_required
$a excess
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=() -?=() ,
 but found (excess) excess
( call) stack: a
$a -to
-*(-to) -?(-to) nothing_required
$a -first --
-*(-first --) --(--) -?() -first(-first) nothing_required
$a -first excess
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=-first -?=() -first=-first ,
 but found (excess) excess
( call) stack: a
$a -to -- -first
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=(-to --) --=-- -?=-to ,
 but found (-first) excess
( call) stack: a
$a -to -first
-*(-to -first) -?(-to) -first(-first) nothing_required
$.function_all_flags a [-*] [-first] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }
  echo nothing_required}
$whence a
.function_all_flags a [-?] [-first] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}
  echo nothing_required}
$a
-*() -?() nothing_required
$a -to -- -first
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=(-to --) --=-- -?=-to ,
 but found (-first) excess
( call) stack: a
$a -to -first
-*(-to -first) -?(-to) -first(-first) nothing_required
$.function_all_flags a [-?] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }
  echo nothing_required}
$whence a
.function_all_flags a [-?] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}
  echo nothing_required}
$a
-*() -?() nothing_required
$.function_all_flags a ... y {}
... elipsis cannot be the first argument in a prototype
call stack: .function_all_flags
$.function_all_flags a [-x] [--file file] ... y {}
... elipsis cannot be the first argument in a prototype
call stack: .function_all_flags
$.function_all_flags a [...] x {}
[...] elipsis cannot be the first argument in a prototype
call stack: .function_all_flags
$.function_all_flags a [... y] x {}
([... y]) elipsis cannot be the first argument in a prototype
call stack: .function_all_flags
$.function_all_flags a x ... [y z] {}
option ([y z]) coming after an elipsis has no meaning
call stack: .function_all_flags
$.function_all_flags a x [... y] z ... {}
duplicated parameter in function definition: ...
call stack: .function_all_flags
$.function_all_flags a [y z] ... x {}
([y z]) for elipsis to apply to option it must occur within the brackets
call stack: .function_all_flags
$.function_all_flags a [y] ... x {}
$whence a
.function_all_flags a [y ...] x {}
$.function_all_flags a x ... y ... {}
duplicated parameter in function definition: ...
call stack: .function_all_flags
$.function_all_flags a [x ...] [y z] {}
option ([y z]) coming after an elipsis has no meaning
call stack: .function_all_flags
$.function_all_flags a [x ...] y ... {}
duplicated parameter in function definition: ...
call stack: .function_all_flags
$.function_all_flags a [x ... a] [y] {}
option [y] coming after an elipsis has no meaning
call stack: .function_all_flags
$.function_all_flags a [x ... a] y ... {}
duplicated parameter in function definition: ...
call stack: .function_all_flags
$.function_all_flags a [x ... a ...] {}
duplicated parameter in function definition: ...
call stack: .function_all_flags
$.function_all_flags a [x ... a ... b] {}
duplicated parameter in function definition: ...
call stack: .function_all_flags
$.function_all_flags a [-x ...] b [c] {}
option [c] coming after an elipsis has no meaning
call stack: .function_all_flags
$.function_all_flags a -? x ... y {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }; .echo $nl}
$whence a
.function_all_flags a [-?] x ... y {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}; .echo $nl}
$a -c -a -b first second third
-*(-c -a -b) -?(-c -a -b) x(first second) y(third) 
$a -c first -a second -b third
found flag -a while collecting arguments for elipsis
call stack a
$.function_all_flags a -* x ... y {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }; .echo $nl}
$whence a
.function_all_flags a [-?] x ... y {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}; .echo $nl}
$a -c -a -b first second third
-*(-c -a -b) -?(-c -a -b) x(first second) y(third) 
$a -c first -a second -b third
found flag -a while collecting arguments for elipsis
call stack a
$.function_all_flags a [-?] x ... y {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }; .echo $nl}
$whence a
.function_all_flags a [-?] x ... y {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}; .echo $nl}
$a 
unacceptable arguments: for prototype [-?] x ... y,
 assigned -*=() -?=() ,
 but needed (x y),
( call) stack: a
$a first
unacceptable arguments: for prototype [-?] x ... y,
 assigned -*=() -?=() x=first ,
 but needed (y),
( call) stack: a
$a first (se cond)
-*() -?() x(first) y(se cond) 
$a first (se cond) third
-*() -?() x(first (se cond)) y(third) 
$a first (se cond) third fourth (fi fth)
-*() -?() x(first (se cond) third fourth) y(fi fth) 
$.function_all_flags a [-?] x [...] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }; .echo $nl}
$whence a
.function_all_flags a [-?] x ... {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}; .echo $nl}
$a
unacceptable arguments: for prototype [-?] x ...,
 assigned -*=() -?=() ,
 but needed (x),
( call) stack: a
$a first second third fourth fifth
-*() -?() x(first second third fourth fifth) 
$.function_all_flags a [-?] x [--] [y ...] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }; .echo $nl}
$whence a
.function_all_flags a [-?] x [--] [y ...] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}; .echo $nl}
$a
unacceptable arguments: for prototype [-?] x [--] [y ...],
 assigned -*=() -?=() ,
 but needed (x),
( call) stack: a
$a first
-*() -?() x(first) 
$a first second
-*() -?() x(first) y(second) 
$a first second third
-*() -?() x(first) y(second third) 
$a first second third fourth fifth
-*() -?() x(first) y(second third fourth fifth) 
$.function_all_flags a [-?] a [b ... c] d {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }; .echo $nl}
$whence a
.function_all_flags a [-?] a [b ... c] d {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}; .echo $nl}
$a first
unacceptable arguments: for prototype [-?] a [b ... c] d,
 assigned -*=() -?=() a=first ,
 but needed (d),
( call) stack: a
$a first second
-*() -?() a(first) d(second) 
$a first second third
unacceptable arguments: for prototype [-?] a [b ... c] d,
 assigned -*=() -?=() a=first b=second c=third ,
 but needed (d),
( call) stack: a
$a first second third fourth
-*() -?() a(first) b(second) c(third) d(fourth) 
$a first second third fourth fifth
-*() -?() a(first) b(second third) c(fourth) d(fifth) 
$a first second third fourth fifth sixth
-*() -?() a(first) b(second third fourth) c(fifth) d(sixth) 
$.function_all_flags a [-x ...] b c {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }; .echo $nl}
$whence a
.function_all_flags a [-x ...] b c {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}; .echo $nl}
$a first second
-*() b(first) c(second) 
$a -x first
unacceptable arguments: for prototype [-x ...] b c,
 assigned -*=-x -x=-x b=first ,
 but needed (c),
( call) stack: a
$a -x first second
-*(-x) -x(-x) b(first) c(second) 
$a -x first second third
-*(-x first) -x(-x first) b(second) c(third) 
$a -x first second third fourth
-*(-x first second) -x(-x first second) b(third) c(fourth) 
$.function_all_flags a [-x b ...] c {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }; .echo $nl}
$whence a
.function_all_flags a [-x b ...] c {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}; .echo $nl}
$a first
-*() c(first) 
$a -x first
unacceptable arguments: for prototype [-x b ...] c,
 assigned -*=(-x first) -x=(-x first) b=first ,
 but needed (c),
( call) stack: a
$a -x (fi rst) second
-*(-x (fi rst)) -x(-x (fi rst)) b((fi rst)) c(second) 
$a -x first (sec ond) third
-*(-x first (sec ond)) -x(-x first (sec ond)) b(first (sec ond)) c(third) 
$a -x first -x (sec ond) third
found flag -x while collecting arguments for elipsis
call stack a
$a -x first -y (sec ond) third
found flag -y while collecting arguments for elipsis
call stack a
$a -x (fi rst) (sec ond) third fourth
-*(-x (fi rst) (sec ond) third) -x(-x (fi rst) (sec ond) third) b((fi rst) (sec ond) third) c(fourth) 
$.function_all_flags a [-x ... b] c {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }
  .combine $nl
  if_only .test_not_empty $-* {c (-*: ) $-*$ $nl}
  if_only .var_exists -x {c (-x: ) $-x$ $nl}
  if_only .var_exists b {c (b: ) $b$ $nl}
  if_only .var_exists c {c (c: ) $c$ $nl}
}
$whence a
.function_all_flags a [-x ... b] c {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}
  .combine $nl
  if_only .test_not_empty $-* {c (-*: ) $-*$ $nl}
  if_only .var_exists -x {c (-x: ) $-x$ $nl}
  if_only .var_exists b {c (b: ) $b$ $nl}
  if_only .var_exists c {c (c: ) $c$ $nl}
}
$a first
-*() c(first) 
c: first
$a -x first
unacceptable arguments: for prototype [-x ... b] c,
 assigned -*=(-x first) -x=(-x first) b=first ,
 but needed (c),
( call) stack: a
$a -x (fi rst) second
-*(-x (fi rst)) -x(-x (fi rst)) b((fi rst)) c(second) 
-*: -xfi rst
-x: -xfi rst
b: fi rst
c: second
$a -x () (fi rst) second
-*(-x () (fi rst)) -x(-x () (fi rst)) b((fi rst)) c(second) 
-*: -xfi rst
-x: -xfi rst
b: fi rst
c: second
$a -x first (sec ond) third
-*(-x first (sec ond)) -x(-x first (sec ond)) b((sec ond)) c(third) 
-*: -xfirstsec ond
-x: -xfirstsec ond
b: sec ond
c: third
$a -x (fi rst) (sec ond) third fourth
-*(-x (fi rst) (sec ond) third) -x(-x (fi rst) (sec ond) third) b(third) c(fourth) 
-*: -xfi rstsec ondthird
-x: -xfi rstsec ondthird
b: third
c: fourth
$.function_all_flags a x [-?] [... y z] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }
  .combine $nl
  if_only .var_exists x {c (x: ) $x$ $nl}}
$whence a
.function_all_flags a [-?] x [... y z] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}
  .combine $nl
  if_only .var_exists x {c (x: ) $x$ $nl}}
$a
unacceptable arguments: for prototype [-?] x [... y z],
 assigned -*=() -?=() ,
 but needed (x),
( call) stack: a
$a (fi rst)
-*() -?() x((fi rst)) 
x: fi rst
$a (fi rst) second
unacceptable arguments: for prototype [-?] x [... y z],
 assigned -*=() -?=() x=(fi rst) y=second ,
 but needed (z),
( call) stack: a
$a first (sec ond) third
-*() -?() x(first) y(sec ond) z(third) 
x: first
$a (fi rst) (sec ond) third fourth
-*() -?() x((fi rst) (sec ond)) y(third) z(fourth) 
x: fi rstsec ond
$a () (sec ond) third fourth
-*() -?() x(() (sec ond)) y(third) z(fourth) 
x: sec ond
$a (fi rst) (sec ond) (thi rd) (fou rth) (fi fth)
-*() -?() x((fi rst) (sec ond) (thi rd)) y(fou rth) z(fi fth) 
x: fi rstsec ondthi rd
$.function_all_flags a [-?] [x] [... y] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }; .echo $nl}
$whence a
.function_all_flags a [-?] [x] [... y] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}; .echo $nl}
$a
-*() -?() 
$a (fi rst)
-*() -?() x((fi rst)) 
$a (fi rst) second
-*() -?() x((fi rst)) y(second) 
$a first (sec ond) third
-*() -?() x(first (sec ond)) y(third) 
$a (fi rst) (sec ond) third fourth
-*() -?() x((fi rst) (sec ond) third) y(fourth) 
$a (fi rst) (sec ond) (thi rd) (fou rth) (fi fth)
-*() -?() x((fi rst) (sec ond) (thi rd) (fou rth)) y(fi fth) 
$.function_all_flags a [-?] [x y] [... z] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }
  .combine $nl
  if_only .var_exists x {c (x: ) $x $nl}
  if_only .var_exists y {c (y: ) $y$ $nl}
  if_only .var_exists z {c (z: ) $z$ $nl}}
$whence a
.function_all_flags a [-?] [x y] [... z] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}
  .combine $nl
  if_only .var_exists x {c (x: ) $x $nl}
  if_only .var_exists y {c (y: ) $y$ $nl}
  if_only .var_exists z {c (z: ) $z$ $nl}}
$a
-*() -?() 
$a (fi rst)
unacceptable arguments: for prototype [-?] [x y] [... z],
 assigned -*=() -?=() x=(fi rst) ,
 but needed (y),
( call) stack: a
$a (fi rst) second
-*() -?() x(fi rst) y(second) 
x: fi rst
y: second
$a (fi rst) (sec ond) (thi rd)
-*() -?() x(fi rst) y((sec ond)) z(thi rd) 
x: fi rst
y: sec ond
z: third
$a (fi rst) (sec ond) third (fou rth)
-*() -?() x(fi rst) y((sec ond) third) z(fou rth) 
x: fi rst
y: sec ondthird
z: fourth
$a (fi rst) (sec ond) (thi rd) (fou rth) (fi fth)
-*() -?() x(fi rst) y((sec ond) (thi rd) (fou rth)) z(fi fth) 
x: fi rst
y: sec ondthi rdfou rth
z: fifth
$.function_all_flags a -- [-x] y z {}
flag option [-x] occurs after -- in the prototype
call stack: .function_all_flags
$.function_all_flags a -- [x y] z {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }; .echo $nl}
$whence a
.function_all_flags a -- [x y] z {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}; .echo $nl}
$a
unacceptable arguments: for prototype -- [x y] z,
 needed (z),
( call) stack: a
$a --file
z(--file) 
$a first second third
x(first) y(second) z(third) 
$a -x second -
x(-x) y(second) z(-) 
$
$# .get_max_collectible_exceptions .set_max_collectible_exceptions
$.get_max_collectible_exceptions excess
unacceptable argument count: received 1 non-optional, but needed 0 (with 0 optional) for .get_max_collectible_exceptions
$.set_max_collectible_exceptions
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .set_max_collectible_exceptions
$.get_max_collectible_exceptions {excess}
.get_max_collectible_exceptions does not accept an argfunction with call stack: .get_max_collectible_exceptions
$.set_max_collectible_exceptions 1 {excess}
.set_max_collectible_exceptions does not accept an argfunction with call stack: .set_max_collectible_exceptions
$.set_max_collectible_exceptions NaN
NaN is not a number
call stack: .set_max_collectible_exceptions
$.scope () {.get_max_collectible_exceptions; .echo $nl}
10
$.set_max_collectible_exceptions 0
value 0 is out of usable numeric range
call stack .set_max_collectible_exceptions
$.scope () {.get_max_collectible_exceptions; .echo $nl}
10
$.set_max_collectible_exceptions 7
$.collect_errors_except
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .collect_errors_except
.collect_errors_except requires an argfunction
$.collect_errors_only
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .collect_errors_only
.collect_errors_only requires an argfunction
$se {.collect_errors_except .nop {
     se {echo before exception
        .throw .not_a_number 7
        echo after exception}
     echo between exceptions
     .scope () {.throw .function_not_found foo}
     echo inside collect}
   echo outside collect}
before exception
between exceptions
inside collect
7 is not a number
call stack: .throw .scope se .collect_errors_except .scope se
foo : command not found ( foo .throw .scope .collect_errors_except .scope se )
$se {.collect_errors_except echo {
     .throw .function_not_found foo
     echo between exceptions
     .throw echo 7
     echo inside collect}
   echo outside collect}
between exceptions
foo : command not found ( foo .throw .collect_errors_except .scope se )
7 .throw .collect_errors_except .scope se
$# .collect_errors_except .echo {${.throw .echo exception thrown directly}}
$se {.collect_errors_only .function_not_found {
     .throw .function_not_found foo
     echo between exceptions
     .throw echo 7
     echo inside collect}
   echo outside collect}
between exceptions
foo : command not found ( foo .throw .collect_errors_only .scope se )
7 .throw .collect_errors_only .scope se
$.collect_errors_except echo {
 .collect_errors_except echo {
  .collect_errors_except echo {
   .collect_errors_except echo {
    .collect_errors_except .echo {
     echo inside 5
     .throw echo inside 5
     .collect_errors_except echo {
      .collect_errors_except echo {
       .collect_errors_except echo {
        .collect_errors_except echo {
         .collect_errors_except .echo {
          echo inside 10
          .throw echo inside 10
          .collect_errors_except echo {
           .collect_errors_except echo {
            .collect_errors_except echo {
             .collect_errors_except echo {
              .collect_errors_except .echo {
               echo inside 15
               .throw echo inside 15
               .collect_errors_except echo {
                .collect_errors_except echo {
                 .collect_errors_except echo {
                  .collect_errors_except echo {
                   .collect_errors_except .echo {
                    echo inside 20
                    .throw echo inside 20
                   .collect_errors_except .echo {echo inside 21}
}}}}}}}}}}}}}}}}}}}}
inside 5
inside 10
inside 15
inside 20
inside 5 .throw .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except
inside 10 .throw .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except
inside 15 .throw .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except
inside 20 .throw .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except
function exceeded max nesting ( 20 ). call stack: (echo .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except .collect_errors_except)
$.set_max_collectible_exceptions 1
$.function_all_flags collecting_handler args ... {
  echo $args$
}
$.scope () {.get_max_extra_exceptions; .echo $nl}
5
$.set_max_extra_exceptions 1
$.try_catch_recursive collecting_handler {
  .collect_errors_except .echo {
    .throw collecting_handler 1
    .throw collecting_handler 2}}
1 .throw .collect_errors_except .try_catch_recursive(body)
2 .throw .collect_errors_except .try_catch_recursive(body)
$.try_catch_recursive collecting_handler {
  .collect_errors_except .echo {
    .throw collecting_handler 1
    .throw collecting_handler 2
    echo almost nothing}}
1 .throw .collect_errors_except .try_catch_recursive(body)
2 .throw .collect_errors_except .try_catch_recursive(body)
exceeded maximum number of exceptions ( 1 ) in collect_errors.
call stack: .collect_errors_except .try_catch_recursive(body) .try_catch_recursive
$.set_max_extra_exceptions 0
$.try_catch_recursive collecting_handler {
  .collect_errors_except .echo {
    .throw collecting_handler 1
    .throw collecting_handler 2}}
1 .throw .collect_errors_except .try_catch_recursive(body) .try_catch_recursive
2 .throw .collect_errors_except .try_catch_recursive(body) .try_catch_recursive
exceeded maximum number of exceptions ( 0 ) in try_catch.
call stack: .try_catch_recursive
$.try_catch_recursive collecting_handler {
  .collect_errors_except .echo {
    .throw collecting_handler 1
    .throw collecting_handler 2
    echo almost nothing}}
1 .throw .collect_errors_except .try_catch_recursive(body) .try_catch_recursive
2 .throw .collect_errors_except .try_catch_recursive(body) .try_catch_recursive
exceeded maximum number of exceptions ( 1 ) in collect_errors.
call stack: .collect_errors_except .try_catch_recursive(body) .try_catch_recursive
exceeded maximum number of exceptions ( 0 ) in try_catch.
call stack: .try_catch_recursive
$.set_max_extra_exceptions 1
$.set_max_collectible_exceptions 7
$.scope () {.get_max_collectible_exceptions; .echo $nl}
7
$
$# .getpid .getppid .sighup
$.getpid excess
unacceptable argument count: received 1 non-optional, but needed 0 (with 0 optional) for .getpid
$.getpid {excess argfunc}
.getpid does not accept an argfunction with call stack: .getpid
$.getppid excess
unacceptable argument count: received 1 non-optional, but needed 0 (with 0 optional) for .getppid
$.getppid {excess argfunc}
.getppid does not accept an argfunction with call stack: .getppid
$se {.fork se {
      /bin/kill -HUP ${.getppid}
      echo after the signal in subshell}
    echo after the signal in parent}
added /bin/kill to executable map in test suite
after the signal in subshell
received SIGHUP
after the signal in parent
$se {.fork se {
      /bin/kill -HUP ${.getpid}
      echo after the signal in subshell}
    echo after the signal in parent}
added /bin/kill to executable map in test suite
received SIGHUP
after the signal in subshell
after the signal in parent
$.while .nop {
  echo before signals
  /bin/kill -PIPE ${.getpid}
  echo after sigpipe
  /bin/kill ${.getpid}
  echo should not continue beyond SIGTERM}
before signals
added /bin/kill to executable map in test suite
received SIGPIPE
after sigpipe
(
) received SIGTERM .throw .sigterm /bin/kill .mapped_argfunction .while
$.while .nop {
  echo before signals
  /bin/kill -USR1 ${.getpid}
  echo after sigusr1
  /bin/kill -INT ${.getpid}
  echo should not continue beyond SIGINT}
before signals
received SIGUSR1
after sigusr1
(
) received SIGINT .throw .sigint /bin/kill .mapped_argfunction .while
$
$# .global .local .local_declare .unset .var_exists
$.global
unacceptable argument count: received 0 non-optional, but needed 2 (with 0 optional) for .global
$.global x y z
unacceptable argument count: received 3 non-optional, but needed 2 (with 0 optional) for .global
$.global x y {excess argfunc}
.global does not accept an argfunction with call stack: .global
$.local
unacceptable argument count: received 0 non-optional, but needed 2 (with 0 optional) for .local
$.local x y z
unacceptable argument count: received 3 non-optional, but needed 2 (with 0 optional) for .local
$.local x y {excess argfunc}
.local does not accept an argfunction with call stack: .local
$.local_declare
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .local_declare
$.local_declare x {excess argfunc}
.local_declare does not accept an argfunction with call stack: .local_declare
$.unset
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .unset
$.unset x {excess argfunc}
.unset does not accept an argfunction with call stack: .unset
$.unset x y
unacceptable argument count: received 2 non-optional, but needed 1 (with 0 optional) for .unset
$.unset FIGNORE
$FIGNORE cannot be set
call stack .unset
$.var_exists
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .var_exists
$.var_exists x {excess argfunc}
.var_exists does not accept an argfunction with call stack: .var_exists
$.global 100 nihilism
$100 cannot be set
call stack .global
$.local 0 nihilism
$0 cannot be set
call stack .local
$.local_declare 0 #
$0 cannot be set
call stack .local_declare
$# cannot be set
call stack .local_declare
$.global .var_exists (must be requested to be checked)
$echo $.var_exists$
must be requested to be checked
$.unset #
$# cannot be set
call stack .unset
$.unset #
$# cannot be set
call stack .unset
$.unset *
$* cannot be set
call stack .unset
$.unset 1
$1 cannot be set
call stack .unset
$.unset MAX_NESTING
MAX_NESTING was not declared
call stack: .unset
$.var_exists #
$.var_exists *
$.var_exists 0
$.var_exists 2
assertion (var exists: 2) failed
call stack .var_exists
$.var_exists x
assertion (var exists: x) failed
call stack .var_exists
$.var_exists x y
assertion (var exists: x y) failed
call stack .var_exists
$.var_exists # y
$.var_exists y x
assertion (var exists: y x) failed
call stack .var_exists
$.unset x
x was not declared
call stack: .unset
$.global x nihilism
$.var_exists x
$.var_exists x y
$echo $x
nihilism
$.global x nihilism
$.global x ubernihilism
variable x already exists
call stack .global
$.global i nihilism
$.global j nihilism
$fn a {if_only .var_exists x {echo in a x $x}
      if_only .var_exists y {echo in a y $y}
      if_only .var_exists i {echo in a i $i}
      if_only .var_exists j {echo in a j $j}
      if_only .var_exists k {echo in a k $k}
      if_only .var_exists m {echo in a m $m}
      .local x (first level not global)
      .local y (level one not global)
      .local z (will be unused)
      .local_declare i j k l m
      .set i (declared first level not global)
      .set j (declared first level not global)
      .set k (declared level one not global)
      .set l (will be unused)
      b
      if_only .var_exists i {echo out a i $i}
      if_only .var_exists j {echo out a j $j}
      if_only .var_exists k {echo out a k $k}
      if_only .var_exists m {echo out a m $m}
      if_only .var_exists x {echo out a x $x}
      if_only .var_exists y {echo out a y $y}}
$fn b {if_only .var_exists i {echo in b i $i}
      if_only .var_exists j {echo in b j $j}
      if_only .var_exists k {echo in b k $k}
      if_only .var_exists m {echo in a m $m}
      if_only .var_exists x {echo in b x $x}
      if_only .var_exists y {echo in b y $y}
      .local x (second level masks first)
      .set y   (level two overwrites one)
      .local_declare i j m
      echo undefined i will hide the first level local
      .set j (declared second level masks first)
      .set k (declared level two overwrites one)
      c
      if_only .var_exists i {echo out b i $i}
      if_only .var_exists j {echo out b j $j}
      if_only .var_exists k {echo out b k $k}
      if_only .var_exists m {echo out b m $m}
      if_only .var_exists x {echo out b x $x}
      if_only .var_exists y {echo out b y $y}}
$fn c {if_only .var_exists i {echo in c i $i}
      if_only .var_exists j {echo in c j $j}
      if_only .var_exists k {echo in c k $k}
      if_only .var_exists m {echo in c m $m}
      if_only .var_exists x {echo in c x $x}
      if_only .var_exists y {echo in c y $y}
      # can unset a local, but only one at a time
      .unset x
      .try_catch_recursive .undefined_variable {
        .unset i}
      .unset j
      .unset l
      .try_catch_recursive .global_would_be_masked {
        .global y (attempting to create global masked by local)}
      .set x (third level overwrites first)
      .set i (declared third level overwrites second)
      .set j (declared third level overwrites first)
      .local x (third level masks first)
      .local_declare i j m
      .set i (declared third level masks first)
      .set j (declared third level masks first)
      .set y (level three overwrites one)
      .set k (declared level three overwrites one)
      if_only .var_exists i {echo out c i $i}
      if_only .var_exists j {echo out c j $j}
      if_only .var_exists k {echo out c k $k}
      if_only .var_exists m {echo out c m $m}
      if_only .var_exists x {echo out c x $x}
      if_only .var_exists y {echo out c y $y}}
$a
in a x nihilism
in a i nihilism
in a j nihilism
in b i (declared first level not global)
in b j (declared first level not global)
in b k (declared level one not global)
in b x (first level not global)
in b y (level one not global)
undefined i will hide the first level local
in c j (declared second level masks first)
in c k (declared level two overwrites one)
in c x (second level masks first)
in c y (level two overwrites one)
optional variable i was not defined
call stack: .unset .try_catch_recursive(body)
requested global y already exists as a local. It would be masked by the local and inaccessible from here
call stack .global .try_catch_recursive(body)
out c i (declared third level masks first)
out c j (declared third level masks first)
out c k (declared level three overwrites one)
out c x (third level masks first)
out c y (level three overwrites one)
out b i (declared third level overwrites second)
out b j (declared third level overwrites first)
out b k (declared level three overwrites one)
out b x (third level overwrites first)
out b y (level three overwrites one)
out a i (declared first level not global)
out a j (declared third level overwrites first)
out a k (declared level three overwrites one)
out a x (third level overwrites first)
out a y (level three overwrites one)
l was unused with call stack a
z was unused with call stack a
$# demonstrating that final values are not retained
$a
in a x nihilism
in a i nihilism
in a j nihilism
in b i (declared first level not global)
in b j (declared first level not global)
in b k (declared level one not global)
in b x (first level not global)
in b y (level one not global)
undefined i will hide the first level local
in c j (declared second level masks first)
in c k (declared level two overwrites one)
in c x (second level masks first)
in c y (level two overwrites one)
optional variable i was not defined
call stack: .unset .try_catch_recursive(body)
requested global y already exists as a local. It would be masked by the local and inaccessible from here
call stack .global .try_catch_recursive(body)
out c i (declared third level masks first)
out c j (declared third level masks first)
out c k (declared level three overwrites one)
out c x (third level masks first)
out c y (level three overwrites one)
out b i (declared third level overwrites second)
out b j (declared third level overwrites first)
out b k (declared level three overwrites one)
out b x (third level overwrites first)
out b y (level three overwrites one)
out a i (declared first level not global)
out a j (declared third level overwrites first)
out a k (declared level three overwrites one)
out a x (third level overwrites first)
out a y (level three overwrites one)
l was unused with call stack a
z was unused with call stack a
$echo $x
nihilism
$.var_exists y
assertion (var exists: y) failed
call stack .var_exists
$.unset x
$.unset i
$.unset j
$.var_exists x
assertion (var exists: x) failed
call stack .var_exists
$
$# .store_output
$.store_output x
.store_output requires an argfunction
$.store_output {echo some text}
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .store_output
$.store_output # {echo some text}
$# cannot be set
call stack .store_output
$.store_output x {echo some text}
x was not declared
call stack: .store_output
$.global x ()
$.store_output x {echo some text; .throw echo exception}
exception .throw .mapped_argfunction .store_output
$e $x
$.store_output x {echo some text}
$e $x
some text
$.unset x
$
$## if_core
$# helper functions
$.function_all_flags silent_throw [text ...] {
  .collect_errors_only .false echo {
    .throw .false first
    .throw echo exception $text$
    .throw .false second
    .nop}}
$.function_all_flags caught_silent_throw [text ...] {
  .try_catch_recursive echo {silent_throw $text$}}
$silent_throw on its own
assertion first failed
call stack .throw .collect_errors_only silent_throw
exception on its own .throw .collect_errors_only silent_throw
assertion second failed
call stack .throw .collect_errors_only silent_throw
$caught_silent_throw on its own
exception on its own .throw .collect_errors_only silent_throw .try_catch_recursive(body)
assertion first failed
call stack .throw .collect_errors_only silent_throw .try_catch_recursive(body) .try_catch_recursive caught_silent_throw
assertion second failed
call stack .throw .collect_errors_only silent_throw .try_catch_recursive(body) .try_catch_recursive caught_silent_throw
$fn if_true {.if .test_not_empty ( ) {.argfunction}}
$fn if_false {.if .test_not_empty ()  {.argfunction}}
$fn else_if_true {.else_if .test_string_unequal q w {.argfunction}}
$fn else_if_false {.else_if .test_string_unequal q q {.argfunction}}
$fn else_if_not_true {.else_if_not .test_string_equal x x {.argfunction}}
$fn else_if_not_false {.else_if_not .test_string_equal y z {.argfunction}}
$fn obscured_else {.scope () {.scope () {.else {.argfunction}}}}
$fn if_with_body args ... {.if $args$ {echo the afore-mentioned body}}
$fn if_else_if_not_with_body args ... {
  .if $args$ {echo the first body}
  .else_if_not $args$ {echo the second body}}
$fn double_if_with_body args ... {
  .if $args$ {echo the first body}
  .if $args$ {echo the second body}}
$fn else_if_with_body args ... {.else_if $args$ {echo the afore-mentioned body}}
$fn else_with_body [args ...] {.else {echo the afore-mentioned &&args$}}
$fn conditional_true {
  .if .test_in . . {echo in_conditional_if}
  .else {echo in_conditional_else}
  .test_in . .}
$fn conditional_false {
  .if .test_in . {echo in_conditional_if}
  .else {echo in_conditional_else}
  .test_in .}
$fn conditional_echo first second {
  .if .test_in () {echo not printed if empty string in null set}
  .else_if_not .echo $first {echo not printed else if echo fails}
  .else {.echo () $second}}
$
$# ! negation: if_core workout
$.function_all_flags !x args ... {
  .if .throw .false anyway {}
  .else_if_not $args$ {.nop}
  .else {.throw .false ${.echo ! $args}}}
$.test_string_equal 42 420e-1
assertion (42 == 420e-1) failed
call stack .test_string_equal
$.test_number_equal 42 420e-1
$!  .test_greater 50 230
$!x .test_greater 50 230
$!  .test_less 5 2.3e1
assertion (! .test_less 5 2.3e1) failed
call stack .throw .mapped_argfunction .if !
$!x .test_less 5 2.3e1
assertion (! .test_less 5 2.3e1) failed
call stack .throw .mapped_argfunction .else !x
$!  !  .test_executable_exists !!!
assertion (! ! .test_executable_exists !!!) failed
call stack .throw .mapped_argfunction .if !
$!  !x .test_executable_exists !!!
assertion (! !x .test_executable_exists !!!) failed
call stack .throw .mapped_argfunction .if !
$!x !  .test_executable_exists !!!
assertion (! ! .test_executable_exists !!!) failed
call stack .throw .mapped_argfunction .else !x
$!x !x .test_executable_exists !!!
assertion (! !x .test_executable_exists !!!) failed
call stack .throw .mapped_argfunction .else !x
$!  !  .whence_function !!!
!!! : command not found ( !!! .whence_function .if ! .if ! )
$!x !x .whence_function !!!
!!! : command not found ( !!! .whence_function .else_if_not !x .else_if_not !x )
$!  !  .test_not_empty 0
$!  !x .test_not_empty 0
$!x !  .test_not_empty 0
$!x !x .test_not_empty 0
$!  !  !  .test_in 0 0
assertion (! ! ! .test_in 0 0) failed
call stack .throw .mapped_argfunction .if !
$!  !  !  .test_in 0
$!  !  !  !  .test_in 0
assertion (! ! ! ! .test_in 0) failed
call stack .throw .mapped_argfunction .if !
$!  !  !x !  .test_in 0
assertion (! ! !x ! .test_in 0) failed
call stack .throw .mapped_argfunction .if !
$!  !x !  !  .test_in 0
assertion (! !x ! ! .test_in 0) failed
call stack .throw .mapped_argfunction .if !
$!  !x !x !  .test_in 0
assertion (! !x !x ! .test_in 0) failed
call stack .throw .mapped_argfunction .if !
$!x !  !  !  .test_in 0
assertion (! ! ! ! .test_in 0) failed
call stack .throw .mapped_argfunction .else !x
$!x !  !x !  .test_in 0
assertion (! ! !x ! .test_in 0) failed
call stack .throw .mapped_argfunction .else !x
$!x !x !  !  .test_in 0
assertion (! !x ! ! .test_in 0) failed
call stack .throw .mapped_argfunction .else !x
$!x !x !x !  .test_in 0
assertion (! !x !x ! .test_in 0) failed
call stack .throw .mapped_argfunction .else !x
$!  !  !  !  .test_in 0 0
$!  !  !x !  .test_in 0 0
$!  !x !  !  .test_in 0 0
$!  !x !x !  .test_in 0 0
$!x !  !  !  .test_in 0 0
$!x !  !x !  .test_in 0 0
$!x !x !  !  .test_in 0 0
$!x !x !x !  .test_in 0 0
$
$# properly sequenced un-nested conditionals where everything succeeds
$se {
  if_true {echo if_true printing}
  else_if_true {echo else_if_true not printing when condition true}
  else_if_not_false {echo else_if_not_false not printing when condition true}
  else_if_false {echo else_if_false not printing when condition true}
  else_if_not_true {echo else_if_not_false not printing when condition true}
  obscured_else {echo obscured_else not printing when condition true}}
if_true printing
$se {
  if_false {echo if_false not printing}
  else_if_false {echo else_if_false not printing when condition false}
  else_if_not_true {echo else_if_not_true not printing when condition false}
  obscured_else {echo obscured_else is printing when condition false}}
obscured_else is printing when condition false
$se {
  if_false {echo if_false not printing}
  else_if_true {echo else_if_true printing when condition false}
  obscured_else {echo obscured_else not printing when condition true}}
else_if_true printing when condition false
$se {
  if_false {echo if_false not printing}
  else_if_not_false {echo else_if_not_false printing when condition false}
  obscured_else {echo obscured_else not printing when condition true}}
else_if_not_false printing when condition false
$se {
  if_with_body .test_not_empty a
  else_if_with_body .test_not_empty a
  else_with_body}
the afore-mentioned body
$se {
  if_with_body .test_not_empty ()
  else_if_with_body .test_not_empty ()
  else_with_body text expanded}
the afore-mentioned text expanded
$se {
  if_with_body .test_not_empty ()
  else_if_with_body .test_not_empty a
  else_with_body text}
the afore-mentioned body
$
$# nested conditionals
$se {
  .if conditional_true {echo conditional_true printing}
  .else {echo else not printing when condition true}}
in_conditional_if
conditional_true printing
$se {
  .if conditional_false {echo conditional_false not printing}
  .else {echo else is printing when condition false}}
in_conditional_else
else is printing when condition false
$se {
  .if ${conditional_echo .test_is_number 71}$ {echo conditional_echo printing}
  .else {echo else not printing when condition true}}
conditional_echo printing
$se {
  .if ${conditional_echo .test_is_number pi}$ {echo conditional_echo not printing}
  .else {echo else is printing when condition false}}
else is printing when condition false
$se {
  if_true {echo ${conditional_echo print this}}
  .else {echo else not printing when condition true}}
(print this)
$se {
  if_false {echo ${conditional_echo .test_not_empty ()}}
  .else {echo else is printing when condition false}}
else is printing when condition false
$se {
  .if conditional_true {echo ${conditional_echo print this}}
  .else {echo ${conditional_echo not printing}}}
in_conditional_if
(print this)
$se {
  .if conditional_false {echo ${conditional_echo not printing}}
  .else {echo ${conditional_echo print this}}}
in_conditional_else
(print this)
$
$# improperly sequenced conditionals and conditional block exception
$.else {echo top level else without if}
else without if with call stack: .else
$.collect_errors_except .nop {
  .if else_with_body {echo else without if in condition}
  else_if_true {echo else_if ignored after exception}
  else_if_false {echo else_if ignored after exception}
  else_if_not_true {echo else_if_not ignored after exception}
  else_if_not_false {echo else_if_not ignored after exception}
  obscured_else {echo else skipped when properly closing block}
  echo end collect errors}
end collect errors
else without if with call stack: .else else_with_body .if .collect_errors_except
$.collect_errors_except .nop {
  if_true {.else {echo else without if in body}}
  echo else is skipped without issue (expecting exception avoided it)}
else is skipped without issue (expecting exception avoided it)
else without if with call stack: .else .mapped_argfunction .if if_true .collect_errors_except
$.collect_errors_except .nop {
  if_false {echo set up}
  else_if_true {else_if_true {else_if without if}}
  else_with_body}
else without if with call stack: .else_if else_if_true .mapped_argfunction .else_if else_if_true .collect_errors_except
$.collect_errors_except .nop {
  double_if_with_body .test_in if following another top-level if
  if_true {echo if_true printing though it is the third if}
  else_with_body}
the first body
if_true printing though it is the third if
two .if commands without a .else between them with call stack : .if double_if_with_body .collect_errors_except
$.collect_errors_except .nop {
  if_with_body double_if_with_body .test_in double if in condition
  obscured_else {echo else skipped when properly closing block}}
two .if commands without a .else between them with call stack : .if double_if_with_body .if if_with_body .collect_errors_except
$.collect_errors_except .nop {
  if_false {}
  .else {double_if_with_body .test_in double if in body}
  .else {echo double else is an exception even when first throws}
  if_true {echo if_true printing immediately after an else that threw}
  else_with_body}
if_true printing immediately after an else that threw
two .if commands without a .else between them with call stack : .if double_if_with_body .mapped_argfunction .else .collect_errors_except
else without if with call stack: .else .collect_errors_except
$.collect_errors_except .nop {
  if_true {.else {echo else without if}}
  .else {echo ignored because it is at the level of the if
         echo not the else that it immediately follows (if-else ambiguity)}
  if_false {echo if ignored because the condition is false}
  else {echo else run after the properly closed if-else}}
else run after the properly closed if-else
else without if with call stack: .else .mapped_argfunction .if if_true .collect_errors_except
$.collect_errors_except .nop {
  if_false {}
  obscured_else {if_false {echo bad_if_nest in condition body}}
  else_if_true {echo exception for else_if after else that threw}
  else_if_not_false {
    echo else_if_not ignored after else_if that threw without else following}
  .if if_with_body if_with_body .test_in innermost if {echo is not matched}}
nested .if without .else with call stack: .else .scope .scope obscured_else .collect_errors_except
else without if with call stack: .else_if else_if_true .collect_errors_except
nested .if without .else with call stack: .if if_with_body .if .collect_errors_except
$if_false {echo if block not closed}
conditional not finished within preceeding block
$.if if_with_body conditional_true {echo middle if is not matched}
in_conditional_if
the afore-mentioned body
nested .if without .else with call stack: .if
$.if if_else_if_not_with_body .test_in else if without else {
  echo body is not run with exception in condition}
the first body
nested .if without .else with call stack: .if
$.collect_errors_except .nop {
  if_false {}
  obscured_else {if_else_if_not_with_body .test_in else_if without else in body}}
the second body
nested .if without .else with call stack: .else .scope .scope obscured_else .collect_errors_except
$.collect_errors_except .nop {
  if_false {}
  .else {if_true {if_true {echo unmatched if doubled in body}}}}
unmatched if doubled in body
nested .if without .else with call stack: .if if_true .mapped_argfunction .else .collect_errors_except
$.collect_errors_except .nop {
  if_false {}
  .else {.if if_with_body .test_in unmatched {echo if in condition of body}}}
nested .if without .else with call stack: .if .mapped_argfunction .else .collect_errors_except
$.collect_errors_except .nop {
  .try_catch_recursive echo {
    .if silent_throw in if {echo definitely should not print}
    .else {echo skipped because non-.false exception thrown earlier}}}
exception in if .throw .collect_errors_only silent_throw .if .try_catch_recursive(body)
$.collect_errors_except .nop {
  .try_catch_recursive echo {
    .if caught_silent_throw in if {echo still should not print}
    .else {echo not skipped because only .false were thrown earlier}}}
exception in if .throw .collect_errors_only silent_throw .try_catch_recursive(body)
not skipped because only .false were thrown earlier
$
$# exception thrown in argfunction
$se {
  .if ${conditional_echo unfindable anywhere}$ {echo also a failed substitution}
  .else {echo else skipped when condition threw an exception}}
unfindable : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction .if .scope se
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction .if .scope se
unfindable : command not found ( unfindable anywhere .if .scope se )
$se {
  if_true {echo &&&{unfindable anywhere}}
  .else {echo else not printing when condition true and if body threw}}
unfindable : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction .mapped_argfunction .mapped_argfunction .if if_true .scope se
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction .mapped_argfunction .mapped_argfunction .if if_true .scope se
unfindable : command not found ( unfindable anywhere .mapped_argfunction .mapped_argfunction .if if_true .scope se )
substitution (&{unfindable anywhere}) failed
call stack: .mapped_argfunction .if if_true .scope se
$if_true {echo &{unfindable anywhere}}
unfindable : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction if_true
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction if_true
unfindable : command not found ( unfindable anywhere if_true )
substitution (&{unfindable anywhere}) failed
$.else {echo else throws an exception because we never got into the if}
else without if with call stack: .else
$
$# .if .else_if .else_if_not .else
$.collect_errors_except .nop {
  .if
  .else_if .test_is_number 0 {echo do not run after an exception}
  .else_if_not .test_is_number false {echo do not run after an exception}
  .else_if
  .else_if_not
  .else {echo do not run after an exception}}
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .if .collect_errors_except
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .else_if .collect_errors_except
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .else_if_not .collect_errors_except
$.if missing argfunction
.if requires an argfunction
$.else_if missing argfunction
.else_if requires an argfunction
$.else_if_not missing argfunction
.else_if_not requires an argfunction
$.else
.else requires an argfunction
$se {
  .if .test_is_number 0 {}
  .else {echo first else for if}
  .else {echo second else for if}}
else without if with call stack: .else .scope se
$se {
  .if .test_is_number 0 {echo if true}
  .else {echo else 0 not a number}}
if true
$se {
  .if .test_is_number false {echo if false}
  .else {echo else false is not a number}}
else false is not a number
$.else {}
else without if with call stack: .else
$.else_if .test_is_number 0 {echo not this one}
else without if with call stack: .else_if
$.else {}
$.else_if_not .test_is_number false {echo nor this}
else without if with call stack: .else_if_not
$
$# .internal_features .internal_functions .internal_vars
$.internal_features 1
unacceptable arguments: for prototype ,
 found (1) excess
( call) stack: .internal_features
$.internal_functions 1
unacceptable argument count: received 1 non-optional, but needed 0 (with 0 optional) for .internal_functions
$.internal_functions {excess argfunc}
.internal_functions does not accept an argfunction with call stack: .internal_functions
$.internal_vars 1
unacceptable arguments: for prototype ,
 found (1) excess
( call) stack: .internal_vars
$.internal_features
.after_command .before_command .run_logic
$.internal_functions
.ambiguous_prototype_dash_dash
.arguments_for_argfunction
.autofunction
.bad_argc
.bad_argfunction_style
.bad_args
.bad_if_nest
.binary_does_not_exist
.binary_not_found
.break
.continue
.dash_dash_argument
.dash_star_argument
.directory_not_found
.divide_by_zero
.double_redirection
.duplicate_parameter
.elipsis_first_arg
.elipsis_out_of_option_group
.else_without_if
.excess_argfunction
.excessive_exceptions_collected
.excessive_exceptions_in_catch
.excessive_nesting
.exec_failed
.executable_already_exists
.failed_substitution
.false
.file_open_failure
.file_not_found
.flag_in_elipsis
.function_not_found
.global_would_be_masked
.if_before_else
.illegal_function_name
.illegal_variable_name
.input_range
.internal_error
.interrupted_sleep
.invalid_word_selection
.mismatched_brace
.mismatched_bracket
.mismatched_parenthesis
.missing_argfunction
.multiple_argfunctions
.not_a_directory
.not_a_function
.not_a_number
.not_catching_exception
.not_executable
.not_soon_enough
.raw_command
.return_code
.result_range
.post_elipsis_option
.post_dash_dash_flag
.prompt
.selection_not_found
.shutdown
.sighup
.sigint
.sigquit
.sigpipe
.sigterm
.sigtstp
.sigcont
.sigchld
.sigusr1
.sigusr2
.sigunknown
.tardy_flag
.unchecked_variable
.undeclared_variable
.undefined_variable
.unfinished_if_block
.unreadable_dir
.unrecognized_flag
.unused_before_set
.unused_variable
.variable_already_exists
.version_incompatible
$.internal_vars
FIGNORE
$
$# .is_default_input .is_default_output .is_default_error
$.is_default_input 1
unacceptable argument count: received 1 non-optional, but needed 0 (with 0 optional) for .is_default_input
$.is_default_input {excess argfunc}
.is_default_input does not accept an argfunction with call stack: .is_default_input
$se {.is_default_input <dummy_file}
assertion is_default_input failed
call stack .is_default_input .scope se
$se {.is_default_input}
$.is_default_output 1
unacceptable argument count: received 1 non-optional, but needed 0 (with 0 optional) for .is_default_output
$.is_default_output {excess argfunc}
.is_default_output does not accept an argfunction with call stack: .is_default_output
$e ${.is_default_output; .echo $?}
assertion is_default_output failed
call stack .is_default_output e
substitution (${.is_default_output; .echo $?}) failed
$se {.is_default_output >dummy_file}
assertion is_default_output failed
call stack .is_default_output .scope se
$se {.is_default_output}
$.is_default_error 1
unacceptable argument count: received 1 non-optional, but needed 0 (with 0 optional) for .is_default_error
$.is_default_error {excess argfunc}
.is_default_error does not accept an argfunction with call stack: .is_default_error
$se {.is_default_error}
$
$# .list_executables
$.list_executables excess
unacceptable argument count: received 1 non-optional, but needed 0 (with 0 optional) for .list_executables
$.list_executables {excess argfunc}
.list_executables does not accept an argfunction with call stack: .list_executables
$.for ${.list_executables}$ {.combine $1 $nl}
!
!x
#
#!
##
+
-
./rwsh
./test_files/../rwsh
.a
.after_command
.ambiguous_prototype_dash_dash
.argc
.arguments_for_argfunction
.autofunction
.bad_argc
.bad_argfunction_style
.bad_args
.bad_if_nest
.before_command
.binary
.binary_does_not_exist
.binary_not_found
.break
.cd
.collect_errors_except
.collect_errors_only
.combine
.continue
.dash_dash_argument
.dash_star_argument
.directory_not_found
.disable_readline
.divide_by_zero
.double_redirection
.duplicate_parameter
.echo
.elipsis_first_arg
.elipsis_out_of_option_group
.else
.else_if
.else_if_not
.else_without_if
.enable_readline
.error
.excess_argfunction
.excessive_exceptions_collected
.excessive_exceptions_in_catch
.excessive_nesting
.exec
.exec_failed
.executable_already_exists
.execution_count
.exit
.failed_substitution
.fallback_handler
.false
.file_not_found
.file_open_failure
.flag_in_elipsis
.for
.for_each_line
.fork
.function
.function_all_flags
.function_not_found
.get_fallback_message
.get_max_collectible_exceptions
.get_max_extra_exceptions
.get_max_nesting
.getpid
.getppid
.global
.global_would_be_masked
.help
.if
.if_before_else
.illegal_function_name
.illegal_variable_name
.init
.input_range
.internal_error
.internal_features
.internal_functions
.internal_vars
.interrupted_sleep
.invalid_word_selection
.is_default_error
.is_default_input
.is_default_output
.last_exception
.last_execution_time
.list_environment
.list_executables
.list_locals
.local
.local_declare
.ls
.mismatched_brace
.mismatched_bracket
.mismatched_parenthesis
.missing_argfunction
.multiple_argfunctions
.nop
.not_a_directory
.not_a_function
.not_a_number
.not_catching_exception
.not_executable
.not_soon_enough
.post_dash_dash_flag
.post_elipsis_option
.prompt
.raw_command
.replace_exception
.result_range
.return_code
.rm_executable
.scope
.selection_not_found
.selection_set
.set
.set_fallback_message
.set_max_collectible_exceptions
.set_max_extra_exceptions
.set_max_nesting
.shutdown
.sigchld
.sigcont
.sighup
.siginfo
.sigint
.sigpipe
.sigquit
.sigterm
.sigtstp
.sigunknown
.sigusr1
.sigusr2
.source
.stepwise
.store_output
.tardy_flag
.test_executable_exists
.test_file_exists
.test_greater
.test_in
.test_is_number
.test_less
.test_not_empty
.test_number_equal
.test_string_equal
.test_string_unequal
.throw
.toggle_readline
.total_execution_time
.try_catch_recursive
.type
.unchecked_variable
.undeclared_variable
.undefined_variable
.unfinished_if_block
.unreadable_dir
.unrecognized_flag
.unset
.unused_before_set
.unused_variable
.usleep
.usleep_overhead
.var_add
.var_divide
.var_exists
.var_subtract
.variable_already_exists
.vars
.version
.version_compatible
.version_incompatible
.waiting_for_binary
.waiting_for_shell
.waiting_for_user
.whence_function
.which_path
.while
/
/bin/cat
/bin/echo
/bin/false
/bin/kill
/bin/rm
/bin/true
/usr/bin/env
/usr/bin/sort
a
af
b
c
caught_silent_throw
collecting_handler
conditional_echo
conditional_false
conditional_true
do_while
double_if_with_body
e
echo
echo-comments
elif
else
else_if_false
else_if_not_false
else_if_not_true
else_if_true
else_if_with_body
else_with_body
env
exec
fIJ
false
fn
fns
for
g
h
if_else_if_not_with_body
if_false
if_only
if_only_not
if_true
if_with_body
ntimes
obscured_else
om
outer_break
outer_continue
outer_for
outer_while
paren_if_words
polish
sa
scope_for
se
setf
silent_throw
single
sort
test
test_files/../rwsh
test_var_greater
test_var_not_equal
true
type
var_exists
var_in
var_less
var_val
whence
whichp
while_and_one_more
$
$# .ls
$.ls
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .ls
$.ls /bin {excess argfunc}
.ls does not accept an argfunction with call stack: .ls
$.ls /bin/usr/
could not find file /bin/usr/
call stack .ls
$.ls /bi  /us /nr
could not find file (/bi /us /nr)
call stack .ls
$.ls /bin /usr/
/bin
/usr/
$
$# .nop
$.nop
$.nop {optional argfunc}
$.nop 1 2 3 4 5
$
$# .replace_exception
$.replace_exception
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .replace_exception
$.replace_exception echo not in exception handler
.replace_exception called outside of an exception handler
call stack: .replace_exception
$.try_catch_recursive .replace_exception {
  .throw .replace_exception echo now in exception handler}
now in exception handler .throw .try_catch_recursive(body) .replace_exception .try_catch_recursive
$
$# .scope
$.scope {e $foo}
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .scope
$.scope () {.scope foo}
.scope requires an argfunction
stack .scope
$.scope a (y y) {echo illegal duplicate required parameter}
duplicated parameter in function definition: y
call stack: .scope
$.scope a ([-x] [-x]) {echo illegal duplicate flag parameter}
duplicated parameter in function definition: -x
call stack: .scope
$.scope a ([x x]) {echo illegal duplicate optional parameter}
duplicated parameter in function definition: x
call stack: .scope
$.scope a ([-x arg bar] [-y arg]) {echo illegal duplicate flag argument}
duplicated parameter in function definition: arg
call stack: .scope
$.scope a (-x [-x]) {echo evil duplication between flags positional}
duplicated parameter in function definition: -x
call stack: .scope
$.scope -- -- {echo -- as a prototype forbids even -- as arguments}
unacceptable arguments: for prototype --,
 found (--) excess
( call) stack: .scope
$.scope -- () {echo but ${.list_locals} is acceptable for empty prototype}
but -- is acceptable for empty prototype
$.scope () {echo no arguments are also good for empty prototype}
no arguments are also good for empty prototype
$.scope a (-- --) {echo -- cannot be a duplicate parameter}
duplicated parameter in function definition: --
call stack: .scope
$.scope a ([--] [--]) {echo [--] cannot be a duplicate flag parameter}
duplicated parameter in function definition: --
call stack: .scope
$.scope a ([--] --) {echo -- and [--] cannot both be parameters}
duplicated parameter in function definition: --
call stack: .scope
$.scope a ([-- arg]) {echo -- cannot take arguments}
optional -- parameter cannot take arguments ( ([-- arg]) ) with call stack: .scope
$.scope a ([arg -- foo]) {echo -- cannot be an argument}
optional -- parameter cannot take arguments ( ([arg -- foo]) ) with call stack: .scope
$.scope -x -y a b ([-?] args ...) {
  for ${.list_locals}$ {.combine $1 = $$1 \ }; .echo $nl}
-*=-x -y -?=-x -y args=a b 
$.scope a ([-? bad] arg) {e -? cannot currently take arguments}
optional -* parameter cannot take arguments ( ([-? bad]) ) with call stack: .scope
$.scope a ([-* bad] arg) {e -* (aka -?) cannot currently take arguments}
optional -* parameter cannot take arguments ( ([-* bad]) ) with call stack: .scope
$.scope -a -* -b a ([-?] a) {
  for ${.list_locals}$ {.combine $1 = $$1 \ }; .echo $nl}
-*=-a -* -b -?=-a -* -b a=a 
$.scope bar foo {echo aa $foo bb}
aa bar bb
$.scope baz bax (foo bar) {
  for ${.list_locals}$ {.combine $1 = $$1 \ }; .echo $nl}
bar=bax foo=baz 
$.scope foo bar baz bax (args ...) {echo aa $args$2 bb $args$1 cc}
aa baz bb bar cc
$.scope single ([-x] [--long-opt y] second) {
  var_val ${.list_locals}$; .echo $nl}
-*() second(single) 
$.function_all_flags a [-x] [--long-opt y] second {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }
  .combine $nl}
$whence a
.function_all_flags a [--long-opt y] [-x] second {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}
  .combine $nl}
$.function_all_flags pt -- args ... {
  .scope $args$ ([-x] [--long-opt y] second) {
    for ${.list_locals}$ {.combine $1 \( $$1 \) \ }}
  .combine $nl
  .scope $args$ ( [-?] [--long-opt y] second) {
    for ${.list_locals}$ {.combine $1 \( $$1 \) \ }}
  .combine $nl}
$whence pt
.function_all_flags pt -- args ... {
  .scope $args$ ([-x] [--long-opt y] second) {
    for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}}
  .combine $nl
  .scope $args$ ( [-?] [--long-opt y] second) {
    for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}}
  .combine $nl}
$a
unacceptable arguments: for prototype [--long-opt y] [-x] second,
 assigned -*=() ,
 but needed (second),
( call) stack: a
$a single
-*() second(single) 
$pt single
-*() second(single) 
-*() -?() second(single) 
$a -x single
-*(-x) -x(-x) second(single) 
$pt -x single
-*(-x) -x(-x) second(single) 
-*(-x) -?(-x) second(single) 
$a --long-opt arg single
-*(--long-opt arg) --long-opt(--long-opt arg) second(single) y(arg) 
$pt --long-opt arg single
-*(--long-opt arg) --long-opt(--long-opt arg) second(single) y(arg) 
-*(--long-opt arg) --long-opt(--long-opt arg) -?() second(single) y(arg) 
$a --long-opt single
unacceptable arguments: for prototype [--long-opt y] [-x] second,
 assigned -*=(--long-opt single) --long-opt=(--long-opt single) y=single ,
 but needed (second),
( call) stack: a
$pt --long-opt single
unacceptable arguments: for prototype [--long-opt y] [-x] second,
 assigned -*=(--long-opt single) --long-opt=(--long-opt single) y=single ,
 but needed (second),
( call) stack: (.scope pt)
$a --long-opt first -x --long-opt second single
-*(--long-opt first -x --long-opt second) --long-opt(--long-opt first --long-opt second) -x(-x) second(single) y(first second) 
$pt --long-opt first -x --long-opt second single
-*(--long-opt first -x --long-opt second) --long-opt(--long-opt first --long-opt second) -x(-x) second(single) y(first second) 
-*(--long-opt first -x --long-opt second) --long-opt(--long-opt first --long-opt second) -?(-x) second(single) y(first second) 
$.function_all_flags a [-?] [-first] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) \ }
  echo nothing_required}
$whence a
.function_all_flags a [-?] [-first] {
  for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}
  echo nothing_required}
$.function_all_flags pts -- [args ...] {
  .if var_exists args {
    .scope $args$ ([-first] [-?]) {
      .for ${.list_locals}$ {.combine $1 \( $$1 \) \ }}
      echo nothing_required}
  else {.scope ([-first] [-?]) {
      .for ${.list_locals}$ {.combine $1 \( $$1 \) \ }}
      echo nothing_required}}
$whence pts
.function_all_flags pts -- [args ...] {
  .if var_exists args {
    .scope $args$ ([-first] [-?]) {
      .for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}}
      echo nothing_required}
  else {.scope ([-first] [-?]) {
      .for ${.list_locals}$ {.combine $1 \( $$1 \) ( )}}
      echo nothing_required}}
$a
-*() -?() nothing_required
$pts
-*() -?() nothing_required
$a excess
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=() -?=() ,
 but found (excess) excess
( call) stack: a
$pts excess
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=() -?=() ,
 but found (excess) excess
( call) stack: (.scope .mapped_argfunction .if pts)
$a -to
-*(-to) -?(-to) nothing_required
$pts -to
-*(-to) -?(-to) nothing_required
$a -first --
-*(-first --) --(--) -?() -first(-first) nothing_required
$pts -first --
-*(-first --) --(--) -?() -first(-first) nothing_required
$a -first excess
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=-first -?=() -first=-first ,
 but found (excess) excess
( call) stack: a
$pts -first excess
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=-first -?=() -first=-first ,
 but found (excess) excess
( call) stack: (.scope .mapped_argfunction .if pts)
$a -to -- -first
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=(-to --) --=-- -?=-to ,
 but found (-first) excess
( call) stack: a
$pts -to -- -first
unacceptable arguments: for prototype [-?] [-first],
 assigned -*=(-to --) --=-- -?=-to ,
 but found (-first) excess
( call) stack: (.scope .mapped_argfunction .if pts)
$a -to -first
-*(-to -first) -?(-to) -first(-first) nothing_required
$pts -to -first
-*(-to -first) -?(-to) -first(-first) nothing_required
$
$# .selection_set
$.selection_set A
unacceptable argument count: received 1 non-optional, but needed 2 (with 0 optional) for .selection_set
$.selection_set A /usr {excess argfunc}
.selection_set does not accept an argfunction with call stack: .selection_set
$.selection_set A /usr
$echo $A$
/usr
$.selection_set A ./
$echo $A$
/usr/*
$.selection_set A local/include
$echo $A$
/usr/local/include
$.selection_set A ..
$echo $A$
/usr
$.selection_set A ()
$echo $A$
/usr
$.selection_set A ./local/../../bin
$echo $A$
/bin
$.selection_set A sbin etc
$echo $A$
/sbin etc
$
$# .set
$.set A
unacceptable argument count: received 1 non-optional, but needed 2 (with 0 optional) for .set
$.set 1 x
$1 cannot be set
call stack .set
$.scope [undefined] {.collect_errors_except .nop {
  .set undeclared is an error
  echo $undeclared}}
undeclared was not declared
call stack: .set .collect_errors_except .scope
undeclared was not declared
call stack: .collect_errors_except .scope
undefined was not checked with call stack .scope
$.scope [undefined] {.collect_errors_except .nop {
  .set undefined and also unchecked
  echo $undefined}}
(and also unchecked)
$.scope but_ignored [defined] {.collect_errors_except .nop {
  .set defined but also unchecked
  echo $defined}}
but_ignored
attempt to set defined before making use of its initial value
call stack .set .collect_errors_except .scope
$.scope unchanged [defined] {.collect_errors_except .nop {
  .set defined unchanged
  echo variable $defined by a set does not throw}}
variable unchanged by a set does not throw
$.scope [undefined] {.collect_errors_except .nop {
  if_only_not .var_exists undefined {.set undefined is checked}
  echo $undefined}}
(is checked)
$.set B x {excess argfunc}
.set does not accept an argfunction with call stack: .set
$.set A x
$echo $A
x
$
$# .try_catch_recursive .get_max_extra_exceptions .set_max_extra_exceptions
$.try_catch_recursive .function_not_found 
.try_catch_recursive requires an argfunction
$.try_catch_recursive {.test_less 0 A}
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .try_catch_recursive
$fn e_after {se {.argfunction}; echo after}
$e_after {.try_catch_recursive .not_a_number .function_not_found {
  .test_less 0 A}}
A is not a number
call stack: .test_less .try_catch_recursive(body)
after
$e_after {
  .try_catch_recursive .function_not_found .binary_not_found \
                       .failed_substitution {
    ..test_less 0 A}}
..test_less : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction .try_catch_recursive(body)
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction .try_catch_recursive(body)
..test_less : command not found ( ..test_less 0 A .try_catch_recursive(body) )
after
$e_after {.try_catch_recursive .not_a_number {.test_less 0 A}}
A is not a number
call stack: .test_less .try_catch_recursive(body)
after
$e_after {.try_catch_recursive .not_a_number {.cho A}}
.cho : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction .try_catch_recursive(body) .try_catch_recursive .scope se e_after
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction .try_catch_recursive(body) .try_catch_recursive .scope se e_after
.cho : command not found ( .cho A .try_catch_recursive(body) .try_catch_recursive .scope se e_after )
$e_after {.try_catch_recursive .not_a_number .function_not_found {echo A}}
A
after
$e_after {sa echo hi {.try_catch_recursive ${.internal_functions}$ {&&&args$}}}
hi
after
$.get_max_extra_exceptions excess
unacceptable argument count: received 1 non-optional, but needed 0 (with 0 optional) for .get_max_extra_exceptions
$.set_max_extra_exceptions
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .set_max_extra_exceptions
$.get_max_extra_exceptions {excess}
.get_max_extra_exceptions does not accept an argfunction with call stack: .get_max_extra_exceptions
$.set_max_extra_exceptions 1 {excess}
.set_max_extra_exceptions does not accept an argfunction with call stack: .set_max_extra_exceptions
$.set_max_extra_exceptions NaN
NaN is not a number
call stack: .set_max_extra_exceptions
$.set_max_extra_exceptions -1
value -1 is out of usable numeric range
call stack .set_max_extra_exceptions
$.scope () {.get_max_extra_exceptions; .echo $nl}
1
$.set_max_extra_exceptions 0
$.scope () {.get_max_extra_exceptions; .echo $nl}
0
$e_after {.try_catch_recursive .not_a_number {
  .try_catch_recursive .not_a_number {.test_less 0 A}}}
A is not a number
call stack: .test_less .try_catch_recursive(body) .try_catch_recursive .try_catch_recursive(body) .try_catch_recursive .scope se e_after
exceeded maximum number of exceptions ( 0 ) in try_catch.
call stack: .try_catch_recursive .try_catch_recursive(body) .try_catch_recursive .scope se e_after
$e_after {.try_catch_recursive .not_a_number {
  .try_catch_recursive .not_a_number {.test_less 0 A}}}
A is not a number
call stack: .test_less .try_catch_recursive(body) .try_catch_recursive .try_catch_recursive(body) .try_catch_recursive .scope se e_after
exceeded maximum number of exceptions ( 0 ) in try_catch.
call stack: .try_catch_recursive .try_catch_recursive(body) .try_catch_recursive .scope se e_after
$e_after {sa echo hi {.try_catch_recursive ${.internal_functions}$ {&&&args$}}}
hi
after
$.set_max_extra_exceptions 5
$.scope () {.get_max_extra_exceptions; .echo $nl}
5
$
$# .stepwise
$.function_all_flags wrapper args ... {a $args$ two; a $args$ three}
$.function_all_flags a args ... {e $args$ one $nl; e $args$ two $nl
  e $args$ three $nl}
$.function_all_flags d args ... {e $args$ $nl; .stepwise $args$ {d $*}}
$.stepwise {e $* $nl}
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .stepwise
$.stepwise wrapper 1 2
.stepwise requires an argfunction
$.stepwise stepwise {e $* $nl}
stepwise : command not found ( stepwise .stepwise )
$.stepwise .stepwise {e $* $nl}
$.stepwise wrapper 1 2 {e $* $nl}
a 1 2 two 
a 1 2 three 
$.function_all_flags wrapper args ... {a $args$ one
  a $args$ two; a $args$ three}
$wrapper 1 2
1 2 one one 
1 2 one two 
1 2 one three 
1 2 two one 
1 2 two two 
1 2 two three 
1 2 three one 
1 2 three two 
1 2 three three 
$.stepwise wrapper 1 2 {d $*}
a 1 2 one 
e 1 2 one one 
 
.echo 1 2 one one 
 
e 1 2 one two 
 
.echo 1 2 one two 
 
e 1 2 one three 
 
.echo 1 2 one three 
 
a 1 2 two 
e 1 2 two one 
 
.echo 1 2 two one 
 
e 1 2 two two 
 
.echo 1 2 two two 
 
e 1 2 two three 
 
.echo 1 2 two three 
 
a 1 2 three 
e 1 2 three one 
 
.echo 1 2 three one 
 
e 1 2 three two 
 
.echo 1 2 three two 
 
e 1 2 three three 
 
.echo 1 2 three three 
 
$.stepwise wrapper 1 2 {
  echo current line: $*
  if_only .test_string_equal $4 two {
    .collect_errors_except .nop {
      .throw .continue
      .throw .break
      .throw .continue}}
  .throw .continue
  echo not printed}
current line: a 1 2 one
current line: a 1 2 two
$.stepwise wrapper 1 2 {e $* $nl}
a 1 2 one 
a 1 2 two 
a 1 2 three 
$
$# .test_file_exists
$.test_file_exists
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .test_file_exists
$.test_file_exists dummy_file {excess argfunc}
.test_file_exists does not accept an argfunction with call stack: .test_file_exists
$.test_file_exists /b /in
assertion ( -e /b -e /in) failed
call stack .test_file_exists
$.test_file_exists /b /bin /in
$
$# .test_string_equal .test_string_unequal .test_not_empty .test_in
$.test_string_equal x
unacceptable argument count: received 1 non-optional, but needed 2 (with 0 optional) for .test_string_equal
$.test_string_equal x x x
unacceptable argument count: received 3 non-optional, but needed 2 (with 0 optional) for .test_string_equal
$.test_string_equal x x {excess argfunc}
.test_string_equal does not accept an argfunction with call stack: .test_string_equal
$.test_string_unequal x 
unacceptable argument count: received 1 non-optional, but needed 2 (with 0 optional) for .test_string_unequal
$.test_string_unequal x x x
unacceptable argument count: received 3 non-optional, but needed 2 (with 0 optional) for .test_string_unequal
$.test_string_unequal x x {excess argfunc}
.test_string_unequal does not accept an argfunction with call stack: .test_string_unequal
$.test_not_empty 
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .test_not_empty
$.test_not_empty x x
unacceptable argument count: received 2 non-optional, but needed 1 (with 0 optional) for .test_not_empty
$.test_not_empty x {excess argfunc}
.test_not_empty does not accept an argfunction with call stack: .test_not_empty
$.test_string_equal x y
assertion (x == y) failed
call stack .test_string_equal
$.test_string_equal x x
$.test_string_unequal x y
$.test_string_unequal x x
assertion (x != x) failed
call stack .test_string_unequal
$.test_not_empty \
assertion ( -n ) failed
call stack .test_not_empty
$.test_not_empty x
$.test_in
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .test_in
$.test_in x
assertion (x in) failed
call stack .test_in
$.test_in x x
$.test_in z y z
$.test_in w x y z
assertion (w in x y z) failed
call stack .test_in
$.test_in y x y z
$
$# .test_is_number .test_number_equal .test_greater .test_less
$.test_is_number
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .test_is_number
$.test_is_number 42 {excess argfunc}
.test_is_number does not accept an argfunction with call stack: .test_is_number
$.test_is_number ()
assertion (is_number  - NaN) failed
call stack .test_is_number
$.test_is_number 42a
assertion (is_number 42a - NaN) failed
call stack .test_is_number
$.test_is_number 42
$.test_is_number -0.314
$.test_is_number 6.022e9000000000
assertion (is_number 6.022e9000000000 - range) failed
call stack .test_is_number
$.test_is_number 6.022e23
$.test_number_equal 42
unacceptable argument count: received 1 non-optional, but needed 2 (with 0 optional) for .test_number_equal
$.test_number_equal 42 42 {excess argfunc}
.test_number_equal does not accept an argfunction with call stack: .test_number_equal
$.test_number_equal 42 42a
42a is not a number
call stack: .test_number_equal
$.test_number_equal 42b 42
42b is not a number
call stack: .test_number_equal
$.test_number_equal 0 0.000000000000000000000000001
assertion (0 -eq 0.000000000000000000000000001) failed
call stack .test_number_equal
$.test_number_equal 1e-9000000000 1e-9000000001
value 1e-9000000000 is out of usable numeric range
call stack .test_number_equal
$.test_number_equal 0 0.0
$.test_number_equal 42 42.01
assertion (42 -eq 42.01) failed
call stack .test_number_equal
$.test_number_equal 42 42
$.test_number_equal 6.022e9000000000 .6022e24
value 6.022e9000000000 is out of usable numeric range
call stack .test_number_equal
$.test_number_equal 6.022e23 .6022e9000000001
value .6022e9000000001 is out of usable numeric range
call stack .test_number_equal
$.test_number_equal 6.022e23 6.022e2
assertion (6.022e23 -eq 6.022e2) failed
call stack .test_number_equal
$.test_number_equal 6.022e23 .6022e24
$.test_greater 6.022e23
unacceptable argument count: received 1 non-optional, but needed 2 (with 0 optional) for .test_greater
$.test_greater 6.022e23c 6.022e23 {excess argfunc}
.test_greater does not accept an argfunction with call stack: .test_greater
$.test_greater 6.022e23c 6.022e23
6.022e23c is not a number
call stack: .test_greater
$.test_greater 6.022e23 6.022e23e
6.022e23e is not a number
call stack: .test_greater
$.test_greater 6.022e9000000000 .6022e23
value 6.022e9000000000 is out of usable numeric range
call stack .test_greater
$.test_greater 6.022e23 .6022e9000000001
value .6022e9000000001 is out of usable numeric range
call stack .test_greater
$.test_greater 6.022e2 6.022e23
assertion (6.022e2 -gt 6.022e23) failed
call stack .test_greater
$.test_greater 6.022e23 .6022e24
assertion (6.022e23 -gt .6022e24) failed
call stack .test_greater
$.test_greater 6.022e23 6.022e2
$.test_less 6.022e23
unacceptable argument count: received 1 non-optional, but needed 2 (with 0 optional) for .test_less
$.test_less 6.022b23 6.022e23 {excess argfunc}
.test_less does not accept an argfunction with call stack: .test_less
$.test_less 6.022b23 6.022e23
6.022b23 is not a number
call stack: .test_less
$.test_less 6.022e23 6.022a23
6.022a23 is not a number
call stack: .test_less
$.test_less 6.022e9000000000 .6022e23
value 6.022e9000000000 is out of usable numeric range
call stack .test_less
$.test_less 6.022e23 .6022e9000000001
value .6022e9000000001 is out of usable numeric range
call stack .test_less
$.test_less 6.022e23 6.022e2
assertion (6.022e23 -lt 6.022e2) failed
call stack .test_less
$.test_less 6.022e23 .6022e24
assertion (6.022e23 -lt .6022e24) failed
call stack .test_less
$.test_less 6.022e2 6.022e23
$
$# .enable_readline .disable_readline .toggle_readline
$.toggle_readline excess
unacceptable argument count: received 1 non-optional, but needed 0 (with 0 optional) for .toggle_readline
$.toggle_readline {excess}
.toggle_readline does not accept an argfunction with call stack: .toggle_readline
$.enable_readline excess
unacceptable argument count: received 1 non-optional, but needed 0 (with 0 optional) for .enable_readline
$.enable_readline {excess}
.enable_readline does not accept an argfunction with call stack: .enable_readline
$.disable_readline excess
unacceptable argument count: received 1 non-optional, but needed 0 (with 0 optional) for .disable_readline
$.disable_readline {excess}
.disable_readline does not accept an argfunction with call stack: .disable_readline
$.nop .enable_readline
$.nop .disable_readline
$.nop .toggle_readline
$.nop .toggle_readline
$
$# .test_executable_exists .type .whence_function
$# Arg_script::str() but only an unknown fraction of the lines
$# Arg_spec::str() (except trailing whitespace) only through SOON case
$.test_executable_exists
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .test_executable_exists
$.test_executable_exists j
assertion (executable exists: j) failed
call stack .test_executable_exists
$.test_executable_exists #
$.test_executable_exists .nop
$.test_executable_exists /bin/cat
$.test_executable_exists .mapped_argfunction
assertion (executable exists: .mapped_argfunction) failed
call stack .test_executable_exists
$.test_executable_exists .mapped_argfunction {.argfunction}
$.type
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .type
$.type j
j : command not found ( j .type )
$.type #
function
$.type .nop
builtin
$.type /bin/cat
file
$.type .mapped_argfunction
.mapped_argfunction : command not found ( .mapped_argfunction .type )
$.type .mapped_argfunction {.argfunction}
argfunction
$type .nop .mapped_argfunction j # {.argfunction}
.nop is builtin
.mapped_argfunction is .mapped_argfunction : command not found ( .mapped_argfunction .type .try_catch_recursive(body) )
j is j : command not found ( j .type .try_catch_recursive(body) )
# is function
$type -t .nop .mapped_argfunction j # {.argfunction}
builtin
.mapped_argfunction : command not found ( .mapped_argfunction .type .try_catch_recursive(body) )
j : command not found ( j .type .try_catch_recursive(body) )
function
$.whence_function
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .whence_function
$.whence_function j
j : command not found ( j .whence_function )
$.whence_function #
.function_all_flags # -- [ignored ...] {.nop $ignored$}
$.whence_function .nop
.nop
$.whence_function /bin/cat
/bin/cat
$.whence_function .mapped_argfunction
.mapped_argfunction : command not found ( .mapped_argfunction .whence_function )
$.whence_function .mapped_argfunction {.argfunction}
{.argfunction}
$whence .mapped_argfunction {.nop 1 () \ \\ \$ \@ \) \(}
{.nop 1 () ( \\) \$ \@ \) \(}
$whence .mapped_argfunction {.nop 1 () \  \\ \$ \@ \) \(}
{.nop 1 () ( ) \\ \$ \@ \) \(}
$whence .mapped_argfunction {@a @$a @$1 @$* @$*2}
{@a @$a @$1 @$*1 @$*2}
$whence .mapped_argfunction {>dummy_file}
{>dummy_file}
$# new tests here
$.whence_function .mapped_argfunction {{&&{&&x &&{e}}$$$ ${&&x ${e}}$$$ {&&&x &&&{e} {&&&&x &&&&{e}}}}}
{{&{&x &{e}}$$$ ${&x ${e}}$$$ {&&x &&{e} {&&&x &&&{e}}}}}
$whence .mapped_argfunction {$A $$A $0 $$$1 $# $* $*2 $A$$$ $A$10 $$*$ $$$*12$}
{$A $$A $0 $$$1 $# $* $*2 $A$$$ $A$10 $$*$ $$$*12$}
$.whence_function .mapped_argfunction {&&A &&0 &&* &&*3 &&$A$$$ &&$A$10 &&*$ &&*6$ {&&&A$ &&&A$10}}
{&A &0 &* &*3 &$A$$$ &$A$10 &*$ &*6$ {&&A$ &&A$10}}
$.function_all_flags wm [args ...] {
   .whence_function .mapped_argfunction {.argfunction}
   .scope $args$ (a1 a2 a3) {.argfunction}}
$wm (aa ab ac) bb cc {
  e x &&a1 &2 $a3 y &&a1$1 z &&a1$2; .nop $a2
  sa &&a1$ {e () w $args$ $#; e $nl}}
{
  e x &a1 bb $a3 y &a1$1 z &a1$2; .nop $a2
  sa &a1$ {e () w $args$ $#; e $nl}}
x aa ab ac bb cc y ab z ac w aa ab ac 4
$.scope (aa ab ac) bb cc (args more ...) {.scope $args $more$ (args more ...) {
  sa &1 {echo $args$ $#}
  sa &&args {echo $args$ $#}
  sa &&&args {echo $args$ $#}
  sa $args {echo $args$ $#}
  sa $args$ {echo $args$ $#}
  sa $more$ {echo $args$ $#}}}
((aa ab ac)) 2
(aa ab ac) 2
(aa ab ac) 2
(aa ab ac) 2
aa ab ac 4
bb cc 3
$.function_all_flags wm [args ...] {
   whence .mapped_argfunction {.argfunction}
   .nop $args
   se {.argfunction}
   .echo $nl}
$wm () {.echo \\\ \ \\\ \\\\ \ \\|\\\ \  \  \\ \( \) \\\)}
{.echo (\\  \\ \\\\) ( \\|\\  ) ( ) \\ \( \) \\)}
\  \ \\  \|\     \ ( ) \)
$wm () {.echo (\\  \\ \\\\) ( \\|\\  ) ( ) (\\) (\() (\)) (\\\))}
{.echo (\\  \\ \\\\) ( \\|\\  ) ( ) \\ \( \) \\)}
\  \ \\  \|\     \ ( ) \)
$wm () {.echo a\\bc\\d\\\\e fg\\|\\hij klm \\ \) \( \\\(}
{.echo a\\bc\\d\\\\e fg\\|\\hij klm \\ \) \( \\(}
a\bc\d\\e fg\|\hij klm \ ) ( \(
$wm () {
.echo \( \) \\( \\) \\\( \\\) \\\\( \\\\) \\\\\( \\\\\)}
{
.echo \( \) \\( \\) \\( \\) \\\\( \\\\) \\\\( \\\\)}
( ) \( \) \( \) \\( \\) \\( \\)
$wm () {
.echo \) \( \\) \\( \\\) \\\( \\\\) \\\\( \\\\\) \\\\\(}
{
.echo \) \( \\) \\( \\) \\( \\\\) \\\\( \\\\) \\\\(}
) ( \) \( \) \( \\) \\( \\) \\(
$wm () {.echo () xx(yy \$ \@ \$$ \@@ }
{.echo () xx(yy \$ \@ $$ @@}
 xx(yy $ @ $$ @@
$wm () {.echo (  ) (	) (
)}
{.echo (  ) (	) (
)}
   	 

$whence .mapped_argfunction {.nop 1}
{.nop 1}
$whence .mapped_argfunction {@a @$a @$1 @$* @$*2}
{@a @$a @$1 @$*1 @$*2}
$whence .mapped_argfunction {>dummy_file}
{>dummy_file}
$
$# .waiting_for_shell .waiting_for_user .waiting_for_binary
$# actual use of these builtins is in test_inconsistent.sh
$.waiting_for_shell j
unacceptable argument count: received 1 non-optional, but needed 0 (with 0 optional) for .waiting_for_shell
$.waiting_for_shell {excess argfunc}
.waiting_for_shell does not accept an argfunction with call stack: .waiting_for_shell
$# .waiting_for_shell
$.waiting_for_user j
unacceptable argument count: received 1 non-optional, but needed 0 (with 0 optional) for .waiting_for_user
$.waiting_for_user {excess argfunc}
.waiting_for_user does not accept an argfunction with call stack: .waiting_for_user
$# .waiting_for_user
$.waiting_for_binary j
unacceptable argument count: received 1 non-optional, but needed 0 (with 0 optional) for .waiting_for_binary
$.waiting_for_binary {excess argfunc}
.waiting_for_binary does not accept an argfunction with call stack: .waiting_for_binary
$# .waiting_for_binary
$
$# .last_exception
$.last_exception .last_exception
.function_not_found /bn/echo .last_exception /bn/echo
$.last_exception .nop

$.last_exception
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .last_exception
$.last_exception .try_catch_recursive {excess argfunc}
.last_exception does not accept an argfunction with call stack: .last_exception
$.last_exception .last_exception
.excess_argfunction .last_exception .try_catch_recursive {excess argfunc}
$.last_exception function_that_does_not_exist
function_that_does_not_exist : command not found ( function_that_does_not_exist .last_exception )
$.last_exception .try_catch_recursive
.not_a_number A .test_less .try_catch_recursive(body) .try_catch_recursive .try_catch_recursive(body) .try_catch_recursive .not_a_number {
  .try_catch_recursive .not_a_number {.test_less 0 A}}; .excessive_exceptions_in_catch 0 .try_catch_recursive .try_catch_recursive(body) .try_catch_recursive .not_a_number {
  .try_catch_recursive .not_a_number {.test_less 0 A}}
$.last_exception .last_execution_time

$.last_exception /bin/which
/bin/which : command not found ( /bin/which .last_exception )
$.last_exception /bin/cat
.file_open_failure non_existent_file /bin/cat <non_existent_file
$.last_exception /bin/echo

$.last_exception e

$.last_exception test_var_greater
.false 0 -gt 0 .test_greater test_var_greater n 0
$
$# .usleep .execution_count .last_execution_time
$# .total_execution_time
$.usleep_overhead excess
unacceptable argument count: received 1 non-optional, but needed 0 (with 0 optional) for .usleep_overhead
$.usleep_overhead {excess argfunc}
.usleep_overhead does not accept an argfunction with call stack: .usleep_overhead
$.usleep_overhead 
() is not a number
call stack: .usleep_overhead
$.usleep
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .usleep
$.usleep 800 {excess argfunc}
.usleep does not accept an argfunction with call stack: .usleep
$.usleep -6
value -6 is out of usable numeric range
call stack .usleep
$.usleep 5i
5i is not a number
call stack: .usleep
$.usleep 800
$# .usleep_overhead
$.execution_count
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .execution_count
$.execution_count j
j : command not found ( j .execution_count )
$.scope () {
  .execution_count .mapped_argfunction {echo not tracked}; .echo $nl}
0
$.scope () {
  .execution_count .usleep; .echo $nl}
5
$.last_execution_time
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .last_execution_time
$.last_execution_time j
j : command not found ( j .last_execution_time )
$.scope () {
  .last_execution_time .mapped_argfunction {echo not tracked}; .echo $nl}
0.000000
$# .last_execution_time .usleep
$.total_execution_time
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .total_execution_time
$.scope () {
  .total_execution_time .mapped_argfunction {echo not tracked}; .echo $nl}
0.000000
$.total_execution_time j
j : command not found ( j .total_execution_time )
$# .total_execution_time .usleep
$
$# .which_path
$echo ${.which_path cat}
unacceptable argument count: received 1 non-optional, but needed 2 (with 0 optional) for .which_path echo
substitution (${.which_path cat}) failed
$echo ${.which_path cat /bin {excess argfunc}}
.which_path does not accept an argfunction with call stack: .which_path echo
substitution (${.which_path cat /bin {excess argfunc}}) failed
$echo ${.which_path cat \ }
cat : binary not found in ( )
call stack: .which_path echo
substitution (${.which_path cat ( )}) failed
$echo ${.which_path does<not>exist /bin:/usr/bin}
does<not>exist : binary not found in /bin:/usr/bin
call stack: .which_path echo
substitution (${.which_path does<not>exist /bin:/usr/bin}) failed
$echo ${.which_path cat :/bin:/usr/bin}
/bin/cat
$echo ${.which_path cat /usr/bin/:/bin/:}
/bin/cat
$echo ${.which_path /bin/cat /usr/bin/:/bin/:}
/bin/cat
$echo ${.which_path rwsh /usr/bin:/bin}
/bin/rwsh
$echo ${.which_path rwsh .:/usr/bin:/bin}
./rwsh
$echo ${.which_path rwsh /usr/bin:/bin:.}
/bin/rwsh
$echo ${.which_path ./rwsh /usr/bin:/bin}
./rwsh : binary not found in /usr/bin:/bin
call stack: .which_path echo
substitution (${.which_path ./rwsh /usr/bin:/bin}) failed
$echo ${.which_path ./rwsh /bin:.}
./rwsh
$echo ${.which_path ../bin/rwsh /usr/bin:/bin}
../bin/rwsh : binary not found in /usr/bin:/bin
call stack: .which_path echo
substitution (${.which_path ../bin/rwsh /usr/bin:/bin}) failed
$echo ${.which_path rwsh :/usr/bin::/usr/bin:}
rwsh : binary not found in :/usr/bin::/usr/bin:
call stack: .which_path echo
substitution (${.which_path rwsh :/usr/bin::/usr/bin:}) failed
$echo ${.which_path rwsh /usr/bin:.}
./rwsh
$
$# .while
$.while {e ARGS}
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .while
$.while var_less A 4 
.while requires an argfunction
$.scope 0 A {.while var_less A 4 {echo printed; .throw .break; echo skipped}}
printed
$.scope 0 A {.while var_less A 4 {echo printed; .set A 4}}
printed
$.scope 4 A {.while var_less A 4 {echo skipped}}
$.while .nop {.throw echo exception within while}
exception within while .throw .mapped_argfunction .while
$.while silent_throw within condition {e body skipped}
exception within condition .throw .collect_errors_only silent_throw .while
$.while .throw .false because {echo body skipped}
$.scope 0 A {.while .throw .break {echo condition cannot break}}
.break thrown outside of control flow body
call stack: .throw .while .scope
A was unused with call stack .scope
$.scope 0 A {.while .throw .continue {echo condition cannot continue}}
.continue thrown outside of control flow body
call stack: .throw .while .scope
A was unused with call stack .scope
$.scope 0 A {.while var_less A 4 {echo body can break; .throw .break}}
body can break
$.scope 0 A {.while var_less A 4 {e in .while argfunction $A $nl; .var_add A 1}}
in .while argfunction 0 
in .while argfunction 1 
in .while argfunction 2 
in .while argfunction 3 
$.scope 0 A {.while var_in A 1 2 {echo A is $A; .var_add A 1}}
$.scope 0 A {do_while var_in A 1 2 {echo A is $A; .var_add A 1}}
A is 0
A is 1
A is 2
$.scope 1 A {.while var_in A 1 2 {echo A is $A; .var_add A 1}}
A is 1
A is 2
$.scope 1 A {while_and_one_more var_in A 1 2 {echo A is $A; .var_add A 1}}
A is 1
A is 2
A is 3
$fn throw_the_kitchen_sink cmd ... {
  $cmd$ {
    echo early in argfunction $A
    .var_add A 1
    if_only .test_less $A 3 {.throw .continue}
    .collect_errors_except .nop {
      .throw .continue
      .throw .break
      .throw .continue}
    echo late in .while argfunction $A}
  echo after $cmd$0
  .throw .break
  echo do not echo after a .break thrown outside control flow}
$.scope 0 A {throw_the_kitchen_sink .while var_less A 4}
early in argfunction 0
early in argfunction 1
early in argfunction 2
after .while
.break thrown outside of control flow body
call stack: .throw throw_the_kitchen_sink .scope
$.scope 0 A {throw_the_kitchen_sink do_while var_less A 4}
early in argfunction 0
.continue thrown outside of control flow body
call stack: .throw .mapped_argfunction .if if_only .try_catch_recursive(body)
early in argfunction 1
early in argfunction 2
after do_while
.break thrown outside of control flow body
call stack: .throw throw_the_kitchen_sink .scope
$.scope 3 A {throw_the_kitchen_sink do_while var_less A 6}
early in argfunction 3
.continue thrown outside of control flow body
call stack: .throw .collect_errors_except .try_catch_recursive(body)
.continue thrown outside of control flow body
call stack: .throw .collect_errors_except .try_catch_recursive(body)
.break thrown outside of control flow body
call stack: .throw .collect_errors_except .try_catch_recursive(body) .try_catch_recursive .try_catch_recursive(body)
after do_while
.break thrown outside of control flow body
call stack: .throw throw_the_kitchen_sink .scope
$.scope 0 A {throw_the_kitchen_sink while_and_one_more var_less A 4}
early in argfunction 0
early in argfunction 1
early in argfunction 2
early in argfunction 3
.continue thrown outside of control flow body
call stack: .throw .collect_errors_except .try_catch_recursive(body)
.continue thrown outside of control flow body
call stack: .throw .collect_errors_except .try_catch_recursive(body)
.break thrown outside of control flow body
call stack: .throw .collect_errors_except .try_catch_recursive(body) .try_catch_recursive .try_catch_recursive(body)
after while_and_one_more
.break thrown outside of control flow body
call stack: .throw throw_the_kitchen_sink .scope
$.function_all_flags tf N {.test_less $A $N}
$.scope 0 A {.while tf 4 {
  .if .test_number_equal 0 $A {.set A 1}
  .else {.function_all_flags tf N {.throw .false $N}}
  echo in overwriting argfunction}}
in overwriting argfunction
in overwriting argfunction
$.set_max_nesting 30
$fn IJK outer middle inner {
  .scope 0 I {
    .local sum 0
    .nop $sum
    $outer var_less I 5 {
      .var_add I 1
      .scope 0 J {
        $middle var_less J 2 {
          .var_add J 1
          if_only_not .test_string_equal ${e $I $J} (1 1) {.combine $nl}
          .combine $I . $J :
          .scope 0 K {
            $inner var_less K 30 {
              .var_add K 1
              if_only .test_less 1 $K {.echo ,}
              .echo $K
              .set sum ${+ $I + $J $K}
              .if .test_less 5 $sum$ {.throw outer_break}
              .else_if .test_less 4 $sum$ {.throw outer_continue}
              .else {}}}}}}}
  .echo $nl}
$IJK      .while      .while      .while
1.1:1,2,3Exception for failed handler. Original exception with call stack:
outer_continue .throw .mapped_argfunction .else_if .mapped_argfunction .while .scope .mapped_argfunction .while .scope .mapped_argfunction .while .scope IJK
.continue thrown outside of control flow body
call stack: .throw .mapped_argfunction .else_if .mapped_argfunction .while .scope .mapped_argfunction .while .scope .mapped_argfunction .while .scope IJK .replace_exception outer_continue
$IJK outer_while      .while      .while
1.1:1,2,3
2.1:1,2
3.1:1
4.1:1
$IJK      .while outer_while      .while
1.1:1,2,3
1.2:1,2
2.1:1,2
2.2:1
3.1:1
3.2:1
4.1:1
5.1:1
$IJK      .while      .while outer_while
1.1:1,2,3,4
1.2:1,2,3
2.1:1,2,3
2.2:1,2
3.1:1,2
3.2:1
4.1:1
4.2:1
5.1:1
5.2:1
$IJK outer_while outer_while outer_while
1.1:1,2,3,4
1.2:1,2,3
2.1:1,2,3
2.2:1,2
3.1:1,2
3.2:1
4.1:1
4.2:1
5.1:1
5.2:1
$.set_max_nesting 20
$
$# .var_add
$.set A 4
$.var_add
unacceptable argument count: received 0 non-optional, but needed 2 (with 0 optional) for .var_add
$.var_add A 1 2
unacceptable argument count: received 3 non-optional, but needed 2 (with 0 optional) for .var_add
$.var_add A 1 {excess argfunc}
.var_add does not accept an argfunction with call stack: .var_add
$.var_add B 1
B was not declared
call stack: .var_add
$.scope [undefined] {.var_add undefined 1}
optional variable undefined was not defined
call stack: .var_add .scope
undefined was not checked with call stack .scope
$.set A A
$.var_add A 2 
A is not a number
call stack: .var_add
$.set A 1e309
$.var_add A 2 
value 1e309 is out of usable numeric range
call stack .var_add
$.set A -1e308
$.var_add A A
A is not a number
call stack: .var_add
$.var_add A 1e309
value 1e309 is out of usable numeric range
call stack .var_add
$.var_add A -1e308
result of .var_add with arguments -1e308 and -1e308 is out of range
call stack: .var_add
$.var_add A 1e308
$.var_add A 1e308
$echo $A
1e+308
$.var_add A 1e308
result of .var_add with arguments 1e+308 and 1e308 is out of range
call stack: .var_add
$.var_add A -1e308
$echo $A
0
$.var_add A \
() is not a number
call stack: .var_add
$echo $A
0
$
$# .var_divide
$.var_divide A
unacceptable argument count: received 1 non-optional, but needed 2 (with 0 optional) for .var_divide
$.var_divide A 1 2
unacceptable argument count: received 3 non-optional, but needed 2 (with 0 optional) for .var_divide
$.var_divide A 1 {excess argfunc}
.var_divide does not accept an argfunction with call stack: .var_divide
$.var_divide B 1
B was not declared
call stack: .var_divide
$.scope [undefined] {.var_divide undefined 1}
optional variable undefined was not defined
call stack: .var_divide .scope
undefined was not checked with call stack .scope
$.set A A
$.var_divide A 2 
A is not a number
call stack: .var_divide
$.set A 1e3000000000
$.var_divide A 2 
value 1e3000000000 is out of usable numeric range
call stack .var_divide
$.set A 16.8
$.var_divide A A
A is not a number
call stack: .var_divide
$.var_divide A 1e3000000000
value 1e3000000000 is out of usable numeric range
call stack .var_divide
$.var_divide A 0 
attempt to divide 16.8 by 0 with call stack: .var_divide
$.var_divide A 4.2 
$echo $A
4
$.set A 1.8e-20
$.var_divide A 1e308
result of .var_divide with arguments 1.8e-20 and 1e308 is out of range
call stack: .var_divide
$.set A 0
$.var_divide A 1e308
$echo $A
0
$
$# .var_subtract
$.var_subtract
unacceptable argument count: received 0 non-optional, but needed 2 (with 0 optional) for .var_subtract
$.var_subtract A 1 2
unacceptable argument count: received 3 non-optional, but needed 2 (with 0 optional) for .var_subtract
$.var_subtract A 1 {excess argfunc}
.var_subtract does not accept an argfunction with call stack: .var_subtract
$.var_subtract B 1
B was not declared
call stack: .var_subtract
$.scope [undefined] {.var_subtract undefined 1}
optional variable undefined was not defined
call stack: .var_subtract .scope
undefined was not checked with call stack .scope
$.set A A
$.var_subtract A 2 
A is not a number
call stack: .var_subtract
$.set A 3000000000
$.var_subtract A 2 
$.set A 1e308
$.var_subtract A -1e308
result of .var_subtract with arguments 1e308 and -1e308 is out of range
call stack: .var_subtract
$echo $A
1e308
$.set A -1e308
$.scope () {.var_subtract A 1e308}
result of .var_subtract with arguments -1e308 and 1e308 is out of range
call stack: .var_subtract .scope
$echo $A
-1e308
$.set A -2147483648
$.var_subtract A A
A is not a number
call stack: .var_subtract
$.var_subtract A 3000000000
$.var_subtract A -2147483648
$.var_subtract A 2147483647
$.var_subtract A 2147483647
$echo $A
-7.29496e+09
$.var_subtract A 2147483647
$.var_subtract A -2147483648
$echo $A
-7.29496e+09
$.var_subtract A \
() is not a number
call stack: .var_subtract
$echo $A
-7.29496e+09
$
$# .version .version_compatible
$.version 1.0
unacceptable argument count: received 1 non-optional, but needed 0 (with 0 optional) for .version
$.version {excess argfunc}
.version does not accept an argfunction with call stack: .version
$.version_compatible
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .version_compatible
$.version_compatible 1.0 1.0
unacceptable argument count: received 2 non-optional, but needed 1 (with 0 optional) for .version_compatible
$.version_compatible 1.0 {excess argfunc}
.version_compatible does not accept an argfunction with call stack: .version_compatible
$echo ${.version}
0.3+
$.version_compatible 1.0
this shell is not compatible with requested version 1.0
call stack: .version_compatible
$.version_compatible 0.3+
$
$# internal functions
$# .after_command .raw_command .prompt
$# all of these are used as part of the test itself, though no longer in a
$# significant way.
$whence .after_command
.function_all_flags .after_command -- args ... {.nop $args}
$whence .prompt
.function_all_flags .prompt  {.echo \$}
$whence .raw_command
.function_all_flags .raw_command -- cmd {.echo $cmd; .echo (
)}
$
$# .before_command
$fn .before_command args ... {.echo $0 $args$; .echo $nl}
$.rm_executable .before_command
.before_command .rm_executable .before_command
$
$# .double_redirection
$# se {e hi #>dummy_file >dummy_file}
$# se {e hi >dummy_file}
$# se {e &{e hi #>dummy_file}}
$
$# .function_not_found
$se {se {not_a_thing; e should not be printed}}
not_a_thing : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction .scope se .scope se
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction .scope se .scope se
not_a_thing : command not found ( not_a_thing .scope se .scope se )
$.rm_executable .function_not_found
$.whence_function .function_not_found
Exception for failed handler. Original exception with call stack:
.function_not_found .function_not_found .whence_function
Exception for failed handler. Original exception with call stack:
.function_not_found .function_not_found .function_not_found .whence_function
.function_not_found : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction
$whence not_a_thing
not_a_thing : command not found ( not_a_thing .whence_function .try_catch_recursive(body) )
$not_a_thing
not_a_thing : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction
not_a_thing : command not found ( not_a_thing )
$.whence_function .function_not_found
.function_all_flags .function_not_found cmd [args ...] {.echo $cmd (: command not found) \( $cmd $args$ \); .echo (
)}
$
$# .help .internal_error
$.help
this is the default configuration for rwsh (or something copied from it), documentation should be available at rwsh.sf.net or rwsh.org
$.internal_error techincally this is untestable
internal error: techincally this is untestable
$
$# .mapped_argfunction .unescaped_argfunction .argfunction
$# .escaped_argfunction
$.mapped_argfunction 1 2 3 {echo a $* a}
a 1 2 3 a
$.mapped_argfunction
.mapped_argfunction : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction
.mapped_argfunction : command not found ( .mapped_argfunction )
$fn g {.whence_function .argfunction {.unescaped_argfunction}
     .whence_function .argfunction {.argfunction}
     .whence_function .argfunction {.escaped_argfunction}}
$g {}
{.whence_function .argfunction {}
     .whence_function .argfunction {.argfunction}
     .whence_function .argfunction {.escaped_argfunction}}
{}
{.argfunction}
$
$# .throw
$.throw
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .throw
$.throw .nop
$.throw .not_a_number 7
7 is not a number
call stack: .throw
$se {if_only .test_is_number 0 {
  .throw sa {echo even from $args$ 7 is a number}}}
even from .throw .mapped_argfunction .if if_only .scope se 7 is a number
$.throw .throw echo innocently
Exception for failed handler. Original exception with call stack:
.throw echo innocently .throw
innocently .throw .throw
$.throw .throw exception_bomb
Exception for failed handler. Original exception with call stack:
.throw exception_bomb .throw
Exception for failed handler. Original exception with call stack:
exception_bomb .throw .throw
exception_bomb : command not found ( exception_bomb .throw .throw )
exception_bomb : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction
$se {.try_catch_recursive echo {
      echo first
      .throw echo failing successfully
      echo second}
   echo third}
first
failing successfully .throw .try_catch_recursive(body)
third
$fn tribble [args ...] {
  .replace_exception tribble $args$
  .replace_exception tribble $args$
  echo the multiplication has begun $#}
$.try_catch_recursive tribble {.throw tribble}
the multiplication has begun 3
the multiplication has begun 5
the multiplication has begun 5
the multiplication has begun 8
Exception for failed handler. Original exception with call stack:
tribble .throw .try_catch_recursive(body) .replace_exception tribble .replace_exception tribble .try_catch_recursive
Exception for failed handler. Original exception with call stack:
tribble .throw .try_catch_recursive(body) .replace_exception tribble .replace_exception tribble .try_catch_recursive .replace_exception tribble
Exception for failed handler. Original exception with call stack:
tribble .throw .try_catch_recursive(body) .replace_exception tribble .replace_exception tribble .try_catch_recursive
Exception for failed handler. Original exception with call stack:
tribble .throw .try_catch_recursive(body) .replace_exception tribble .replace_exception tribble .try_catch_recursive
Exception for failed handler. Original exception with call stack:
tribble .throw .try_catch_recursive(body) .replace_exception tribble .replace_exception tribble .try_catch_recursive
exceeded maximum number of exceptions ( 5 ) in try_catch.
call stack: .try_catch_recursive
Exception for failed handler. Original exception with call stack:
tribble .throw .try_catch_recursive(body) .replace_exception tribble .replace_exception tribble .try_catch_recursive .replace_exception tribble
$.throw tribble
the multiplication has begun 2
Exception for failed handler. Original exception with call stack:
tribble .throw
Exception for failed handler. Original exception with call stack:
tribble .throw .replace_exception tribble
Exception for failed handler. Original exception with call stack:
tribble .throw .replace_exception tribble
$fn neverending [args ...] {.replace_exception neverending $args$}
$.throw neverending
Exception for failed handler. Original exception with call stack:
neverending .throw
Exception for failed handler. Original exception with call stack:
neverending .throw .replace_exception neverending
$.try_catch_recursive neverending {.throw neverending}
Exception for failed handler. Original exception with call stack:
neverending .throw .try_catch_recursive(body) .replace_exception neverending .replace_exception neverending .replace_exception neverending .replace_exception neverending .replace_exception neverending .try_catch_recursive
Exception for failed handler. Original exception with call stack:
neverending .throw .try_catch_recursive(body) .replace_exception neverending .replace_exception neverending .replace_exception neverending .replace_exception neverending .replace_exception neverending .try_catch_recursive .replace_exception neverending
exceeded maximum number of exceptions ( 5 ) in try_catch.
call stack: .try_catch_recursive
$fn sneaky [args ...] {
  .try_catch_recursive sneaky {.replace_exception sneaky $args$}}
$.try_catch_recursive sneaky {.throw sneaky}
Exception for failed handler. Original exception with call stack:
sneaky .throw .try_catch_recursive(body) .replace_exception .try_catch_recursive(body) .try_catch_recursive sneaky .replace_exception .try_catch_recursive(body) .try_catch_recursive sneaky .replace_exception .try_catch_recursive(body) .try_catch_recursive sneaky .replace_exception .try_catch_recursive(body) .try_catch_recursive sneaky .replace_exception .try_catch_recursive(body) .try_catch_recursive sneaky .try_catch_recursive
Exception for failed handler. Original exception with call stack:
sneaky .throw .try_catch_recursive(body) .replace_exception .try_catch_recursive(body) .try_catch_recursive sneaky .replace_exception .try_catch_recursive(body) .try_catch_recursive sneaky .replace_exception .try_catch_recursive(body) .try_catch_recursive sneaky .replace_exception .try_catch_recursive(body) .try_catch_recursive sneaky .replace_exception .try_catch_recursive(body) .try_catch_recursive sneaky .try_catch_recursive .replace_exception .try_catch_recursive(body) .try_catch_recursive sneaky
exceeded maximum number of exceptions ( 5 ) in try_catch.
call stack: .try_catch_recursive
$
$# .run_logic
$fn .run_logic flag cmd ... {
  .if .test_number_equal 0 $flag {.nop}
  .else_if $cmd$ {.nop}
  .else {.nop}}
$0 echo don't print nuthin'
$1 echo do print
do print
$1 .rm_executable .run_logic
$1 e executable not found
1 : binary not found in /bin:/usr/bin:.
call stack: .which_path .autofunction .autofunction
substitution (${.which_path $cmd $PATH}) failed
call stack: .autofunction
1 : command not found ( 1 e executable not found )
$
$# .vars
$.vars
FIGNORE
$
$## recursive function testing
$fn -n -- [args ...] {$args$; echo after $args$}
$-n -n -n -n
after
after -n
after -n -n
after -n -n -n
$-n -n -n echo -n
-n
after echo -n
after -n echo -n
after -n -n echo -n
$fn -n [-x] ignored -- [args ...] {
  echo before $args flags $-x$
  $args$
  .nop $ignored}
$-n -x -x a -n -x a -n a -n -x a
before (-n -x a -n a -n -x a) flags -x -x
before (-n a -n -x a) flags -x
before (-n -x a) flags
-x was unused with call stack -n -n -n -n
-* was unused with call stack -n -n -n -n
ignored was unused with call stack -n -n -n -n
args was not checked with call stack -n -n -n -n
optional variable args was not defined
call stack: -n -n -n -n
ignored was unused with call stack -n -n -n
ignored was unused with call stack -n -n
ignored was unused with call stack -n
$-n -x -x a -n -x a -n a echo -n -x a
before (-n -x a -n a echo -n -x a) flags -x -x
before (-n a echo -n -x a) flags -x
before (echo -n -x a) flags
-n -x a
$single .nop
unacceptable arguments: for prototype result,
 needed (result),
( call) stack: (.scope single)
$single - - 40 10 - 7 2 1
unacceptable arguments: for prototype result,
 assigned result=25 ,
 but found (1) excess
( call) stack: (.scope single)
$single - 40 10
30
$single - 40 - 10 2
32
$single / - + 40 10 2 2
24
$single - 40 - 10 - 7 2
35
$.function_all_flags excessive-commentary arg {#! shebang
  $arg first comment
  echo not a $arg; .nop second; echo either}
$excessive-commentary #
not a #
either
$echo-comments excessive-commentary #
#! shebang
# first comment
.nop second
$
$## environment testing i don't want to mess up everything else
$# check for extraneous variables and that export_env doesn't bless
$.scope M val (N necessary) {printenv; .nop $necessary}
added printenv to executable map in test suite
.var_exists=must be requested to be checked
?=.fork returned 255
A=-7.29496e+09
C=(external) () ( ) internal(parenthesis)
FIGNORE=*de*
LC_ALL=C
PATH=/bin:/usr/bin:.
broken=extra_close) (extra_open
nl=

original_message=Exception for failed handler. Original exception with call stack:

N=M
necessary=val
this printenv function has been brought to you by .autofunction
N was unused with call stack .scope
$
$# .list_environment
$.global SHELL unmodified
$.list_environment x
unacceptable argument count: received 1 non-optional, but needed 0 (with 0 optional) for .list_environment
$.list_environment {excess argfunc}
.list_environment does not accept an argfunction with call stack: .list_environment
$for ${.list_environment}$ {
  .scope $1$ (var val) {
    .if .test_in $var ? FIGNORE SHELL {echo $var : $$var to $val}
    .else {.global $var $val}}}
FIGNORE : *de* to ()
SHELL : unmodified to /bin/rwsh
$.combine $TESTABILITY $nl
an=external var(iable)
$echo $SHELL
unmodified
$.unset TESTABILITY
$for ${.list_environment}$ {
  .scope $1$ (var val) {setf $var $val; .nop $$var}}
$.combine $TESTABILITY $nl
an=external var(iable)
$echo $SHELL
/bin/rwsh
$printenv
.var_exists=must be requested to be checked
?=.fork returned 255
A=-7.29496e+09
C=(external) () ( ) internal(parenthesis)
FIGNORE=
LC_ALL=C
PATH=/bin:/usr/bin:.
SHELL=/bin/rwsh
TESTABILITY=an=external var(iable)
args=./rwsh -to
broken=extra_close) (extra_open
nl=

original_message=Exception for failed handler. Original exception with call stack:

this printenv function has been brought to you by .autofunction
$
$if_only_not test -z z {echo test throwing a .false exception}
added /usr/bin/test to executable map in test suite
test throwing a .false exception
$
$## unused variables
$# bless_unused_variables
$.scope () {}
$.scope -- () {}
$.scope -- () {echo $--}
--
$.scope -- (-- [a]) {}
a was unused with call stack .scope
$.scope () {.local a n; .local b o; .local c p}
a was unused with call stack .scope
b was unused with call stack .scope
c was unused with call stack .scope
$.scope () {
  .local a n; .local b o; .local c p
  echo $a $b $c $d
  .local d too_late}
d was not declared
call stack: .scope
$.scope () {
  .local a n; .local b o; .local c p
  echo $d $a $b $c
  .local d too_late}
a was unused with call stack .scope
b was unused with call stack .scope
c was unused with call stack .scope
d was not declared
call stack: .scope
$.scope n o p q (a b c d) {echo $a $b $c $d}
n o p q
$.scope n o p q (a b c d) {echo a b c d}
a b c d
a was unused with call stack .scope
b was unused with call stack .scope
c was unused with call stack .scope
d was unused with call stack .scope
$.scope n o (a [b] c [d]) {echo $a $c }
n o
b was not checked with call stack .scope
d was not checked with call stack .scope
$.scope n o ([a] b [c] d) {echo $b $d; .var_exists a}
n o
assertion (var exists: a) failed
call stack .var_exists .scope
c was not checked with call stack .scope
$.scope n o ([a] b [c] d) {echo $b; .var_exists c}
n
assertion (var exists: c) failed
call stack .var_exists .scope
a was not checked with call stack .scope
d was unused with call stack .scope
$.scope n ([a1 a2 a3 a4] b [c] [d1 d2] [e ...]) {echo $b}
n
a1 was not checked with call stack .scope
a2 was not checked with call stack .scope
a3 was not checked with call stack .scope
a4 was not checked with call stack .scope
c was not checked with call stack .scope
d1 was not checked with call stack .scope
d2 was not checked with call stack .scope
e was not checked with call stack .scope
$.scope n ([a1 a2 a3 a4] b [c] [d1 d2] [e ...]) {echo $b; .var_exists a4 d2 e c}
n
assertion (var exists: a4 d2 e c) failed
call stack .var_exists .scope
$.scope n ([a1 a2 a3 a4] b [c] [d1 d2] [e ...]) {echo $b; .var_exists a3 d1}
n
assertion (var exists: a3 d1) failed
call stack .var_exists .scope
c was not checked with call stack .scope
e was not checked with call stack .scope
$.scope n ([a1 a2 a3 a4] b [c] [d1 d2] [e ...]) {echo ${.list_locals} $b}
b n
$.scope n o p q r s ([a1 a2 a3 a4] b [c] [d1 d2] [e ...]) {echo ${.list_locals} $b}
(a1 a2 a3 a4 b c) r
a1 was unused with call stack .scope
a2 was unused with call stack .scope
a3 was unused with call stack .scope
a4 was unused with call stack .scope
c was unused with call stack .scope
$.scope n o p q r s t u ([a1 a2 a3 a4] b [c] [d1 d2]) {echo $a1 $d2}
n u
a2 was unused with call stack .scope
a3 was unused with call stack .scope
a4 was unused with call stack .scope
b was unused with call stack .scope
c was unused with call stack .scope
d1 was unused with call stack .scope
$.scope n o p q r s t u ([a1 a2 a3 a4] b [c] [d1 d2]) {
  echo $a1 $a2 $a3 $a4 $c $d1 $d2}
n o p q s t u
b was unused with call stack .scope
$.scope ([-a a1 a2 a3] [-b] [-c] [-d d1]) {}
-a was not checked with call stack .scope
a1 was not checked with call stack .scope
a2 was not checked with call stack .scope
a3 was not checked with call stack .scope
-b was not checked with call stack .scope
-c was not checked with call stack .scope
-d was not checked with call stack .scope
d1 was not checked with call stack .scope
-* was unused with call stack .scope
$.scope ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {}
-a was not checked with call stack .scope
a1 was not checked with call stack .scope
a2 was not checked with call stack .scope
a3 was not checked with call stack .scope
-b was not checked with call stack .scope
-c was not checked with call stack .scope
-d was not checked with call stack .scope
d1 was not checked with call stack .scope
-? was unused with call stack .scope
-* was unused with call stack .scope
$.scope ([-a a1 a2 a3] [-b] [-c] [-d d1]) {.var_exists -a -b -c -d}
assertion (var exists: -a -b -c -d) failed
call stack .var_exists .scope
$.scope ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {echo $-?; .var_exists -a -b -c -d}
()
assertion (var exists: -a -b -c -d) failed
call stack .var_exists .scope
$.scope ([-a a1 a2 a3] [-b] [-c] [-d d1]) {.list_locals; .echo $nl}
-*
$.scope -b -d darg ([-a a1 a2 a3] [-b] [-c] [-d d1]) {.list_locals; echo ()}
-* -b -d d1()
d1 was unused with call stack .scope
-d was unused with call stack .scope
-* was unused with call stack .scope
$.scope ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {echo ${.list_locals} $-?}
(-* -?) ()
$.scope -b -d darg -v ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {echo ${.list_locals} $-?}
(-* -? -b -d d1) -v
d1 was unused with call stack .scope
-d was unused with call stack .scope
-* was unused with call stack .scope
$.scope ([-a a1 a2 a3] [-d d1 d2]) {.var_exists a2 d2}
assertion (var exists: a2 d2) failed
call stack .var_exists .scope
$.scope ([-?] [-a a1 a2 a3] [-d d1 d2]) {.var_exists -? a3 d1}
-? was unused with call stack .scope
-* was unused with call stack .scope
$.scope ([-a a1 a2 a3] [-b] [-c] [-d d1]) {echo $-*}
()
$.scope ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {echo $-*}
()
$.scope n ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1] [e] f) {.local loc lval; echo $-*}
()
e was not checked with call stack .scope
f was unused with call stack .scope
loc was unused with call stack .scope
$.scope -c ([-a a1 a2 a3] [-b] [-c] [-d d1]) {echo $-c}
-c
-a was not checked with call stack .scope
a1 was not checked with call stack .scope
a2 was not checked with call stack .scope
a3 was not checked with call stack .scope
-b was not checked with call stack .scope
-d was not checked with call stack .scope
d1 was not checked with call stack .scope
-* was unused with call stack .scope
$.scope -b -c ([-a a1 a2 a3] [-b] [-c] [-d d1]) {echo $-c; .var_exists -a -b -d}
-c
$.scope -b -c ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {
  echo $-c; .var_exists -a -b -d -?}
-c
-? was unused with call stack .scope
-* was unused with call stack .scope
$.scope -b -c ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {
  echo $-c $-?; .var_exists -a -b -d}
-c ()
$.scope -b -c ([-a a1 a2 a3] [-b] [-c] [-d d1]) {echo $-b; .var_exists a2 d1}
-b
assertion (var exists: a2 d1) failed
call stack .var_exists .scope
-c was unused with call stack .scope
-* was unused with call stack .scope
$.scope -a n o p -b -c -d q ([-a a1 a2 a3] [-b] [-c] [-d d1]) {
  echo $-c; .var_exists -a -b -d}
-c
a1 was unused with call stack .scope
a2 was unused with call stack .scope
a3 was unused with call stack .scope
-a was unused with call stack .scope
d1 was unused with call stack .scope
-d was unused with call stack .scope
-* was unused with call stack .scope
$.scope -a n o p -b -c -d q ([-a a1 a2 a3] [-b] [-c] [-d d1]) {
  echo $-b; .var_exists a2 d1}
-b
a1 was unused with call stack .scope
a2 was unused with call stack .scope
a3 was unused with call stack .scope
-a was unused with call stack .scope
-c was unused with call stack .scope
d1 was unused with call stack .scope
-d was unused with call stack .scope
-* was unused with call stack .scope
$.scope -a n o p -b -c -d q ([-a a1 a2 a3] [-b] [-c] [-d d1]) {
  echo $-a $-b $-c $-d}
(-a n o p) -b -c (-d q)
$.scope -a n o p -b -c -d q ([-a a1 a2 a3] [-b] [-c] [-d d1]) {
  echo $a1 $a2 $a3 $d1; .var_exists -b -c}
n o p q
$.scope -a n o p -b -c -d q ([-a a1 a2 a3] [-b] [-c] [-d d1]) {
  echo $-*}
(-a n o p -b -c -d q)
$.scope -v -a n o p -b -c -d q ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {
  echo $a1 $a2 $a3 $d1; .var_exists -b -c}
n o p q
-? was unused with call stack .scope
-* was unused with call stack .scope
$.scope -v -a n o p -b -c -d q ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {echo $-?}
-v
a1 was unused with call stack .scope
a2 was unused with call stack .scope
a3 was unused with call stack .scope
-a was unused with call stack .scope
-b was unused with call stack .scope
-c was unused with call stack .scope
d1 was unused with call stack .scope
-d was unused with call stack .scope
-* was unused with call stack .scope
$.scope -v -a n o p -b -c -d q ([-?] [-a a1 a2 a3] [-b] [-c] [-d d1]) {echo $-*}
(-v -a n o p -b -c -d q)
$.scope -a n o p ([-a a1 a2 a3]) {echo $a1 $a3}
n p
a2 was unused with call stack .scope
-a was unused with call stack .scope
-* was unused with call stack .scope
$
$# .excessive_nesting Base_executable::exception_handler
$fn g {h}
$fn h {g}
$g
function exceeded max nesting ( 20 ). call stack: (h g h g h g h g h g h g h g h g h g h g h g)
$.stepwise g {e $* $nl; $*}
h 
function exceeded max nesting ( 20 ). call stack: (g h g h g h g h g h g h g h g h g h g h .mapped_argfunction .stepwise)
$fn .excessive_nesting args ... {.nop $args; h}
$g
Exception for failed handler. Original exception with call stack:
.excessive_nesting h g h g h g h g h g h g h g h g h g h g h g
Exception for failed handler. Original exception with call stack:
.excessive_nesting h g h g h g h g h g h g h g h g h g h g h .excessive_nesting
$fn .excessive_nesting args ... {.nop $args; e &&{.throw .nop}}
$fn .failed_substitution args ... {.nop $args; e $Z}
$g
Exception for failed handler. Original exception with call stack:
.excessive_nesting h g h g h g h g h g h g h g h g h g h g h g
Exception for failed handler. Original exception with call stack:
.failed_substitution &{.throw .nop} .excessive_nesting
Z was not declared
call stack: .failed_substitution
$.set_max_extra_exceptions 0
$e_after {.try_catch_recursive .undeclared_variable .excessive_nesting .failed_substitution {g}}
Exception for failed handler. Original exception with call stack:
.excessive_nesting g h g h g h g h g h g h g h g h g .try_catch_recursive(body) .try_catch_recursive .scope se e_after
Exception for failed handler. Original exception with call stack:
.failed_substitution &{.throw .nop} .excessive_nesting
Z was not declared
call stack: .failed_substitution
exceeded maximum number of exceptions ( 0 ) in try_catch.
call stack: .try_catch_recursive .scope se e_after
$.set_max_extra_exceptions 5
$e_after {.try_catch_recursive .undeclared_variable .excessive_nesting .failed_substitution {g}}
Z was not declared
call stack: .failed_substitution
Exception for failed handler. Original exception with call stack:
.excessive_nesting g h g h g h g h g h g h g h g h g .try_catch_recursive(body) .try_catch_recursive .scope se e_after
Exception for failed handler. Original exception with call stack:
.failed_substitution &{.throw .nop} .excessive_nesting
Z was not declared
call stack: .failed_substitution
Exception for failed handler. Original exception with call stack:
.failed_substitution &{.throw .nop} .excessive_nesting .try_catch_recursive .scope se e_after
$e_after {.try_catch_recursive .undeclared_variable .failed_substitution {
  e ${.throw .nop}}}
Z was not declared
call stack: .failed_substitution
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.throw .nop} .try_catch_recursive(body) .try_catch_recursive .scope se e_after
Z was not declared
call stack: .failed_substitution
$fn .else_without_if args ... {.nop $args; e ${.throw .nop}}
$e_after {.try_catch_recursive .undeclared_variable .else_without_if {
  .else {}}}
Exception for failed handler. Original exception with call stack:
.else_without_if .else .try_catch_recursive(body) .try_catch_recursive .scope se e_after
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.throw .nop} .else_without_if
Z was not declared
call stack: .failed_substitution
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.throw .nop} .else_without_if .try_catch_recursive .scope se e_after
$fn .failed_substitution args ... {.nop $args; e ${.throw echo foo}}
$e_after {.try_catch_recursive .undeclared_variable .failed_substitution {
  e ${.throw .nop}}}
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.throw .nop} .try_catch_recursive(body) .try_catch_recursive .scope se e_after
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.throw echo foo} .failed_substitution
foo .throw .failed_substitution .failed_substitution .try_catch_recursive .scope se e_after
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.throw echo foo} .failed_substitution .try_catch_recursive .scope se e_after
foo .throw .failed_substitution .failed_substitution .try_catch_recursive .scope se e_after
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.throw echo foo} .failed_substitution .try_catch_recursive .scope se e_after
foo .throw .failed_substitution .failed_substitution .try_catch_recursive .scope se e_after
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.throw echo foo} .failed_substitution .try_catch_recursive .scope se e_after
exceeded maximum number of exceptions ( 5 ) in try_catch.
call stack: .try_catch_recursive .scope se e_after
foo .throw .failed_substitution .failed_substitution
$fn .else_without_if args ... {.nop $args; e $Z}
$e_after {.try_catch_recursive .undeclared_variable .else_without_if {
  .else {}}}
Z was not declared
call stack: .else_without_if
Exception for failed handler. Original exception with call stack:
.else_without_if .else .try_catch_recursive(body) .try_catch_recursive .scope se e_after
Z was not declared
call stack: .else_without_if
$fn .failed_substitution args ... {.nop $args; .test_less 0 Z}
$e_after {.try_catch_recursive .not_a_number .failed_substitution {
  e ${.throw .nop}}}
Z is not a number
call stack: .test_less .failed_substitution
Exception for failed handler. Original exception with call stack:
.failed_substitution ${.throw .nop} .try_catch_recursive(body) .try_catch_recursive .scope se e_after
Z is not a number
call stack: .test_less .failed_substitution
$
$# exiting
$# .shutdown .exit
$.exit
unacceptable argument count: received 0 non-optional, but needed 1 (with 0 optional) for .exit
$.exit 1 {excess argfunction}
.exit does not accept an argfunction with call stack: .exit
$.exit not_a_number
not_a_number is not a number
call stack: .exit
$fn exit_exception args ... {echo $args$; .exit 0}
$.collect_errors_except .nop {
  .try_catch_recursive exit_exception {
    .collect_errors_only exit_exception {
      .throw exit_exception
      echo print expected after having collected exit exception}}
  echo after having run .exit (will not print)}
print expected after having collected exit exception
.throw .collect_errors_only .try_catch_recursive(body)

now terminating normally
