<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>

















  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">

















  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <title>Built-in commands</title>
</head>


<body>



Builtins take a fixed number of arguments, and will throw an argument
count error if they are passed a different
number.&nbsp;Builtins&nbsp;either return nonzero&nbsp;or throw an error
in the case
of failures, rather than printing any diagnostic text. They are
not intended to regularly be useful as something to run from the
command line. Instead they are intended to be useful building blocks
for shell functions.
<h3>.cd</h3>
















The .cd changes the current working directory to the path given as its
argument. If successful it sets CWD to the argument that was passed to
it. It returns the value returned by chdir.<br>




&nbsp;&nbsp;&nbsp; .cd does not open any file descriptors
<h3>.combine</h3>


The .combine command prints its arguments without any intervening
space. It does not append a newline. Note that this is the way to
combine the contents of multiple variables or to combine the contents
of a variable with fixed text in a single word.<br>


&nbsp;&nbsp;&nbsp; .combine opens the output file descriptor.
<h3>.echo</h3>

















The .echo command prints its arguments separated by a single space. It
does not append a newline. An echo function that prints its arguments
followed by a newline can easily be created from the .echo builtin and
the .newline builtin.<br>




&nbsp;&nbsp;&nbsp; .echo opens the output file descriptor.<br>
















<h3>.else</h3>


.else does not take any arguments, it runs its argfunction if IF_TEST
is false, and then sets IF_TEST to the empty string. It is a syntax
error for .else to occur except following .if and zero or more .else_if
and .else_if_not commands, or for a sequence of those commands to occur
without a .else.<br>




&nbsp;&nbsp;&nbsp; .else does not itself open any file descriptors.
<h3>.else_if</h3>
















.else_if returns 0 immediately if IF_TEST is true. Otherwise it runs
its arguments, setting IF_TEST to true, and running any argfunction if
they return 0. It is a syntax error for .else_if to occur except
between .if and .else.<br>




&nbsp;&nbsp;&nbsp; .else_if does not itself open any file descriptors.<br>

















<h3>.else_if_not</h3>
















.else_if_not is identical to .else_if except that it sets IF_TEST to
true and runs its argfunction only if the result of running its
arguments returns nonzero.<br>




&nbsp;&nbsp;&nbsp; .else_if_not does not itself open any file descriptors.<br>










<h3>.exec</h3>


.exec attempts to replace the shell with another executable using the
exec system call. The first argument is the name of the executable, any
remaining arguments are passed to that executable. The variable map is
used as the new environment. The current input, output and error file
descriptors are the default input, output, and error for the
executable. .exec can only return non-zero since it will never return
on success.<br>


&nbsp;&nbsp;&nbsp; .exec does not open any file descriptors.<br>



<h3>.exit</h3>


.exit causes the shell to exit before the next command is requested
from the user. It does not terminate any function (i.e. commands after
.exit in a function will be run). After any enclosing functions
complete, rwsh.shutdown will be run before the shell actually
terminates.<br>




&nbsp;&nbsp;&nbsp; .exit does not open any file descriptors.
<h3>.for</h3>










.for runs its argfunction once for each of its arguments, passing the argument to the argfunction each time as $1.<br>




&nbsp;&nbsp;&nbsp; .for does not open any file descriptors.<br>










<h3>.for_each_line</h3>








.for_each_line runs its argfunction once for each line of its input, passing the line as arguments to its argfunction.<br>




&nbsp;&nbsp;&nbsp; .for_each_line opens its input file descriptor.
<h3>.fork</h3>



<h3>.function</h3>

















.function inserts its argument function into the executable map. The first argument is used as the name for the new function.<br>




&nbsp;&nbsp;&nbsp; .function does not open any file descriptors.<br>

















<h3>.global</h3>










.global takes two arguments, a variable name and a value. If the
variable does not exist it is added to the variable_map with the given
value, if the variable does exist, then .global returns 1 and does not
change the variable map. Variables created in this way remain set after
the termination of the enclosing function.<br>




&nbsp;&nbsp;&nbsp; .global does not open any file descriptors.<br>










<h3>.if</h3>
















.if executes its arguments as a command, and then runs its argument
function&nbsp;if it has one and if the command returned 0. It is a
syntax error for .if to follow another .if, .else_if, or .else_if_not,
unless there is an .else between them. It is not a syntax error for .if
to have no argfunction. .if returns -1 on a syntax error, the return
value of its argfunction if it is run, and 0 otherwise. It sets IF_TEST
to true if its arguments returned 0, and to false otherwise.<br>




&nbsp;&nbsp;&nbsp; .if does not itself open any file descriptors.<br>










<h3>.importenv_overwrite</h3>










.importenv causes the environment that rwsh was run in to be imported
into the variable map. If a variable exists in both environments, the
external value is taken.<br>











&nbsp;&nbsp;&nbsp; .importenv_overwrite does not open any file descriptors.
<h3>.importenv_preserve</h3>










.importenv causes the environment that rwsh was run in to be imported
into the variable map. If a variable exists in both environments, the
internal value is taken.<br>




&nbsp;&nbsp;&nbsp; .importenv_preserve does not open any file descriptors.






<h3>.internal_errors</h3>















.internal_errors takes no arguments. It prints a list of those internal
functions which are run whether they exist or not (and will thus result
in rwsh.executable_not_found errors if they do not exist). Except for .init they are all reporting errors themselves.<br>




&nbsp;&nbsp;&nbsp; .internal_errors is implemented as a function which calls .echo, which opens &nbsp;its output.
<h3>.internal_features</h3>















.internal_features takes no arguments. It prints a list of those internal functions which are run only if they exist.<br>




&nbsp;&nbsp;&nbsp; .internal_features is implemented as a function which calls .echo, which opens its output.
<h3>.internal_vars</h3>















.internal_vars takes no arguments. It prints a list of those variables
that are written by the shell itself or affect the running of builtins.<br>




&nbsp;&nbsp;&nbsp; .internal_vars is implemented as a function which calls .echo, which opens its output.
<h3>.is_default_input</h3>









returns 1 if its input has been redirected away from the stdin of the shell.<br>




&nbsp;&nbsp;&nbsp; .is_default_input does not open any file descriptors.
<h3>.is_default_output</h3>









returns 1 if its output has been redirected away from the stdout of the shell.<br>




&nbsp;&nbsp;&nbsp; .is_default_output does not open any file descriptors.
<h3>.is_default_error</h3>









returns 1 if its error has been redirected away from the stdout of the shell.<br>




&nbsp;&nbsp;&nbsp; .is_default_error does not open any file descriptors.
<h3>.ls</h3>

















As it currently stands, .ls is a very stripped-down version of the
standard ls. Selection write and read work just as well with external
commands as with built-ins, so feel free to define the function ls to
use /bin/ls rather than .ls.<br>




&nbsp;&nbsp;&nbsp; .ls opens its output.<br>

















<h3>.nop</h3>
















.nop ignores its arguments, and leaves $? unchanged<br>




&nbsp;&nbsp;&nbsp; .nop does not open any file descriptors.<br>

















<h3>.return</h3>
















.return takes one argument, which it converts to an integer, and then
returns that value. It has more error conditions than any other builtin, besides .var_add and .var_divide.<br>




&nbsp;&nbsp;&nbsp; .return does not open any file descriptors.<br>
















<h3>.set</h3>

















.set changes the value of a variable in the variable map. the first argument is the
name of the variable, its second and any additional arguments are the value of the
variable.<br>




&nbsp;&nbsp;&nbsp; .set does not open any file descriptors.<br>

















<h3>.selection_set</h3>

















.selection_set is described in the selection document. Briefly, it is a
variant of .set, that treats the current value of the variable as a
path that should be modified by the second argument.<br>




&nbsp;&nbsp;&nbsp; .selection_set does not open any file descriptors.
<h3>.source</h3>
















.source attempts to run its first argument as a shell script. The
remaining arguments are passed to that shell script as its arguments. .source returns the value
returned by the script it ran.<br>




&nbsp;&nbsp;&nbsp; .source does not open any file descriptors (the script gets opened as a new file descriptor)
<h3>.stepwise</h3>












.stepwise treats its arguments as a function call, looks up this
function and interprets it with the given arguments, but rather than
running this function, it passes each statement in turn to its argument
function. &nbsp;To see what this means in practice look at test.result,
where stepwise commands are listed along with their output. Also look
at the functions "or" and "and" in rwshrc. The or function runs another
function, stopping after the first statement that succeeds. &nbsp;The
and function runs another function, stopping after the first statement
that fails. &nbsp;This is equivalent to rewriting a function in another
shell replacing each ";" with "||", and "&amp;&amp;" respectively.<br>




&nbsp;&nbsp;&nbsp; .stepwise does not itself open any file descriptors.
<h3>.store_output</h3>

.store_output takes one argument and one argfunction. It runs the
argfunction and if the argfunction returns zero, it stores the output
in the variable named by its argument
(which must exist in advance.) .store_output returns the value returned
by the argfunction. This is the way to handle cases where you want a
substitution, but also want specific handling of any error.<br>


&nbsp;&nbsp;&nbsp; .store_output does not itself open any file descriptors.
<h3>.test_equal</h3>










.test_equal takes two arguments. It returns 0 if those two arguments
are the same string. It returns 1 if those two arguments are different
strings.<br>




&nbsp;&nbsp;&nbsp; .test_equal does not open any file descriptors.

<h3>.test_greater</h3>


.test_greater takes two arguments. It returns 0 if both arguments
convert to numbers and the first argument is numerically greater than the
second argument. It returns 1 if the first argument is numerically less than or equal to the second argument.<br>


&nbsp;&nbsp;&nbsp; .test_greater does not open any file descriptors.
<h3>.test_less</h3>


.test_less takes two arguments. It returns 0 if both arguments convert
to numbers and the first argument is numerically less than the second
argument. It returns 1 if the first argument is numerically greater
than or equal to the second argument.<br>


&nbsp;&nbsp;&nbsp; .test_less does not open any file descriptors.
<h3>.test_is_number</h3>



.test_is_number takes one argument. It returns 0 if that argument can convert to a floating point number.<br>




&nbsp;&nbsp;&nbsp; .test_is_number does not open any file descriptors.
<h3>.test_not_empty</h3>
















.test_not_empty takes one argument. It returns 0 if that argument is not the empty string.<br>




&nbsp;&nbsp;&nbsp; .test_not_empty does not open any file descriptors.
<h3>.test_not_equal</h3>










.test_not_equal takes two arguments. It returns 0 if those two
arguments are different strings. It returns 1 if those two arguments
are the same string.<br>




&nbsp;&nbsp;&nbsp; .test_not_equal does not open any file descriptors.<br>










<h3>.test_number_equal</h3>



.test_number_equal takes two arguments. It returns 0 if both of those
arguments convert to the same floating point number. It returns 1 if
those two arguments convert to different floating point numbers. It
throws an error if it cannot convert either argument to a double
presion float.<br>



&nbsp;&nbsp;&nbsp; .test_number_equal does not open any file descriptors.
<h3>.unset</h3>










.unset takes one argument, the name of a variable to remove from the variable map.<br>




&nbsp;&nbsp;&nbsp; .unset does not open any file descriptors.
<h3>.usleep</h3>



.usleep takes one argument and then sleeps the shell for the specified number of microseconds.<br>



&nbsp;&nbsp;&nbsp; .usleep does not open any file descriptors.
<h3>.var_add</h3>










.var_add takes two arguments, the name of a variable and an integer
value to add to this variable.&nbsp;&nbsp;The set of errors is argument_count, not_a_number, input_range, and result_range.<br>




&nbsp;&nbsp;&nbsp; .var_add does not open any file descriptors.<br>





<h3>.var_subtract</h3>



.var_subtract takes two arguments, the name of a variable and an integer
value to subtract from this variable.&nbsp;The set of errors is argument_count, not_a_number, input_range, and result_range.<br>




&nbsp;&nbsp;&nbsp; .var_divide does not open any file descriptors.
<h3>.var_divide</h3>



.var_divide takes two arguments, the name of a variable and an integer
value to&nbsp;divide this variable by. The set of errors is
argument_count, not_a_number, input_range, result_range, and
divide_by_zero.<br>




&nbsp;&nbsp;&nbsp; .var_divide does not open any file descriptors.
<h3>.var_exists</h3>










.var_exists takes one argument, the name of a variable in the variable
map. If the variable is set then it returns 0. If the variable is not
set it returns 1.<br>




&nbsp;&nbsp;&nbsp; .var_exists does not open any file descriptors.<br>










<h3>.version</h3>

















.version prints out the version of rwsh that is currently running<br>




&nbsp;&nbsp;&nbsp; .version opens its output.
<h3>.version_available</h3>
















.version_available takes no arguments, and prints out a list of those that would return true if passed to .version_compatible.<br>




&nbsp;&nbsp;&nbsp; .version_available opens its output.





<h3>.version_compatible</h3>



.version_compatible takes one argument, and returns 0 if that argument
is an rwsh version number compatible with this one. At the current
time, only the current version will cause .version_compatible to return
0.<br>




&nbsp;&nbsp;&nbsp; .version_compatible does not open any file descriptors.
<h3>.waiting_for_binary</h3>





.waiting_for_binary prints the total amount of time that the shell has
spent waiting for other processes that it has forked to terminate.<br>




&nbsp;&nbsp;&nbsp; .waiting_for_binary opens its output.
<h3>.waiting_for_shell</h3>





.waiting_for_shell prints the amount of time since
startup that the shell has not been waiting for input from the user, or
waiting for a binary to terminate, so that the sum of the three will
exactly equal the wall time elapsed since startup.<br>





&nbsp;&nbsp;&nbsp; Although it probably doesn't matter, all of the timing calculations are included within .waiting_for_shell.<br>




&nbsp;&nbsp;&nbsp; .waiting_for_shell opens its output.




<h3>.waiting_for_user</h3>





.waiting_for_user prints the total amount of time that the shell has spent waiting for commands to be entered.<br>




&nbsp;&nbsp;&nbsp; .waiting_for_user opens its output.
<h3>.which_executable</h3>

















.which_executable prints the value stored in the executable map at the name given
in its first argument. Functions are printed by giving the command that
would create that function. Built-ins just print their name. Executable
files are added to the executable map when they are run. If an
executable file has been run, then .which_executable will print the name of the
file, otherwise it will inform you that it is not in the executable
map, whether or not the file exists and is executable.
rwsh.mapped_argfunction and rwsh.argfunction are both recognized as
names for whatever argument function might have been passed to .which_executable,
and are printed with just their enclosing braces.<br>




&nbsp;&nbsp;&nbsp; .which_executable opens its output.<br>










<br>










<h3>.which_execution_count</h3>







.which_execution_count prints the number of times that the executable
specified by its first argument has been run. It returns 1 if the
executable does not exist in the executable map.<br>




&nbsp;&nbsp;&nbsp; .which_execution_count opens its output.<br>










<br>










<h3>.which_last_execution_time</h3>






.which_last_execution_time prints the amount of time that&nbsp;the
executable
specified by its first argument took to run the last time it was run.
This is wall time as opposed to time that the shell was active. It
returns 1 if the
executable does not exist in the executable map.<br>




&nbsp;&nbsp;&nbsp; .which_last_execution_time opens its output.<br>










<br>










<h3>.which_total_execution_time</h3>







.which_total_execution_time prints the amount of time that the executable
specified by its first argument has taken to run since it was added to the executable map. It returns 1 if the
executable does not exist in the executable map.<br>




&nbsp;&nbsp;&nbsp; .which_total_execution_time opens its output.
<h3>.which_path</h3>










.which_path takes two arguments. The first is the name of the
executable to search for, the second is the colon-separated search path
within which to look for it. If an executable is found, it is printed,
otherwise an error is returned.<br>




&nbsp;&nbsp;&nbsp; .which_path opens its output.






<h3>.which_return</h3>










.which_return takes one argument, the name of an executable in the
executable map. If the executable is found, then it prints the last
value returned by that executable, and then returns 0. If the
executable is not found, then it returns 1. If the executable name is
rwsh.argfunction or rwsh.mapped_argfunction, then it returns 2.<br>




&nbsp;&nbsp;&nbsp; .which_return opens its output.
<h3>.which_test</h3>










.which_test takes one argument, the name of an executable to look up in
the executable map. If one is found it returns 0. Otherwise it returns
1. It does not print any text.<br>




&nbsp;&nbsp;&nbsp; .which_test does not open any file descriptors.<br>










<h3>.while</h3>



.while runs its arguments as a command, and for each time that they
return 0, it runs its argument function. &nbsp;Note: a loop of the form
".while .return $X {...}" will either not run its argument function or
run it until it throws an error. &nbsp;$X is interpretted once, before
the
statement is run, and however the argument function might change the
value of X, it cannot change the value that it used to have.<br>




&nbsp;&nbsp;&nbsp; .while does not itself open any file descriptors.
</body>
</html>
