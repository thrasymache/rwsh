<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
  <title>argument functions</title>
</head>
<body>
Along with normal text arguments, commands can include argument functions enclosed in braces. For example,<br>
%function sel {echo $SELECT}<br>
The function builtin is passed "sel" as $1 and "echo $SELECT" as an
argument function. The function builtin creates a new function in the
executable map using $1 for the name and the argument function for the
content. Braces are recognized as special characters, and do not need
any whitespace around them, they may also occur anywhere in the command
line, not just at the end (e.g. "%function{echo $SELECT}sel" is
equivalent to the command given above.) Empty braces ("{}") refer to
the same empty command that a blank line does.<br>
<br>
There are also four constructs named like internal functions to permit
user-defined functions to use argument functions themselves:
rwsh.mapped_argfunction, rwsh.unescaped_argfunction, rwsh.argfunction
and rwsh.escaped_argfunction. Each of these is used as an executable
name to get the special meaning. Since they are not keywords, they can
be used as arguments to commands without the shell interfering. Of them
only rwsh.mapped_argfunction can take arguments itself.<br>
<br>
<h3>rwsh.mapped_argfunction</h3>
rwsh.mapped_argfunction executes its argument function with the given arguments. For example<br>
<br>
rwsh.mapped_argfunction z c {echo x y $1; echo a b $2; echo $0}<br>
<br>
will output<br>
<br>
x y z<br>
a b c<br>
rwsh.mapped_argfunction<br>
<br>
Nested argument functions are possible, and variables are not
interpretted for argument functions until they are run. For example<br>
rwsh.mapped_argfunction 1 2 3 {echo $*; rwsh.mapped_argfunction a b $1 {echo $*; rwsh.mapped_argfunction x $2 $3 {echo $*}}}<br>
<br>
will output<br>
<br>
1 2 3<br>
a b 1<br>
x b 1<br>
<br>
<h3>rwsh.unescaped_argfunction and rwsh.argfunction</h3>
Suppose that you wanted a function to provide a shorter name for
%function. What you need is a way of passing the argument function for
the current function an an argument function to the command that it
calls. Each time an argument script is interpretted
rwsh.unescaped_argfunction is replaced by the current argument function
and rwsh.argfunction is replaced by rwsh.unescaped_argfunction.<br>
<br>
so if you type<br>
%function fn {%function $* {rwsh.argfunction}}<br>
<br>
the result of interpretting the command line results in<br>
<br>
%function fn {%function $* {rwsh.unescaped_argfunction}}<br>
<br>
which places "%function $* {rwsh.unescaped_argfunction}" in the executable_map with name fn.<br>
<br>
if you then type <br>
<br>
fn sel {echo $SELECT}<br>
<br>
the command is unchanged by interpretation, and the function that is stored under fn gets interpretted to be<br>
<br>
%function sel {echo $SELECT}<br>
<br>
If we had instead typed<br>
%function fn {%function $* {rwsh.unescaped_argfunction}}<br>
<br>
It would have been interpretted to result in<br>
%function fn {%function $* {%function $* {rwsh.unescaped_argfunction}}}<br>
<br>
The result would have been a function that takes an argument function
and defines a second function which, when run, would define a function
to execute the argument function that was passed to the first function.<br>
<br>
The which command seeks to describe what is in the executable map in
the terms that you would use to put it there rather than what is
actually there. Thus<br>
which fn<br>
<br>
prints out<br>
%function fn {%function $* {rwsh.argfunction}}<br>
<br>
instead of what is stored, which is<br>
%function $* {rwsh.unescaped_argfunction}<br>
<br>
The which command also recognizes the names rwsh.mapped_argfunction and
rwsh.argfunction to request the printing of the specified argument
function. In these cases the "%function rwsh.argfunction " part of the
print out is omitted for various reasons. For example, we could define
fn_v<br>
<br>
fn fn_v {%echo adding \ ; which rwsh.argfunction {rwsh.argfunction}; %echo \ to executable map as $1; fn $* {rwsh.argfunction}}<br>
<br>
then running<br>
fn_v sel {echo $SELECT}<br>
<br>
would print out<br>
adding {echo $SELECT} to executable map as sel<br>
<br>
<h3>rwsh.escaped_argfunction</h3>
Suppose you wanted to define rwsh.init such that it defined a function
fn which was equivalent to %function. It needs to encorporate the
argument function, but not rwsh.init's argument function, fn's argument
function. The solution is rwsh.escaped_argfunction, which is replaced
by rwsh.argfunction when interpretted. If that was all we wanted to
have in rwsh.init, it would be defined as follows:<br>
%function rwsh.init {%function fn {%function $* {rwsh.escaped_argfunction}}}<br>
</body>
</html>
