<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>




  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  <title>function prototypes and option handling</title>
</head>


<body>
Function prototypes in rwsh were inspired by the command synopsis
entries found in UNIX man pages. Most of the syntax that I have seen
used in man pages is unambiguous enough for a program to parse, and
they quickly make clear what arguments are acceptable or not to a
command. One specific piece of syntax that cannot be supported is
separating options by a vertical bar (e.g. "[files | directories]"), as
there is no support to restrict what a variable can contain based upon
its contents. Others include using keywords to stand in for unnamed
options, using the same identifier for multiple parameters, or any use
of braces. Three of these can be seen in the following synopsis entry,
along with a violation the current requirement that an elipsis must be
preceeded by a space: "grep [options] [-e PATTERN | -f FILE]
[FILE...]". I take some consolation in that this synopsis entry is
actually a lie, because grep will not accept zero arguments, which is
implied by all of the above parameters being surrounded by brackets.<br>
<br>
Currently, functions defined with .function_all_flags or
.function_some_flags are
defined
with a function prototype, functions defined by .function are not. When
the prototypes become flexible enough to handle all cases currently in
use, .function and non-prototyped functions will be removed. Additional
builtins to define functions with different command line expectations
may be added later. There will be
support for
multiple single-character flag options grouped behind a single dash.
There may be support for other common option-handling paradigms (e.g.
that long-options can occur after<span style="font-weight: bold;">
</span>some
positional arguments, or that arguments to flag options can be given
with an equals-sign). There will not be support for historical tar
style or
similar paradigms, which include rules like all characters following an
"f" in a group of short options are an argument to the -f flag. That
lack of support should only cause function wrappers for such programs
to be more restrictive in the syntax that they will accept than the
programs themselves require, or at least that the functions are
more restrictive in the syntax which they can add functionality to.<br>
<h3>required arguments</h3>




Arguments to .function_all_flags that follow the function name, are
not enclosed in brackets and are not "..." are interpreted as required
arguments. Given the following definition of a "grep" function,<br>




<pre>.function_all_flags grep regex file {<br>    .selection_set s $file; &amp;{whichp grep} $regex @$s}</pre>



running grep with&nbsp;zero, one,&nbsp;three or more arguments will
produce an error that the wrong number of arguments was passed. If this
grep is run with exactly two arguments, then the named parameters are
filled in as local variables, and can be accessed for the duration of
the function in the same way that global variables are. (Additional
local variables can be defined with the .local builtin.)

<h3>flag options and $-*</h3>




Arguments in the prototype that are surrounded by brackets and begin
with a dash are treated as flag options.  Given the following definition of a "grep" function,<br>




<pre>.function_all_flags grep [-i] regex file {<br>    .selection_set s $file; &amp;{whichp grep} $-i$ $regex @$s}</pre>



running grep will be the same as the two required argument version,
except that additional arguments are accepted, if and only if these
arguments are "-i" and they preceed the two required arguments. The $-i
variable will also be defined for the execution of the function, and it
will contain the text of all the matching flags. It will be the empty
string if the flag is not passed. It will be "-i" if the flag is passed
once, and it will be "-i -i" if the flag is passed twice, etc. The flag
variable is referenced as "$-i$" above because it will avoid passing an
empty string argument to the grep binary if -i was not passed to the
function, and separates the flags if multiple were passed. Multiple
different flags can be handled as well, and are made more convenient by
$-*. The following two function definitions are roughly equivalent:<br>



<pre>.function_all_flags grep [-i] [-c] [-n] regex file {<br>    .selection_set s $file; &amp;{whichp grep} $-i$ $-c$ $-n$ $regex @$s}<br>.function_all_flags grep [-i] [-c] [-n] regex file {<br>    .selection_set s $file; &amp;{whichp grep} $-*$ $regex @$s}</pre>

The difference between them is that the first will call the grep binary
with the -i options first, the -c options second and the -n options
third, while the second will call the grep binary with the options in
the order in which they were passed. The $-* local variable is defined
for all functions that take flag options, and is filled in with all of
the flag options that were passed. The fact that the $-* variable is
not defined for all functions that take zero flag options permits these
functions to make use of the $-* from the calling function (e.g. in the
argfunction of user-defined control flow).<br>
<br>
Flag options can also take arguments:<br>
<pre>.function_some_flags cut [-b b_list] [-c c_list] [-f f_list] [-d delim] cut file {<br>    if_only .var_not_empty -d {echo using $delim as delimiter because $-d was passed}<br>   &nbsp;.selection_set s $file<br>    &amp;{whichp cut} $-*$ @$s}</pre>
This defines a cut which has four flags which take arguments. If any of
those flags are passed, the argument following the flag is assigned as
the value of the local variable named after the flag. In these cases
flag variable will contain not only its own name, but also the argument
that was passed to it. For the cut executable, the -b, -c, and -f
options are mutually exclusive, and the -d option is only meaningful if
-f is passed as well. The corresponding man page on my system expresses
this with three variant commands, each of which has one required flag.
There is currently no support for a "required flag", (i.e. a function
that is defined so that rwsh will throw an exception rather than
running it if it does not have some specific flag passed to it), nor
for variant commands with there being multiple different prototypes
which could be used. So the example above depends upon the binary to
identify these errors.<br>
<br>
Parameters that begin with a dash, but are not surrounded by
brackets are treated as ordinary required arguments, and will be filled
in with whatever argument appears at that point in the command line.
This may change in the future. Currently, all flag options must precede all positional arguments. Also
currently, a bare dash is treated as a flag, as this involves the least
special-casing, if the existing uses for dash all end up being as a placeholder
indicating stdin, then this may change.<br>




<h3>[--]</h3>

"--" can be used to end the search for flag options so that subsequent
arguments that begin with a dash are treated as positional arguments.
This will happen regardless of whether "[--]" is included in the
function prototype. If an inappropriate number of positional arguments
are encountered, "--" is counted amongst the optional arguments found.
The $-- variable will be set to the value "--" if it occurs in a
command line. If the function has declared flag options, then the "--"
will also be included at the end of the $-*
variable, whether or not any flag options have been passed on this
command line. If the function has not declared flag options, then only
the $-- variable will be set. Note that if "--" occurs more than once
in the command
line that the first occurrence will be recognized as terminating the
flag arguments and any subsequent occurrences will be treated as
positional arguments. Also note that because "[--]" is implicitly in
every function prototype, "--" cannot be a required parameter.

<h3>.function_all_flags versus .function_some_flags</h3>
The main difference between .function_all_flags and
.function_some_flags is that functions defined with .function_all_flags
will throw an rwsh.unrecognized_flag flag exception if they are called
with a flag that has not been declared, and functions defined with
.function_some_flags will not.&nbsp;All functions will only define
local variables for those parameters that have been declared, but all
flags are kept in the variable $-*, and so non-declared options are
accessible there (presumably to be passed on to some executable that
takes more options than the function needs to have special handling
for). Because there is an expectation that &nbsp;non-declared flag
options will be passed to and will be significant to functions declared
with .function_some_flags, $-* is defined for all such functions,
regardless of whether or not they explicitly declare any flag options.
This is the secondary difference between .function_all_flags and
.function_some_flags. Note that because .function_some_flags defines
the flag portion of a command line to end with the first non-flag
argument group, it will not properly handle flags that have not been
declared that also take options.&nbsp;
<h3>optional positional arguments (non-flag options)</h3>
Arguments in the prototype that are surrounded by brackets that do not
begin with a dash are treated as optional positional arguments, and
arguments given to the function in the corresponding positions will
be. Note that local variables corresponding to optional positional
arguments will not be defined if the optional argument is not present.
The empty string can be passed as an argument, either literally as
"()", or as the value of a variable which itself contains the empty
string. If and only if the empty string is passed as an argument that
is used for a non-flag option, then the variable will be defined but
empty.<br>



<br>



It is most common for optional positional arguments to be
individual arguments and follow the required arguments, but neither of
these is necessary. Optional positional arguments will be filled in in
the order in which they are encountered, while reserving enough
arguments to fill in the required arguments. given the following
definition:<br>




<br>




** do a function definition that won't cause variable undefined errors<br>




**** echo_vars_that_exist * do it with a for loop and .local comma ,*
add this to the startup script, and make a variant of this that prints
the name of the variable in test_main.sh<br>




<pre>.function_all_flags foo [a] [b] c [d] {.echo $a , $b , $c , $d $nl}</pre>




***<br>




foo -&gt; error 0 1 0<br>




foo x -&gt; , , x ,<br>




foo x x -&gt; x , , x ,<br>




foo x x x -&gt; x , x , x ,<br>




foo x x x x -&gt; x , x , x , x<br>




foo x x x x x -&gt; error 2 1 3<br>




***<br>




Multiple optional positional arguments that are grouped together within a
single set of brackets are filled or not filled as a group. given the
following definition:<br>




<pre>.function_all_flags foo [a b c] [d e] {.echo $a , $b , $c , $d, $e $nl}</pre>




** do a function definition that won't cause variable undefined errors<br>




<br>




foo -&gt; , , , ,<br>




foo x -&gt; error 1 0 0<br>




foo x x -&gt; , ,&nbsp;, x , x<br>




foo x x x -&gt; x , x , x , ,<br>




foo x x x x -&gt; error 1 0 3<br>




foo x x x x x -&gt;&nbsp;x , x , x , x , x<br>




foo x x x x x x -&gt; error 1 0 5<br>




<br>




Note that because optional arguments that begin with a dash are
interpreted as flag options, it is not possible to name an optional
positional argument beginning with a dash.<br>



<h3>...</h3>



"..." occurring in the definition of a function is used to
indicate additional arguments are possible. It does not fill in a
corresponding $... local variable, but rather appends them to the
previous argument, as this is the usage that I find in man pages. This
argument may or may not be enclosed in brackets, depending upon whether
it is required or optional. To continue with the variants on grep
example:<br>



<pre>.function_all_flags grep regex file ... {<br>    .selection_set s $file$; &amp;{whichp grep} $regex @$s}<br>.function_all_flags grep regex [file ...] {<br>    .if .var_exists file {.selection_set s $file$}; &amp;{whichp grep} $regex @$s}</pre>
The first version takes two or more arguments, with at least one path
name being required, but more than one being accepted, all are stored
in the local variable $file. The second version makes specifying files
optional, and so it takes one or more arguments. If these functions are
passed two or more arguments then they behave identically. If they are
passed one argument, then the first version fails to run with a bad
argument count exception being thrown, but the second version runs with
an unmodified selection. "..." and "[...]" have the same meaning, which
is to say that the first version above does not require two or more
arguments. "..." is currently not permitted to occur more than once in
a single function prototype. Note that a space is currently required
before
the "...", though I have seen man pages that do not do this.<br>
<h3>Whitespace within brackets</h3>
To simplify the parsing logic in the initial implementation, whitespace
can only be used within brackets to separate parameters, which is
consistent with a majority of the man pages that I have seen. As a
result, whitespace following an open bracket or preceding a close
bracket is interpreted as declaring the empty string parameter (i.e.
the variable that is accessed with a bare $), and thus having
whitespace after the opening bracket and following the closing bracket
is defining two separate parameters both named the empty string which
is an error (though either by themselves is acceptable). I find the
declarations to be clearer without extra whitespace around the
brackets, but since the implication in the man pages that I have seen
is that there only be as many parameters as there are identifiers, and
since the rarity of support for variables named the empty string makes
this behavior surprising, and since there is no need to make it extra
convenient to declare parameters named the empty string, this behavior
is likely to change in the future. It may change to generate a clearer
error in these situations rather than to ignore this extra whitespace.
As elsewhere, tokens may be separated by multiple spaces or a single
space.
</body>
</html>
