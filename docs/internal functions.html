<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>




  
  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">




  
  
  
  
  <title>internal functions</title>
</head>


<body>
%error%%testTo configure the prompt in other shells, one uses a shell variable.
This can contain fixed text or one of several escapes that are replaced
dynamically by the shell. In order to make this more flexible, and
simultaneously require less documentation (I could never remember all
of those escapes myself), rwsh uses an internal function instead.
Internal functions are just functions that the shell runs for you under
certain conditions. Their names all begin with "rwsh." so that they
won't conflict with other functions you might wish to define and to
clearly identify them as internal functions. Otherwise, they are normal
functions that can be run from the command line or be called by other
functions. They are divided into features and error messages, with the
difference being that if a feature function is missing, then nothing is
run, but if an error message function is missing, then
rwsh.executable_not_found is run instead.<br>




<br>




<h2>features
</h2>


<h3>rwsh.after_command</h3>



After each command completes, rwsh.after_command is run with the entire command line as its arguments.
<h3>rwsh.autofunction</h3>



If a command is requested which is not in the executable map, then the
entire command line is passed to rwsh.autofunction. Afterwards, the
command is searched for again, and if it is not found, then
rwsh.executable_not_found is called. Thus rwsh.autofunction must
implement whatever $PATH-searching logic is desired, and then add the
binary that it finds to the executable map as a function.&nbsp;
<h3>rwsh.before_command</h3>



Before any command is run, the entire command is passed to
rwsh.before_command (if it exists). The command is run only if
rwsh.before_command returns 0.<br>




<h3>rwsh.prompt</h3>



This function is responsible for printing the prompt and for any
notification messages that should come before the prompt. It is not passed any
arguments.<br>




<h3>rwsh.raw_command</h3>


This function is passed the entire command line as a single argument,
before it is parsed, and will thus have the command as typed, rather
than the command that will be run.
<h3>rwsh.shutdown</h3>



This function is run immediately before the shell exits (i.e. after the
exit builtin is run, or after the shell receives EOF from stdin). Its
arguments are the same as those that were used to initialize the shell.
(The arguments to the rwsh executable itself, not the last set of
arguments passed to rwsh.init.)<br>




<h2>error messages</h2>


<h3>rwsh.arguments_for_argfunction</h3>




<p>rwsh cannot handle passing arguments to rwsh.unescaped_argfunction,
rwsh.argfunction, and rwsh.escaped_argfunction (e.g. "fn x {fn $1
{rwsh.argfunction $1}}" or "fn y {fn $1 {rwsh.argfunction {echo
hello}}}"), so any attempt to do so is flagged as an error, and results
in rwsh.arguments_for_argfunction. Currently, the only argument passed
to this function is the name of the function being called (i.e.
rwsh.argfunction, rwsh.unescaped_argfunction, or
rwsh.escaped_argfunction).</p>




<p>If you find that you want to pass arguments to an argfunction, this
is the purpose of rwsh.mapped_argfunction. While the second example
given above would require two argument functions which is not currently
supported, the first one could be written as "fn x {fn $1
{rwsh.mapped_argfunction $1 {rwsh.argfunction}}}" </p>




<h3>rwsh.bad_argfunction_style</h3>
the style of an argument function is determined by its prefix. The two
styles currently supported are "plain" argfunctions, which have no
prefix and are passed on to the executable, and substitutions, which
are prefixed by one or more ampersands (&amp;), and which are run at
some point before the given executable and which are replaced with
their output. If an argfunction is specified with any other prefix, a
rwsh.bad_argfunction_style error will be thrown. Its one argument is
the argument function with the bad style.<br>
<h3>rwsh.binary_not_found</h3>




If the execve() system call fails when attempting to run a binary,
rwsh.binary_not_found is called with the name of the binary as its only
argument.
<h3>rwsh.executable_not_found</h3>




<p>If a function or a builtin is requested that is not in the
executable_map after calling rwsh.autofunction, then
rwsh.executable_not_found is called with the same command line as was
going to be passed to the missing executable, meaning that the
executable's name is in $0.</p>




<p>rwsh.executable_not_found ends up being an incredibly important
error message because if some other error occurs, for which the
corresponding internal function has not been defined (e.g. if the error
occurred in the initialization file), then rwsh.executable_not_found is
called. This has two implications, the first is that it is worthwhile
to print the entire command line that is passed. While a user will
normally know the command that they just entered, if
rwsh.executable_not_found is being called in response to an error, then
the user will not know the arguments to that error function, which will
themselves be useful information. The second implication is that it is
unacceptable for rwsh.executable_not_found to not be defined if it is
called. It is not defined before rwsh.init is called, and it isn't a
crisis if it isn't initialized immediately. However, if it is called
and it is not defined, then it will be defined to a default value and
that will be run.</p>




<h3>rwsh.excessive_nesting</h3>




<p>If a function nests more than $MAX_NESTING times, execution will be
aborted and rwsh.excessive_nesting will be called with the call stack
as arguments (the name of the last function to be called is in $1, the
function that called it is in $2, and so on). If $MAX_NESTING is "0",
undefined or has some value other than a positive number, then
functions may be called, but they may not themselves call functions. If
$MAX_NESTING is "1", then functions may call other functions, but those
functions may only call builtins and binaries. This is necessary
because an infinitely recursive function would cause the shell to
crash. (This behavior can be observed by setting MAX_NESTING to an
absurdly high value, and then running a function that calls itself.) It
is also useful to have an error message in these situations that does
not fill several screens.</p>




<p>If rwsh.excessive_nesting itself generates an excessive nesting
error, then a default error message is given with the call stacks both
of the original error, and the attempt of rwsh.excessive_nesting to
respond to that error. Because this error could be either the result of
missetting MAX_NESTING or an error in rwsh.excessive_nesting, neither
value is changed in this situation.</p>


<h3>rwsh.failed_substitution</h3>
If a substitution returns nonzero, then it is understood to have
failed, and the executable for which its output was to be an argument
is not executed. Instead rwsh.failed_substitution is run, with its
first argument being the substitution that failed.<br>
<h3>rwsh.init</h3>




This function is responsible for all of the initialization of the
shell. It is the only value that is compiled into rwsh. The command
line that started rwsh is passed to rwsh.init as its arguments. It
doesn't do any good to change rwsh.init after the shell has started,
but it can be examined to see what initialization has been done, and it
can be run as a command to reinitialize the shell, possibly with
different arguments.

<h3>rwsh.mismatched_brace</h3>



If the braces in a command do not match properly, (implying a confusion
as to where an argument function begins and ends), then rwsh.mismatched
brace is called instead. It's one argument is the command string up to
and including the first mismatched brace.
<h3>rwsh.multiple_argfunctions</h3>



rwsh cannot currently handle more than one argfunction per
command.&nbsp;This does not limit the ability of argfunctions to be
nested within other argfunctions, or even several argfunctions to be
nested within a single argfunction as long as each is associated with a
separate command. If a command is requested with multiple argfunctions,
then rwsh.multiple_argfunctions is called instead. It does not take any
arguments.
<h3>rwsh.not_soon_enough</h3>
it is possible to specify a soon variable or a substitution that is
delayed past the execution of the statement in which it occurs (e.g.
"echo &amp;&amp;X" or "rwsh.mapped_argfunction {echo
&amp;&amp;&amp;X}"). If a command is given in which this will be the
case, an rwsh.not_soon_enough error is thrown, it's argument is the
argument specification that is delayed too far.<br>
<h3>rwsh.selection_not_found</h3>




<p>If a selection read fails to return any matches, then
rwsh.selection_not_found is called, with the smallest part of the
selection that did not find a match as its first argument and the full
selection as its second argument. For example, a command line that read
"/bin/ls @/ussr/local/" would result in a call of
"rwsh.selection_not_found /ussr /ussr/local/*"</p>


<h3>rwsh.sighup rwsh.sigint rwsh.sigquit rwsh.sigpipe rwsh.sigterm rwsh.sigstp rwsh.sigcont rwsh.siginfo rwsh.sigusr1 rwsh.sigusr2</h3>


If the shell receives any of these signals, then it will unwind the
stack, and pass the call stack as the arguments to the corresponding
internal function.
<h3>rwsh.undefined_variable</h3>
If an argument specification reads a variable that is not set, or
%selection_set or %var_add is passed a variable that is not set, then
an rwsh.undefined_variable error is thown. Its argument is the name of
the variable.<br>
<h3>rwsh.unreadable_dir</h3>


If a selection read encounters a directory to which you do not have
read permissions, then rwsh.unreadable_dir is called with the name of
that directory as its argument.<br>

<h3>rwsh.vars</h3>

rwsh.vars is currently the only exception to the rule that internal
functions are run by the shell itself under the right circumstances.
&nbsp;The intent is for the configuration script to give descriptive
information about the variables used by the configured shell, since
this will probably include variables that are not used by the shell
directly, but are used instead by internal functions, or to implement
other functionality.

</body>
</html>
