<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>











  
  
  
  
  
  
  
  
  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">











  
  
  
  
  
  
  
  
  
  
  
  <title>internal functions</title>
</head>


<body>





Rather than using a shell variable with its own language of special
characters to configure the prompt, rwsh uses an internal function.
Internal functions are just functions that the shell runs for you under
certain conditions. Their names all begin with "rwsh." so that they
won't conflict with other functions you might wish to define and to
clearly identify them as internal functions. Otherwise, they are normal
functions that can be run from the command line or be called by other
functions. They are divided into features and error messages, with the
difference being that if a feature function is missing, then nothing is
run, but if an error message function is missing, then
rwsh.executable_not_found is run instead.<br>











<br>











<h2>features
</h2>









<h3>rwsh.after_command</h3>










After each command completes, rwsh.after_command is run with the entire command line as its arguments.
<h3>rwsh.autofunction</h3>










If a command is requested which is not in the executable map, then the
entire command line is passed to rwsh.autofunction. Afterwards, the
command is searched for again, and if it is not found, then
rwsh.executable_not_found is called. Thus rwsh.autofunction must
implement whatever $PATH-searching logic is desired, and then add the
binary that it finds to the executable map as a function.
<h3>rwsh.before_command</h3>










Before any command is run, the entire command is passed to
rwsh.before_command (if it exists). The command is run only if
rwsh.before_command returns 0.<br>











<h3>rwsh.prompt</h3>










This function is responsible for printing the prompt and for any
notification messages that should come before the prompt. It is not passed any
arguments.<br>











<h3>rwsh.raw_command</h3>









This function is passed the entire command line as a single argument,
before it is parsed, and will thus have the command as typed, rather
than the command that will be run.
<h3>rwsh.run_logic</h3>




If it exists, this command is passed the entire command line and takes
responsibility for actually running the command. If this function fails
early enough, the command will not be run.
<h3>rwsh.shutdown</h3>










This function is run immediately before the shell exits (i.e. after the
exit builtin is run, or after the shell receives EOF from stdin). Its
arguments are the same as those that were used to initialize the shell.
(The arguments to the rwsh executable itself, not the last set of
arguments passed to&nbsp;.init.)<br>





<h3>rwsh.vars</h3>








rwsh.vars is currently the only exception to the rule that internal
functions are run by the shell itself under the right circumstances.
&nbsp;The intent is for the configuration script to give descriptive
information about the variables used by the configured shell, since
this will probably include variables that are not used by the shell
directly, but are used instead by internal functions, or to implement
other functionality.<br>











<h2>error messages</h2>





Note, it any of the functions below produce an error that causes the
stack to unwind, then a generic error message will be printed for both
errors rather than calling the internal function used to report errors
on the secondary error. This prevents an infinite recursion of error
messages. Note that while ".init" is not an error message it falls into this category because it must exist.



<h3>rwsh.argument_count</h3>




If a command is requested with the wrong
number of arguments, then rwsh.argument_count is run instead. Currently
this is limited to builtins and no diagnostic information is passed to
rwsh.argument_count. In a future version there will be diagnostic
information passed as arguments, and functions run with the wrong
number of arguments will produce this error as well.<br>




<h3>rwsh.arguments_for_argfunction</h3>











<p>rwsh cannot handle passing arguments to rwsh.unescaped_argfunction,
rwsh.argfunction, and rwsh.escaped_argfunction (e.g. "fn x {fn $1
{rwsh.argfunction $1}}" or "fn y {fn $1 {rwsh.argfunction {echo
hello}}}"), so any attempt to do so is flagged as an error, and results
in rwsh.arguments_for_argfunction. Currently, the only argument passed
to this function is the name of the function being called (i.e.
rwsh.argfunction, rwsh.unescaped_argfunction, or
rwsh.escaped_argfunction).</p>











<p>If you find that you want to pass arguments to an argfunction, this
is the purpose of rwsh.mapped_argfunction. While the second example
given above would require two argument functions which is not currently
supported, the first one could be written as "fn x {fn $1
{rwsh.mapped_argfunction $1 {rwsh.argfunction}}}" </p>











<h3>rwsh.bad_argfunction_style</h3>







the style of an argument function is determined by its prefix. The two
styles currently supported are "plain" argfunctions, which have no
prefix and are passed on to the executable, and substitutions, which
are prefixed by one or more ampersands (&amp;), and which are run at
some point before the given executable and which are replaced with
their output. If an argfunction is specified with any other prefix, a
rwsh.bad_argfunction_style error will be thrown. Its one argument is
the argument function with the bad style.<br>







<h3>rwsh.bad_if_nest</h3>




<p>if-else blocks do not need to all be at the same nesting level - you
can define functions that act like .if, .else_if, .else, etc. with
differing semantics, which will result in a function returning after
.if was called, but before .else was called. However, if-else blocks
need to be nested within each other properly. That is to say that if
".if" occurs within the argument function of a different .if
invocation, then ".else" needs to occur within that same argument
function. If it does not, then an error will be thrown when the
argument function returns.</p>




<p>For example, this will generate an error:</p>




<pre>.if .return 0 {<br>    .if .return $x {.nop}}<br>.else {.echo this line will never be reached}<br>.else {.echo nor this}<br></pre>




<p>But this will not:</p>




<pre>.if .return 0 {<br>    rwsh.mapped_argfunction {<br>        .if .return $x {.nop}}<br>    rwsh.mapped_argfunction {<br>        rwsh.mapped_argfunction {<br>            .else {.echo valid}}}}<br>.else {.echo still valid}</pre>




<h3>rwsh.binary_not_found</h3>











If the execve() system call fails when attempting to run a binary,
rwsh.binary_not_found is called with the name of the binary as its only
argument.
<h3>rwsh.divide_by_zero</h3>




If the second argument to .var_divide is "0", or a number that converts to 0, then this error will be thrown.
<h3>rwsh.double_redirection</h3>




If a command line has two output redirections, or two input
redirections, then this error is thrown. Both of these constructions
will be supported in a later version.
<h3>rwsh.duplicate_parameter</h3>
If a function definition lists two parameters with the same name, then
this function will be called, with the name of the parameter and a call
stack. Note that the empty string is a valid variable name, and so
placing whitespace before a close bracket, or after an open bracket is
defining an optional argument with the empty string as its name, as
does "[]".
<h3>rwsh.else_without_if</h3>




if ".else" is called before ".if", then this error will be thrown.
<h3>rwsh.excessive_nesting</h3>











<p>If a function nests more than $MAX_NESTING times, execution will be
aborted and rwsh.excessive_nesting will be called with the call stack
as arguments (the name of the last function to be called is in $1, the
function that called it is in $2, and so on). If $MAX_NESTING is "0",
undefined or has some value other than a positive number, then
functions may be called, but they may not themselves call functions. If
$MAX_NESTING is "1", then functions may call other functions, but those
functions may only call builtins and binaries. This is necessary
because an infinitely recursive function would cause the shell to
crash. (This behavior can be observed by setting MAX_NESTING to an
absurdly high value, and then running a function that calls itself, or
by running a function that always calls itself in a shell like bash.)
It
is also useful to have an error message in these situations that does
not fill several screens.</p>





<h3>rwsh.excess_argfunction</h3>


If a builtin that cannot use an argument function is called with an argument function, this error will be thrown. 
<h3>rwsh.executable_not_found</h3>











<p>If a function or a builtin is requested that is not in the
executable_map after calling rwsh.autofunction, then
rwsh.executable_not_found is called with the same command line as was
going to be passed to the missing executable, meaning that the
executable's name is in $0.</p>











<p>rwsh.executable_not_found ends up being an incredibly important
error message because if some other error occurs, for which the
corresponding internal function has not been defined (e.g. if the error
occurred in the initialization file), then rwsh.executable_not_found is
called. This has two implications, the first is that it is worthwhile
to print the entire command line that is passed. While a user will
normally know the command that they just entered, if
rwsh.executable_not_found is being called in response to an error, then
the user will not know the arguments to that error function, which will
themselves be useful information. The second implication is that it is
unacceptable for rwsh.executable_not_found to not be defined if it is
called. It is not defined before .init is called, and it isn't a
crisis if it isn't initialized immediately. However, if it is called
and it is not defined, then it will be defined to a default value and
that will be run.</p>











<h3>rwsh.failed_substitution</h3>







If a substitution returns nonzero, then it is understood to have
failed, and the executable for which its output was to be an argument
is not executed. Instead rwsh.failed_substitution is run, with its
first argument being the substitution that failed.<br>







<h3>rwsh.file_open_failure</h3>




If a file input or output redirection cannot open its target, or if
.source cannot open its first argument, then this error is thrown. The
name of the file that could not be opened is passed as the first
argument.
<h3>rwsh.if_before_else</h3>




If two ".if" commands occur, without a ".else" command between them, then this error is thrown.
<h3>.init</h3>











This function is responsible for all of the initialization of the
shell. The command
line that started rwsh is passed to .init as its arguments. It
doesn't do any good to change .init after the shell has started,
but it can be examined to see what initialization has been done, and it
can be run as a command to reinitialize&nbsp;the shell, possibly with
different arguments. This is why it is named like a built-in rather than like an internal function.

<h3>rwsh.input_range</h3>




If any of the builtins that take a numerical argument are passed a
number outside of the range of a double-precision floating point
number, then this error will be thrown.
<h3>rwsh.invalid_word_selection</h3>




If a word selection (i.e. something following a dollar sign following a
variable name) is not a number, this error will be thrown. Its argument
will be the text that was the word selection.
<h3>rwsh.mismatched_brace</h3>
If the braces in a command do not match properly, (implying a confusion
as to where an argument function begins and ends), then
rwsh.mismatched_brace is called instead. It's one argument is the
command string up to
and including the first unmatched brace.

<h3>rwsh.mismatched_bracket</h3>
If the brackets in the definition of a function taking options do not
match properly, then rwsh.mismatched_bracket is called instead. It's
first argument is the&nbsp;section of the command string with the
mismatched brakcet,&nbsp;up to
and including the first unmatched bracket, and then it also takes a
call stack.
<h3>rwsh.mismatched_parenthesis</h3>

If a parenthesis is found for which no mate can be found, this error
will be thrown with the offending text passed as an argument. Note that
this will generally be an excess close parenthesis since in the
presence of an excess open parenthesis the parser will continue taking
more text until a mate is found.


<h3>rwsh.multiple_argfunctions</h3>










rwsh cannot currently handle more than one argfunction per
command.&nbsp;This does not limit the ability of argfunctions to be
nested within other argfunctions, or even several argfunctions to be
nested within a single argfunction as long as each is associated with a
separate command. If a command is requested with multiple argfunctions,
then rwsh.multiple_argfunctions is called instead. It does not take any
arguments.
<h3>rwsh.not_a_number</h3>

If any builtin that expects a number as an argument (such as .var_add,
.test_less, or .return) gets instead something that is not simply
numerical (e.g. "many", "three", or "3a"), this error is thrown with
the text that was where a number should have been passed as an argument.


<h3>rwsh.not_executable</h3>




If a script is sourced that does not have the executable permission bit
set, this error is thrown and the name of the script is passed as an
argument.
<h3>rwsh.not_soon_enough</h3>







it is possible to specify a soon variable or a substitution that is
delayed past the execution of the statement in which it occurs (e.g.
"echo &amp;&amp;X" or "rwsh.mapped_argfunction {echo
&amp;&amp;&amp;X}"). If a command is given in which this will be the
case, an rwsh.not_soon_enough error is thrown, it's argument is the
argument specification that is delayed too far.
<h3>rwsh.result_range</h3>

If the result of an arithmetic operation does not fit in a double
precision number on the machine, this error is thrown with the two
components of the arithmetic operation passed as arguments


<h3>rwsh.selection_not_found</h3>











<p>If a selection read fails to return any matches, then
rwsh.selection_not_found is called, with the smallest part of the
selection that did not find a match as its first argument and the full
selection as its second argument. For example, a command line that read
"/bin/ls @/usrr/local/" would result in a call of
"rwsh.selection_not_found /usrr /usrr/local/*"</p>









<h3>rwsh.sighup rwsh.sigint rwsh.sigquit rwsh.sigpipe rwsh.sigterm
rwsh.sigtstp rwsh.sigcont rwsh.sigchld rwsh.sigusr1 rwsh.sigusr2
rwsh.sigunknown</h3>









If the shell receives any of these signals, then it will unwind the
stack, and pass the call stack as the arguments to the corresponding
internal function.


<h3>rwsh.undefined_variable</h3>






If an argument specification reads a variable that is not set, or
builtins such as .selection_set or .var_add are passed a variable that
is not set, then
an rwsh.undefined_variable error is thown. Its argument is the name of
the variable.<br>







<h3>rwsh.unreadable_dir</h3>









If a selection read encounters a directory to which you do not have
read permissions, then rwsh.unreadable_dir is called with the name of
that directory as its argument.<br>


<h3>rwsh.unrecognized_flag</h3>
If a flag argument (i.e. one that begins with a dash that does not
follow "--") is passed to a function that declares all of its flags
(such as functions defined with .function_all_options), that is not one
of the declared flags, then rwsh.unrecognized_flag is run with the
offending flag and a call stack as its arguments.
<h3>rwsh.version_incompatible</h3>

If .version_compatible is run with the version string different from
the set of versions that this shell is compatible with, then this error
will be thrown with the requested version as an argument. At the
current time there are so many changes between one release and the next
that this will occur if the version string passed is not identical to
that printed by .version. At some point in the future (likely after
1.0), the shell will be backwards compatible for scripts that do not
depend upon bugs or the absence of features, for some range of
versions. At that time this error will only be thrown if the version is
outside of that range of compatible versions.





</body>
</html>
