.function_flag_ignorant # [ignored ...] {
  .local ret $?
  .if .var_exists argv {.nop $ignored}
  .else {.nop}
  .return $ret}

# set up environment
.global nl (
)

# ability of functions to act as builtin wrappers
.function_flag_ignorant af [argv ...] {rwsh.argfunction}
.function_flag_ignorant c text ... {.combine $text$}
.function_flag_ignorant e text ... {.echo $text}
.function_flag_ignorant echo text ... {.echo $text $nl}
.function_flag_ignorant elif command ... {.else_if $command$ {rwsh.argfunction}}
.function_flag_ignorant else {.else {rwsh.argfunction}}
.function_flag_ignorant fn prototype ... {
  .function_all_flags $prototype$ {rwsh.argfunction}
  .local ret $?
  .if .test_number_equal $ret 1 {echo cannot set paths as functions}
  .else_if .test_number_equal $ret 2 {echo cannot set builtins as functions}
  .else_if .test_number_equal $ret 3 {echo cannot set argfunctions in executable map}
  .else_if .test_number_equal $ret 4 {echo function &&1 did not exist to be erased}
  .else {.return $ret}}
.function_flag_ignorant fni prototype ... {
  .function_flag_ignorant $prototype$ {rwsh.argfunction}
  .local ret $?
  .if .test_number_equal $ret 1 {echo cannot set paths as functions}
  .else_if .test_number_equal $ret 2 {echo cannot set builtins as functions}
  .else_if .test_number_equal $ret 3 {echo cannot set argfunctions in executable map}
  .else_if .test_number_equal $ret 4 {echo function &&1 did not exist to be erased}
  .else {.return $ret}}
.function_flag_ignorant fns name prototype ... {
  .function_all_flags $name [-*] $prototype$ {rwsh.argfunction}
  .local ret $?
  .if .test_number_equal $ret 1 {echo cannot set paths as functions}
  .else_if .test_number_equal $ret 2 {echo cannot set builtins as functions}
  .else_if .test_number_equal $ret 3 {echo cannot set argfunctions in executable map}
  .else_if .test_number_equal $ret 4 {echo function &&1 did not exist to be erased}
  .else {.return $ret}}
.function if {.if $* {rwsh.argfunction}}
.function if_only {.if $* {rwsh.argfunction}; .else {.nop}}
.function if_only_not {.if $* {.nop}; .else {rwsh.argfunction}}
.function timings {
  .echo last time (); .which_last_execution_time $*; c $nl
  .echo total time (); .which_total_execution_time $*; c $nl
  .echo execution count (); .which_execution_count $*; c $nl}
.function set {.set $1 $2 $*3}
.function setf {
  .if .var_exists $1 {.set &&1 &&2}
  .else {.global &&1 &&2}}
.function_flag_ignorant set_if_undefined var [value] {
  .if .var_exists $var {.nop}
  .else_if .var_exists value {.global $var $value}
  .else {.global $var ()}}
fn test_var_not_equal var value {.test_string_unequal $$var $value}
fn test_var_greater var value {.test_greater $$var $value}
fn ntimes n {
  .while test_var_greater n 0 {
    rwsh.mapped_argfunction {rwsh.argfunction}
    .var_subtract n 1}}
fn mark {ntimes 4 {.echo ####################}}
.function unset {.unset $1}
fn which command {
  .local body ()
  .store_output body {.which_executable $command {rwsh.argfunction}}
  .if .test_number_equal $? 0 {.echo $body $nl}
  .else {echo no $command}}
fn whichp binary {
  .which_path $binary $PATH
  .if .test_number_equal $? 0 {.nop}
  .else {echo &&binary not found in $PATH; .return 1}}
.function while {.while $* {rwsh.argfunction}}
fn var_exists var {.var_exists $var}

