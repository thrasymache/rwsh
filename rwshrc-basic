.function_all_flags # -- [ignored ...] {.nop $ignored$}

# set up environment
.set_max_collectible_exceptions 10
.set_max_extra_exceptions 5
.global nl (
)

# internal functions
.function_all_flags .ambiguous_prototype_dash_dash prototype stack ... {
  .echo $prototype is an ambiguous location for a prototype --
  .combine ( (it requests reading the user's mind) ) \( stack: $stack \) $nl}
.function_all_flags .arguments_for_argfunction name {
  echo cannot specify arguments for $name directly}
.function_all_flags .bad_argc required needed optional [stack ...] {
  .echo unacceptable argument count: received $required non-optional
  echo , but needed $needed \(with $optional optional\) for $stack$}
.function_all_flags .bad_argfunction_style style {
  echo $style is neither an argfunction nor a substitution}
.function_all_flags .bad_args -- proto assigned needed excess call_stack ... {
  .combine (unacceptable arguments: for prototype ) $proto , $nl
  if_only .test_not_empty $assigned {
    .combine ( assigned )
    .for $assigned$ {.combine $1$0 = ${paren_if_words $1$1} ( )}
    .combine , $nl ( but)}
  if_only .test_not_empty $needed {
    .combine ( needed \() $needed \), $nl
    if_only .test_not_empty $excess {.combine ( and)}}
  if_only .test_not_empty $excess {
    .combine ( found \() $excess (\) excess) $nl}
  echo \ call stack:  $call_stack}
.function_all_flags .bad_if_nest stack ... {
  echo nested .if without .else with call stack: $stack$}
.function_all_flags .binary_does_not_exist name [stack ...] {
  echo $name : binary does not exist
  if_only .var_exists stack {echo call stack: $stack}}
.function_all_flags .binary_not_found name path stack ... {
  echo $name : binary not found in $path
  echo call stack: $stack$}
.function_all_flags .break stack ... {
  echo .break thrown outside of control flow body
  echo call stack: $stack$}
.function_all_flags .continue stack ... {
  echo .continue thrown outside of control flow body
  echo call stack: $stack$}
.function_all_flags .dash_dash_argument args stack ... {
  echo optional -- parameter cannot take arguments \( $args \) with call stack: $stack$}
.function_all_flags .dash_star_argument args stack ... {
  echo optional -* parameter cannot take arguments \( $args \) with call stack: $stack$}
.function_all_flags .directory_not_found -- dir stack ... {
  .combine $dir ( directory does not exist) $nl
  echo call stack $stack}
.function_all_flags .divide_by_zero numerator stack ... {
  echo attempt to divide $numerator by 0 with call stack: $stack$}
.function_all_flags .double_redirection first second [stack ...] {
  echo double redirection is not supported at this time: $first and $second
  if_only .var_exists stack {echo call stack: $stack$}}
.function_all_flags .duplicate_parameter -- parameter stack ... {
  echo duplicated parameter in function definition: $parameter
  echo call stack: $stack$}
.function_all_flags .elipsis_first_arg -- elipsis stack ... {
  echo $elipsis elipsis cannot be the first argument in a prototype
  echo call stack: $stack$}
.function_all_flags .elipsis_out_of_option_group -- group stack ... {
  echo $group for elipsis to apply to option it must occur within the brackets
  echo call stack: $stack$}
.function_all_flags .else_without_if stack ... {
  echo else without if with call stack: $stack$}
.function_all_flags .excess_argfunction cmd [stack ...] {
  echo $cmd does not accept an argfunction with call stack: $cmd $stack$}
.function_all_flags .excessive_exceptions_collected max stack ... {
  echo exceeded maximum number of exceptions \( $max \) in collect_errors.
  echo call stack: $stack$}
.function_all_flags .excessive_exceptions_in_catch max stack ... {
  echo exceeded maximum number of exceptions \( $max \) in try_catch.
  echo call stack: $stack$}
.function_all_flags .excessive_nesting stack ... {
  echo function exceeded max nesting \( ${.get_max_nesting} \). call stack: $stack}
.function_all_flags .exec_failed binary errno stack ... {
  .combine (.exec failed for ) $binary ( with errno ) $errno $nl
  echo call stack $stack}
.function_all_flags .executable_already_exists -- binary stack ... {
  echo $binary is already an executable in the hash table $nl
  echo call stack $stack}
.function_all_flags .failed_substitution substitution [stack ...] {
  echo substitution $substitution failed
  echo call stack $stack$}
.function_all_flags .false test [stack ...] {
  echo assertion $test failed
  echo call stack $stack$}
.function_all_flags .file_not_found -- file stack ... {
  echo could not find file $file
  echo call stack $stack}
.function_all_flags .file_open_failure -- file stack ... {
  echo could not open file $file
  echo call stack $stack}
.function_all_flags .flag_in_elipsis -- flag stack ... {
  echo found flag $flag while collecting arguments for elipsis
  echo call stack $stack$}
.function_all_flags .function_not_found -- cmd [stack ...] {
  echo $cmd : command not found \( $cmd $stack$ \)}
.function_all_flags .global_would_be_masked name stack ... {
  .echo requested global $name already exists as a local
  echo . It would be masked by the local and inaccessible from here
  echo call stack $stack$}
.function_all_flags .help [args ...] {
  .nop $args$
  .echo this is the default configuration for rwsh \(or something copied from it
  echo \), documentation should be available at rwsh.sf.net or rwsh.org}
.function_all_flags .if_before_else stack ... {
  echo two .if commands without a .else between them with call stack : $stack$}
.function_all_flags .illegal_function_name name stack ... {
  .combine \$ $name ( cannot be a function) $nl
  echo call stack $stack}
.function_all_flags .illegal_variable_name name stack ... {
  .combine \$ $name ( cannot be set) $nl
  echo call stack $stack}
.function_all_flags .input_range -- value stack ... {
  echo value $value is out of usable numeric range
  echo call stack $stack$}
.function_all_flags .internal_error -- [args ...] {
  echo internal error: $args$
  .return -1}
.function_all_flags .invalid_word_selection selection [stack ...] {
  echo $selection is not a valid word selection
  echo call stack $stack$}
.function_all_flags .mismatched_brace context [stack ...] {
  echo mismatched brace: $context $stack$}
.function_all_flags .mismatched_bracket context stack ... {
  echo mismatched bracket: $context
  echo call stack: $stack$}
.function .mismatched_parenthesis {
  .echo signal triggered: $0 \( $* \); .combine $nl
  echo mismatched parenthesis: $1
  echo call stack: $*2
  .return -1}
.function_all_flags .missing_argfunction cmd [add_stack ...] {
  echo $cmd requires an argfunction
  if_only .var_exists add_stack {echo stack $add_stack$}}
.function_all_flags .multiple_argfunctions {
  echo multiple argfunctions not supported at this time}
.function_all_flags .not_a_directory file stack ... {
  .combine $file ( is not a directory) $nl
  echo call stack $stack}
.function_all_flags .not_a_function executable stack ... {
  .combine $executable ( is not a function) $nl
  echo call stack $stack}
.function_all_flags .not_a_number -- nan stack ... {
  echo $nan is not a number
  echo call stack: $stack$}
.function_all_flags .not_catching_exception stack ... {
  echo .replace_exception called outside of an exception handler
  echo call stack: $stack$}
.function_all_flags .not_executable file stack ... {
  echo $file is not executable
  echo call stack: $stack$}
.function_all_flags .not_soon_enough too_late [stack ...] {
  echo $too_late attempts to substitute after the command has been run
  if_only .var_exists stack {echo call stack $stack}}
.function_all_flags .post_elipsis_option -- flag stack ... {
  echo option $flag coming after an elipsis has no meaning
  echo call stack: $stack$}
.function_all_flags .post_dash_dash_flag -- flag stack ... {
  echo flag option $flag occurs after -- in the prototype
  echo call stack: $stack$}
.function_all_flags .result_range -- lhs rhs op [stack ...] {
  echo result of $op with arguments $lhs and $rhs is out of range
  echo call stack: $op $stack$}
.function_all_flags .return_code code cmd [add_stack ...] {
  echo $cmd returned $code : call stack $cmd $add_stack$}
.function_all_flags .selection_not_found not_found selection [stack ...] {
  .echo no file matching pattern $not_found
  if_only .test_string_unequal $not_found $selection {
    .echo () for selection $selection}
  .echo $nl
  if_only .var_exists stack {echo call stack: $stack$}
  .return -1}
.function_all_flags .sigcont {
  echo received SIGCONT; .return -1}
.function_all_flags .sigchld {
  echo received SIGCHLD; .return -1}
.function_all_flags .sighup {
  echo received SIGHUP; .return -1}
.function_all_flags .sigint {
  .throw echo $nl received SIGINT}
.function_all_flags .sigquit {
  echo received SIGQUIT; .return -1}
.function_all_flags .sigpipe {
  echo received SIGPIPE; .return -1}
.function_all_flags .sigterm {
  .throw echo $nl received SIGTERM}
.function_all_flags .sigtstp {
  echo received SIGTSTP; .return -1}
.function_all_flags .siginfo {
  echo received SIGINFO; .return -1}
.function_all_flags .sigusr1 {
  echo received SIGUSR1; .return -1}
.function_all_flags .sigusr2 {
  echo received SIGUSR2; .return -1}
.function_all_flags .sigunknown {
  echo received unknown unix signal; .return -1}
.function_all_flags .shutdown -- args ... {
  .nop $args
  .combine $nl (now terminating normally) $nl}
.function_all_flags .tardy_flag -- flag stack ... {
  echo $flag flag comes too late in command
  echo call stack: $stack$}
.function_all_flags .unchecked_variable -- var [stack ...] {
  echo $var was not checked with call stack $stack$}
.function_all_flags .undeclared_variable -- name [stack ...] {
  echo $name was not declared
  echo call stack: $stack$}
.function_all_flags .undefined_variable -- name [stack ...] {
  echo optional variable $name was not defined
  echo call stack: $stack$}
.function_all_flags .unfinished_if_block [stack ...] {
  echo conditional not finished within preceeding block
  if_only .var_exists stack {echo call stack: $stack$}}
.function_all_flags .unreadable_dir dir errno [stack ...] {
  .combine (cannot read directory ) $dir \ \(errno\  $errno \) $nl
  echo call stack: $stack$
  .return -1}
.function_all_flags .unrecognized_flag -- flag cmd [add_stack ...] {
  echo $flag flag is unrecognized for $cmd
  echo call stack: $cmd $add_stack$}
.function_all_flags .unused_before_set -- var [stack ...] {
  echo attempt to set $var before making use of its initial value
  echo call stack $stack$}
.function_all_flags .unused_variable -- var [stack ...] {
  echo $var was unused with call stack $stack$}
.function_all_flags .variable_already_exists name stack ... {
  echo variable $name already exists
  echo call stack $stack$}
.function_all_flags .version_incompatible version stack ... {
  echo this shell is not compatible with requested version $version
  echo call stack: $stack$}

# ability of functions to act as builtin wrappers
.function_all_flags ! args ... {
  .if $args$ {.throw .false ${.echo ! $args}}
  .else {.return 0}}
.function_all_flags af -- [argv ...] {.argfunction}
.function_all_flags c -- text ... {.combine $text$}
.function_all_flags e -- text ... {.echo $text}
.function_all_flags do_while argv ... {
  .try_catch_recursive .break {
    .nop $argv
    .try_catch_recursive .continue {.argfunction}
    .while $argv$ {.argfunction}}}
.function_all_flags echo -- text ... {.echo $text; .combine $nl}
.function_all_flags echo-comments cmd ... {
  .stepwise $cmd$ {if_only .test_in $1 .nop # #! ## {echo &&&*}}}
.function_all_flags exec -- argv ... {.exec $argv$}
.function_all_flags elif command ... {.else_if $command$ {.argfunction}}
.function_all_flags else {.else {.argfunction}}
.function_all_flags fn -- prototype ... {
  .function_all_flags $prototype$ {.argfunction}}
.function_all_flags fni -- name args ... {
  .function_all_flags $name -- $args$ {.argfunction}}
.function_all_flags fns -- name args ... {
  .function_all_flags $name [-*] $args$ {.argfunction}}
.function_all_flags if_only -- args ... {
  .if $args$ {.argfunction}; .else {.nop}}
.function_all_flags if_only_not -- args ... {
  .if $args$ {.nop}; .else {.argfunction}}
fn ntimes n {
  .while test_var_greater n 0 {
    .mapped_argfunction {.argfunction}
    .var_subtract n 1}}
.function_all_flags outer_break stack ... {
  .replace_exception .break $stack$}
.function_all_flags outer_continue stack ... {
  .replace_exception .continue $stack$}
.function_all_flags scope_for var vals ... {
  .for $vals$ {
    .scope $1 $var {.argfunction}}}
.function_all_flags outer_for var vals ... {
  .for $vals$ {
    .scope $1 $var {
      .try_catch_recursive outer_break outer_continue {.argfunction}}}}
.function_all_flags outer_while argv ... {
  .while $argv$ {
    .try_catch_recursive outer_break outer_continue {.argfunction}}}
.function_all_flags setf var value {
  .if .var_exists $var {.set $var $value}
  .else {.global $var $value}}
fn single -- args ... {.scope ${$args$}$ result {echo $result}}
fn test_var_not_equal var value {.test_string_unequal $$var $value}
fn test_var_greater -- var value {.test_greater $$var $value}
fn type [-t] args ... {
  .for $args$ {
    .try_catch_recursive .function_not_found {
      if_only_not .var_exists -t {.echo &&&1 is ()}
      .type &&&1 {.argfunction}}}}
fn whence command {
  .try_catch_recursive .function_not_found {
    .whence_function $command {.argfunction}}}
fn whichp binary {.which_path $binary $PATH}
.function_all_flags while_and_one_more argv ... {
  .try_catch_recursive .break {
    .while $argv$ {.argfunction}
    .try_catch_recursive .continue {.argfunction}}}
.function_all_flags var_exists -- var {.var_exists $var}
.function_all_flags var_in var set ... {.test_in $$var $set$}
.function_all_flags var_less var N {.test_less $$var $N}
.function_all_flags var_val -- [var ...] {
  .if .var_exists var {.for $var$ {.combine $1 \( $$1 \) \ }}
  .else {.nop}}
.function_all_flags paren_if_words -- value {
  .if .test_number_equal ${.argc $value$} 1 {.combine $value}
  .else {.combine \( $value \)}}
fn polish -- operator builtin {
  fn &&operator -- lhs rhs ... {
    if_only .test_in $lhs + - / {
      .scope ${$lhs $rhs$}$ (-- l r ...) {
        .set lhs $l
        .set rhs $r}}
    .scope $rhs$ (rhs [extra ...]) {
      .if .test_in $rhs + - / {
        .scope ${$rhs $extra$}$ (rhs [extra ...]) {
          &&builtin lhs $rhs
          echo $lhs $extra$}}
      .else {
        &&builtin lhs $rhs
        echo $lhs $extra$}}}}
polish - .var_subtract
polish + .var_add
polish / .var_divide
