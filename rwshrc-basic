.function_all_flags # -- [ignored ...] {
  .local ret $?
  .if .var_exists ignored {.nop $ignored}
  .else {.nop}
  .nop $ret $?
  .return 0
  .return $ret}

# set up environment
.global nl (
)

# internal functions
.function rwsh.unused_variable {echo $1 was unused with call stack $*2}
.function rwsh.unchecked_variable {echo $1 was not checked with call stack $*2}

# ability of functions to act as builtin wrappers
.function_all_flags af -- [argv ...] {rwsh.argfunction}
.function_all_flags c -- text ... {.combine $text$}
.function_all_flags e -- text ... {.echo $text}
.function_all_flags echo -- text ... {.echo $text $nl}
.function_all_flags elif command ... {.else_if $command$ {rwsh.argfunction}}
.function_all_flags else {.else {rwsh.argfunction}}
.function_all_flags fn -- prototype ... {
  .function_all_flags $prototype$ {rwsh.argfunction}
  .local ret $?
  .if .test_number_equal $ret 1 {echo cannot set paths as functions}
  .else_if .test_number_equal $ret 2 {echo cannot set builtins as functions}
  .else_if .test_number_equal $ret 3 {echo cannot set argfunctions in executable map}
  .else_if .test_number_equal $ret 4 {echo function &&1 did not exist to be erased}
  .else {.return $ret}}
.function_all_flags fni -- name args ... {
  .function_all_flags $name -- $args$ {rwsh.argfunction}
  .local ret $?
  .if .test_number_equal $ret 1 {echo cannot set paths as functions}
  .else_if .test_number_equal $ret 2 {echo cannot set builtins as functions}
  .else_if .test_number_equal $ret 3 {echo cannot set argfunctions in executable map}
  .else_if .test_number_equal $ret 4 {echo function &&1 did not exist to be erased}
  .else {.return $ret}}
.function_all_flags fns -- name args ... {
  .function_all_flags $name [-*] $args$ {rwsh.argfunction}
  .local ret $?
  .if .test_number_equal $ret 1 {echo cannot set paths as functions}
  .else_if .test_number_equal $ret 2 {echo cannot set builtins as functions}
  .else_if .test_number_equal $ret 3 {echo cannot set argfunctions in executable map}
  .else_if .test_number_equal $ret 4 {echo function &&1 did not exist to be erased}
  .else {.return $ret}}
.function_all_flags iee var {
  .if .var_exists $var {.echo $$var}
  .else {.nop}}
.function_all_flags ien var {
  .if .var_exists $var {.nop $$var}
  .else {.nop}}
.function if {.if $* {rwsh.argfunction}}
.function_all_flags if_only -- args ... {
  .if $args$ {rwsh.argfunction}; .else {.nop}}
.function if_only_not {.if $* {.nop}; .else {rwsh.argfunction}}
.function timings {
  .echo last time (); .which_last_execution_time $*; c $nl
  .echo total time (); .which_total_execution_time $*; c $nl
  .echo execution count (); .which_execution_count $*; c $nl}
.function set {.set $1 $2 $*3}
.function setf {
  .if .var_exists $1 {.set &&1 &&2}
  .else {.global &&1 &&2}}
.function_all_flags set_if_undefined -- var [value] {
  .if .var_exists $var {ien value}
  .else_if .var_exists value {.global $var $value}
  .else {.global $var ()}}
fn test_var_not_equal var value {.test_string_unequal $$var $value}
.function_all_flags test_var_greater -- var value {.test_greater $$var $value}
fn ntimes n {
  .while test_var_greater n 0 {
    rwsh.mapped_argfunction {rwsh.argfunction}
    .var_subtract n 1}}
fn mark {ntimes 4 {.echo ####################}}
.function unset {.unset $1}
fn which command {
  .if .which_test $command {
    .combine ${.which_executable $command {rwsh.argfunction}} $nl}
  .else {echo no $command}}
fn whichp binary {
  .which_path $binary $PATH
  .if .test_number_equal $? 0 {.nop}
  .else {echo &&binary not found in $PATH; .return 1}}
.function while {.while $* {rwsh.argfunction}}
.function_all_flags var_exists -- var {.var_exists $var}
.function_all_flags var_val -- [var ...] {
  .if .var_exists var {.for $var$ {.combine $1 \( $$1 \) \ }}
  .else {.nop}}
.function_all_flags paren_if_words -- value {
  .if .test_number_equal ${.argc $value$} 1 {.combine $value}
  .else {.combine \( $value \)}}
.function_all_flags rwsh.bad_args -- proto assigned needed excess call_stack ... {
  .combine (unacceptable arguments: for prototype ) $proto , $nl
  if_only .test_not_empty $assigned {
    .combine ( assigned )
    .for $assigned$ {.combine $1$0 = ${paren_if_words $1$1} ( )}
    .combine , $nl ( but)}
  if_only .test_not_empty $needed {
    .combine ( needed \() $needed \), $nl
    if_only .test_not_empty $excess {.combine ( and)}}
  if_only .test_not_empty $excess {
    .combine ( found \() $excess (\) excess) $nl}
  .echo \ call stack:  $call_stack $nl
  .return -1}
