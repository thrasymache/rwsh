.function_all_flags # -- [ignored ...] {
  .local ret $?
  .if .var_exists ignored {.nop $ignored}
  .else {.nop}
  .nop $ret $?
  .return 0
  .return $ret}
.function_all_flags #! -- [ignored ...] {# $ignored}

# set up environment
.global nl (
)

# internal functions
.function_all_flags rwsh.bad_args -- proto assigned needed excess call_stack ... {
  .combine (unacceptable arguments: for prototype ) $proto , $nl
  if_only .test_not_empty $assigned {
    .combine ( assigned )
    .for $assigned$ {.combine $1$0 = ${paren_if_words $1$1} ( )}
    .combine , $nl ( but)}
  if_only .test_not_empty $needed {
    .combine ( needed \() $needed \), $nl
    if_only .test_not_empty $excess {.combine ( and)}}
  if_only .test_not_empty $excess {
    .combine ( found \() $excess (\) excess) $nl}
  echo \ call stack:  $call_stack
  .return -1}
.function rwsh.binary_does_not_exist {
  echo $1 : binary does not exist
  echo call stack: $*2
  .return -1}
.function rwsh.binary_not_found {
  echo $1 : binary not found in $2
  echo call stack: $*3
  .return -1}
.function rwsh.directory_not_found {
  .combine $1 ( directory does not exist) $nl
  echo call stack $*2}
.function rwsh.exec_failed {
  .combine (.exec failed for ) $1 ( with errno ) $2 $nl
  echo call stack $*3}
.function rwsh.file_not_found {
  echo $1 : could not find file
  .return -1}
.function rwsh.illegal_function_name {
  .combine \$ $1 ( cannot be a function) $nl
  echo call stack $*2}
.function rwsh.illegal_variable_name {
  .combine \$ $1 ( cannot be set) $nl
  echo call stack $*2}
.function rwsh.not_a_directory {
  .combine $1 ( is not a directory) $nl
  echo call stack $*2}
.function rwsh.unused_variable {echo $1 was unused with call stack $*2}
.function rwsh.unchecked_variable {echo $1 was not checked with call stack $*2}

# ability of functions to act as builtin wrappers
.function_all_flags af -- [argv ...] {rwsh.argfunction}
.function_all_flags c -- text ... {.combine $text$}
.function_all_flags e -- text ... {.echo $text}
.function_all_flags echo -- text ... {.echo $text; .combine $nl}
.function_all_flags exec -- argv ... {.exec $argv$}
.function_all_flags elif command ... {.else_if $command$ {rwsh.argfunction}}
.function_all_flags else {.else {rwsh.argfunction}}
.function_all_flags fn -- prototype ... {
  .function_all_flags $prototype$ {rwsh.argfunction}}
.function_all_flags fni -- name args ... {
  .function_all_flags $name -- $args$ {rwsh.argfunction}}
.function_all_flags fns -- name args ... {
  .function_all_flags $name [-*] $args$ {rwsh.argfunction}}
.function_all_flags iee var {
  .if .var_exists $var {.echo $$var}
  .else {.nop}}
.function_all_flags ien var {
  .if .var_exists $var {.nop $$var}
  .else {.nop}}
.function if {.if $* {rwsh.argfunction}}
.function_all_flags if_only -- args ... {
  .if $args$ {rwsh.argfunction}; .else {.nop}}
.function if_only_not {.if $* {.nop}; .else {rwsh.argfunction}}
.function timings {
  .echo last time (); .which_last_execution_time $*; c $nl
  .echo total time (); .which_total_execution_time $*; c $nl
  .echo execution count (); .which_execution_count $*; c $nl}
.function set {.set $1 $2 $*3}
.function setf {
  .if .var_exists $1 {.set &&1 &&2}
  .else {.global &&1 &&2}}
.function_all_flags set_if_undefined -- var [value] {
  .if .var_exists $var {ien value}
  .else_if .var_exists value {.global $var $value}
  .else {.global $var ()}}
fn test_var_not_equal var value {.test_string_unequal $$var $value}
.function_all_flags test_var_greater -- var value {.test_greater $$var $value}
fn ntimes n {
  .while test_var_greater n 0 {
    rwsh.mapped_argfunction {rwsh.argfunction}
    .var_subtract n 1}}
.function unset {.unset $1}
fn which command {
  .if .which_test $command {
    .combine ${.which_executable $command {rwsh.argfunction}} $nl}
  .else {echo no $command}}
fn whichp binary {.which_path $binary $PATH}
.function while {.while $* {rwsh.argfunction}}
.function_all_flags var_exists -- var {.var_exists $var}
.function_all_flags var_val -- [var ...] {
  .if .var_exists var {.for $var$ {.combine $1 \( $$1 \) \ }}
  .else {.nop}}
.function_all_flags paren_if_words -- value {
  .if .test_number_equal ${.argc $value$} 1 {.combine $value}
  .else {.combine \( $value \)}}
