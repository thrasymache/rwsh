init file /non-existent/file/to/test/failure does not exist
call stack .source .try_catch_recursive(body)
.global last_command_return -10
.global A \

.nop .function_all_flags .run_logic -- cmd [args ...] {
  .return $last_command_return
  .signal_handler &{.internal_functions}$ {&&* {.argfunction}}
  .mapped_argfunction {&&* {.argfunction}}
  &&* {.argfunction}
  .set last_command_return $?
  .echo $nl
  .echo $last_command_return
  .echo $nl}
.function_all_flags .before_command -- args ... {
  .nop $args
  .return $last_command_return}
.function_all_flags .after_command -- args ... {
  .nop $args
  .set last_command_return $?
  .combine $last_command_return $nl}
.function_all_flags .prompt {.echo \$}
.function_all_flags .vars {.internal_vars}
.source /etc/rwshrc-basic
.function_all_flags # -- [ignored ...] {.nop $ignored$}

# set up environment
.set_max_collectible_exceptions 10
.set_max_extra_exceptions 5
.global nl (
)

# internal functions
.function_all_flags .ambiguous_prototype_dash_dash prototype stack ... {
  .echo $prototype is an ambiguous location for a prototype --
  .combine ( (it requests reading the user's mind) ) \( stack: $stack \) $nl}
.function_all_flags .arguments_for_argfunction name {
  echo cannot specify arguments for $name directly}
.function_all_flags .bad_argc required needed optional [stack ...] {
  .echo unacceptable argument count: received $required non-optional
  echo , but needed $needed \(with $optional optional\) for $stack$}
.function_all_flags .bad_argfunction_style style {
  echo $style is neither an argfunction nor a substitution}
.function_all_flags .bad_args -- proto assigned needed excess call_stack ... {
  .combine (unacceptable arguments: for prototype ) $proto , $nl
  if_only .test_not_empty $assigned {
    .combine ( assigned )
    .for $assigned$ {.combine $1$0 = ${paren_if_words $1$1} ( )}
    .combine , $nl ( but)}
  if_only .test_not_empty $needed {
    .combine ( needed \() $needed \), $nl
    if_only .test_not_empty $excess {.combine ( and)}}
  if_only .test_not_empty $excess {
    .combine ( found \() $excess (\) excess) $nl}
  echo \ call stack:  $call_stack}
.function_all_flags .bad_if_nest stack ... {
  echo nested .if without .else with call stack: $stack$}
.function_all_flags .binary_does_not_exist name [stack ...] {
  echo $name : binary does not exist
  if_only .var_exists stack {echo call stack: $stack}}
.function_all_flags .binary_not_found name path stack ... {
  echo $name : binary not found in $path
  echo call stack: $stack$}
.function_all_flags .break stack ... {
  echo .break thrown outside of control flow body
  echo call stack: $stack$}
.function_all_flags .continue stack ... {
  echo .continue thrown outside of control flow body
  echo call stack: $stack$}
.function_all_flags .dash_dash_argument args stack ... {
  echo optional -- parameter cannot take arguments \( $args \) with call stack: $stack$}
.function_all_flags .dash_star_argument args stack ... {
  echo optional -* parameter cannot take arguments \( $args \) with call stack: $stack$}
.function_all_flags .directory_not_found -- dir stack ... {
  .combine $dir ( directory does not exist) $nl
  echo call stack $stack}
.function_all_flags .divide_by_zero numerator stack ... {
  echo attempt to divide $numerator by 0 with call stack: $stack$}
.function_all_flags .double_redirection first second [stack ...] {
  echo double redirection is not supported at this time: $first and $second
  if_only .var_exists stack {echo call stack: $stack$}}
.function_all_flags .duplicate_parameter -- parameter stack ... {
  echo duplicated parameter in function definition: $parameter
  echo call stack: $stack$}
.function_all_flags .elipsis_first_arg -- elipsis stack ... {
  echo $elipsis elipsis cannot be the first argument in a prototype
  echo call stack: $stack$}
.function_all_flags .elipsis_out_of_option_group -- group stack ... {
  echo $group for elipsis to apply to option it must occur within the brackets
  echo call stack: $stack$}
.function_all_flags .else_without_if stack ... {
  echo else without if with call stack: $stack$}
.function_all_flags .excess_argfunction cmd [stack ...] {
  echo $cmd does not accept an argfunction with call stack: $cmd $stack$}
.function_all_flags .excessive_exceptions_collected max stack ... {
  echo exceeded maximum number of exceptions \( $max \) in collect_errors.
  echo call stack: $stack$}
.function_all_flags .excessive_exceptions_in_catch max stack ... {
  echo exceeded maximum number of exceptions \( $max \) in try_catch.
  echo call stack: $stack$}
.function_all_flags .excessive_nesting stack ... {
  echo function exceeded max nesting \( ${.get_max_nesting} \). call stack: $stack}
.function_all_flags .exec_failed binary errno stack ... {
  .combine (.exec failed for ) $binary ( with errno ) $errno $nl
  echo call stack $stack}
.function_all_flags .executable_already_exists -- binary stack ... {
  echo $binary is already an executable in the hash table $nl
  echo call stack $stack}
.function_all_flags .failed_substitution substitution [stack ...] {
  echo substitution $substitution failed
  echo call stack $stack$}
.function_all_flags .false test [stack ...] {
  echo assertion $test failed
  echo call stack $stack$}
.function_all_flags .file_not_found -- file stack ... {
  echo could not find file $file
  echo call stack $stack}
.function_all_flags .file_open_failure -- file stack ... {
  echo could not open file $file
  echo call stack $stack}
.function_all_flags .flag_in_elipsis -- flag stack ... {
  echo found flag $flag while collecting arguments for elipsis
  echo call stack $stack$}
.function_all_flags .function_not_found -- cmd [stack ...] {
  echo $cmd : command not found \( $cmd $stack$ \)}
.function_all_flags .global_would_be_masked name stack ... {
  .echo requested global $name already exists as a local
  echo . It would be masked by the local and inaccessible from here
  echo call stack $stack$}
.function_all_flags .help [args ...] {
  .nop $args$
  .echo this is the default configuration for rwsh \(or something copied from it
  echo \), documentation should be available at rwsh.sf.net or rwsh.org}
.function_all_flags .if_before_else stack ... {
  echo two .if commands without a .else between them with call stack : $stack$}
.function_all_flags .illegal_function_name name stack ... {
  .combine \$ $name ( cannot be a function) $nl
  echo call stack $stack}
.function_all_flags .illegal_variable_name name stack ... {
  .combine \$ $name ( cannot be set) $nl
  echo call stack $stack}
.function_all_flags .input_range -- value stack ... {
  echo value $value is out of usable numeric range
  echo call stack $stack$}
.function_all_flags .internal_error -- [args ...] {
  echo internal error: $args$
  .return -1}
.function_all_flags .invalid_word_selection selection [stack ...] {
  echo $selection is not a valid word selection
  echo call stack $stack$}
.function_all_flags .mismatched_brace context [stack ...] {
  echo mismatched brace: $context $stack$}
.function_all_flags .mismatched_bracket context stack ... {
  echo mismatched bracket: $context
  echo call stack: $stack$}
.function .mismatched_parenthesis {
  .echo signal triggered: $0 \( $* \); .combine $nl
  echo mismatched parenthesis: $1
  echo call stack: $*2
  .return -1}
.function_all_flags .missing_argfunction cmd [add_stack ...] {
  echo $cmd requires an argfunction
  if_only .var_exists add_stack {echo stack $add_stack$}}
.function_all_flags .multiple_argfunctions {
  echo multiple argfunctions not supported at this time}
.function_all_flags .not_a_directory file stack ... {
  .combine $file ( is not a directory) $nl
  echo call stack $stack}
.function_all_flags .not_a_function executable stack ... {
  .combine $executable ( is not a function) $nl
  echo call stack $stack}
.function_all_flags .not_a_number -- nan stack ... {
  echo $nan is not a number
  echo call stack: $stack$}
.function_all_flags .not_catching_exception stack ... {
  echo .replace_exception called outside of an exception handler
  echo call stack: $stack$}
.function_all_flags .not_executable file stack ... {
  echo $file is not executable
  echo call stack: $stack$}
.function_all_flags .not_soon_enough too_late [stack ...] {
  echo $too_late attempts to substitute after the command has been run
  if_only .var_exists stack {echo call stack $stack}}
.function_all_flags .post_elipsis_option -- flag stack ... {
  echo option $flag coming after an elipsis has no meaning
  echo call stack: $stack$}
.function_all_flags .post_dash_dash_flag -- flag stack ... {
  echo flag option $flag occurs after -- in the prototype
  echo call stack: $stack$}
.function_all_flags .result_range -- lhs rhs op [stack ...] {
  echo result of $op with arguments $lhs and $rhs is out of range
  echo call stack: $op $stack$}
.function_all_flags .return_code code cmd [add_stack ...] {
  echo $cmd returned $code : call stack $cmd $add_stack$}
.function_all_flags .selection_not_found not_found selection [stack ...] {
  .echo no file matching pattern $not_found
  if_only .test_string_unequal $not_found $selection {
    .echo () for selection $selection}
  .echo $nl
  if_only .var_exists stack {echo call stack: $stack$}
  .return -1}
.function_all_flags .sigcont {
  echo received SIGCONT; .return -1}
.function_all_flags .sigchld {
  echo received SIGCHLD; .return -1}
.function_all_flags .sighup {
  echo received SIGHUP; .return -1}
.function_all_flags .sigint {
  .throw echo $nl received SIGINT}
.function_all_flags .sigquit {
  echo received SIGQUIT; .return -1}
.function_all_flags .sigpipe {
  echo received SIGPIPE; .return -1}
.function_all_flags .sigterm {
  .throw echo $nl received SIGTERM}
.function_all_flags .sigtstp {
  echo received SIGTSTP; .return -1}
.function_all_flags .siginfo {
  echo received SIGINFO; .return -1}
.function_all_flags .sigusr1 {
  echo received SIGUSR1; .return -1}
.function_all_flags .sigusr2 {
  echo received SIGUSR2; .return -1}
.function_all_flags .sigunknown {
  echo received unknown unix signal; .return -1}
.function_all_flags .shutdown -- args ... {
  .nop $args
  .combine $nl (now terminating normally) $nl}
.function_all_flags .tardy_flag -- flag stack ... {
  echo $flag flag comes too late in command
  echo call stack: $stack$}
.function_all_flags .unchecked_variable -- var [stack ...] {
  echo $var was not checked with call stack $stack$}
.function_all_flags .undeclared_variable -- name [stack ...] {
  echo $name was not declared
  echo call stack: $stack$}
.function_all_flags .undefined_variable -- name [stack ...] {
  echo optional variable $name was not defined
  echo call stack: $stack$}
.function_all_flags .unreadable_dir dir errno [stack ...] {
  .combine (cannot read directory ) $dir \ \(errno\  $errno \) $nl
  echo call stack: $stack$
  .return -1}
.function_all_flags .unrecognized_flag -- flag cmd [add_stack ...] {
  echo $flag flag is unrecognized for $cmd
  echo call stack: $cmd $add_stack$}
.function_all_flags .unused_before_set -- var [stack ...] {
  echo attempt to set $var before making use of its initial value
  echo call stack $stack$}
.function_all_flags .unused_variable -- var [stack ...] {
  echo $var was unused with call stack $stack$}
.function_all_flags .variable_already_exists name stack ... {
  echo variable $name already exists
  echo call stack $stack$}
.function_all_flags .version_incompatible version stack ... {
  echo this shell is not compatible with requested version $version
  echo call stack: $stack$}

# ability of functions to act as builtin wrappers
.function_all_flags ! args ... {
  .if $args$ {.throw .false ${.echo ! $args}}
  .else {.return 0}}
.function_all_flags af -- [argv ...] {.argfunction}
.function_all_flags c -- text ... {.combine $text$}
.function_all_flags e -- text ... {.echo $text}
.function_all_flags do_while argv ... {
  .try_catch_recursive .break {
    .nop $argv
    .try_catch_recursive .continue {.argfunction}
    .while $argv$ {.argfunction}}}
.function_all_flags echo -- text ... {.echo $text; .combine $nl}
.function_all_flags echo-comments cmd ... {
  .stepwise $cmd$ {if_only .test_in $1 .nop # #! ## {echo &&&*}}}
.function_all_flags exec -- argv ... {.exec $argv$}
.function_all_flags elif command ... {.else_if $command$ {.argfunction}}
.function_all_flags else {.else {.argfunction}}
.function_all_flags fn -- prototype ... {
  .function_all_flags $prototype$ {.argfunction}}
.function_all_flags fni -- name args ... {
  .function_all_flags $name -- $args$ {.argfunction}}
.function_all_flags fns -- name args ... {
  .function_all_flags $name [-*] $args$ {.argfunction}}
.function_all_flags if_only -- args ... {
  .if $args$ {.argfunction}; .else {.nop}}
.function_all_flags if_only_not -- args ... {
  .if $args$ {.nop}; .else {.argfunction}}
fn ntimes n {
  .while test_var_greater n 0 {
    .mapped_argfunction {.argfunction}
    .var_subtract n 1}}
.function_all_flags outer_break stack ... {
  .replace_exception .break $stack$}
.function_all_flags outer_continue stack ... {
  .replace_exception .continue $stack$}
.function_all_flags scope_for var vals ... {
  .for $vals$ {
    .scope $1 $var {.argfunction}}}
.function_all_flags outer_for var vals ... {
  .for $vals$ {
    .scope $1 $var {
      .try_catch_recursive outer_break outer_continue {.argfunction}}}}
.function_all_flags outer_while argv ... {
  .while $argv$ {
    .try_catch_recursive outer_break outer_continue {.argfunction}}}
.function_all_flags setf var value {
  .if .var_exists $var {.set $var $value}
  .else {.global $var $value}}
fn single -- args ... {.scope ${$args$}$ result {echo $result}}
fn test_var_not_equal var value {.test_string_unequal $$var $value}
fn test_var_greater -- var value {.test_greater $$var $value}
fn type [-t] args ... {
  .for $args$ {
    .try_catch_recursive .function_not_found {
      if_only_not .var_exists -t {.echo &&&1 is ()}
      .type &&&1 {.argfunction}}}}
fn whence command {
  .try_catch_recursive .function_not_found {
    .whence_function $command {.argfunction}}}
fn whichp binary {.which_path $binary $PATH}
.function_all_flags while_and_one_more argv ... {
  .try_catch_recursive .break {
    .while $argv$ {.argfunction}
    .try_catch_recursive .continue {.argfunction}}}
.function_all_flags var_exists -- var {.var_exists $var}
.function_all_flags var_in var set ... {.test_in $$var $set$}
.function_all_flags var_less var N {.test_less $$var $N}
.function_all_flags var_val -- [var ...] {
  .if .var_exists var {.for $var$ {.combine $1 \( $$1 \) \ }}
  .else {.nop}}
.function_all_flags paren_if_words -- value {
  .if .test_number_equal ${.argc $value$} 1 {.combine $value}
  .else {.combine \( $value \)}}
fn polish -- operator builtin {
  fn &&operator -- lhs rhs ... {
    if_only .test_in $lhs + - / {
      .scope ${$lhs $rhs$}$ (-- l r ...) {
        .set lhs $l
        .set rhs $r}}
    .scope $rhs$ (rhs [extra ...]) {
      .if .test_in $rhs + - / {
        .scope ${$rhs $extra$}$ (rhs [extra ...]) {
          &&builtin lhs $rhs
          echo $lhs $extra$}}
      .else {
        &&builtin lhs $rhs
        echo $lhs $extra$}}}}
polish - .var_subtract
polish + .var_add
polish / .var_divide
.else_if .test_string_equal $2 -c {
  .for ${.list_environment}$ {
    .scope $1$ (-- var val) {
      .if .var_exists $var {.nop $val}
      .else {
        .global $var $val
        .nop $$var}}}
  .source /etc/rwshrc-basic
  .nop $FIGNORE
  .function_all_flags .if_before_else stack ... {.nop $stack}
  .function_all_flags .shutdown -- args ... {.nop $args; .return 0}
  .collect_errors_except .nop {
    .mapped_argfunction &3 {$1$}
    .exit}}
.else {
  .echo unexpected command line: &* (
)
  .source /etc/rwshrc-default}
$.echo $nl $nl $nl $nl

 
 
 
0
$.return 0
0
$.function_all_flags # [args ...] {.nop $args$}
0
$.function_all_flags fw {
  .function_all_flags f1 name {.argfunction}
  .whence_function f1; .echo $nl
  f1 f2 {.argfunction}
  .whence_function f2; .echo $nl
  .rm_executable f1; .rm_executable f2}
0
$fw {.echo hi $nl; .function_all_flags $name {.argfunction}}
.function_all_flags f1 name {.echo hi $nl; .function_all_flags $name {.argfunction}}

hi 
.function_all_flags f2  {.echo hi $nl; .function_all_flags $name {.argfunction}}

0
$fw {.while .throw .false {.function_all_flags &&name {.argfunction}}}
.function_all_flags f1 name {.while .throw .false {.function_all_flags &name {.argfunction}}}

f2 : command not found ( f2 .whence_function fw )
-1
$.function_all_flags f1 name {
  .echo function name $name $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of function body $nl}
0
$f1 f2 {
  .echo noname $1 $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of nothing $nl}
function name f2 
{
  .echo noname $1 $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of nothing $nl}

 end of function body 
0
$fw {
  .echo function name $name $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of function body $nl}
.function_all_flags f1 name {
  .echo function name $name $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of function body $nl}

function name f2 
{
  .echo function name $name $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of function body $nl}

 end of function body 
f2 : command not found ( f2 .whence_function fw )
-1
$fw {.for 1 2 3 {
  .echo function name $1 $name $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of function body $nl}}
.function_all_flags f1 name {.for 1 2 3 {
  .echo function name $1 $name $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of function body $nl}}

function name 1 f2 
{.for 1 2 3 {
  .echo function name $1 $name $nl
  .whence_function .argfunction
  .echo $nl end of function body $nl}}

 end of function body 
function name 2 f2 
{.for 1 2 3 {
  .echo function name $1 $name $nl
  .whence_function .argfunction
  .echo $nl end of function body $nl}}

 end of function body 
function name 3 f2 
{.for 1 2 3 {
  .echo function name $1 $name $nl
  .whence_function .argfunction
  .echo $nl end of function body $nl}}

 end of function body 
f2 : command not found ( f2 .whence_function fw )
-1
$fw {.for 1 2 3 {.mapped_argfunction $1 {
  .echo function name &&name $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of function body $nl}}}
.function_all_flags f1 name {.for 1 2 3 {.mapped_argfunction $1 {
  .echo function name &name $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of function body $nl}}}

function name f2 
{.for 1 2 3 {.mapped_argfunction $1 {
  .echo function name &name $nl
  .whence_function .argfunction
  .echo $nl end of function body $nl}}}

 end of function body 
function name f2 
{.for 1 2 3 {.mapped_argfunction $1 {
  .echo function name &name $nl
  .whence_function .argfunction
  .echo $nl end of function body $nl}}}

 end of function body 
function name f2 
{.for 1 2 3 {.mapped_argfunction $1 {
  .echo function name &name $nl
  .whence_function .argfunction
  .echo $nl end of function body $nl}}}

 end of function body 
f2 : command not found ( f2 .whence_function fw )
-1
$# all of the above make sense, and the next should be identical to the last
-1
$fw {.mapped_argfunction $1 {.for 1 2 3 {
  .echo function name &&name $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of function body $nl}}}
.function_all_flags f1 name {.mapped_argfunction $1 {.for 1 2 3 {
  .echo function name &name $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of function body $nl}}}

function name f2 
{.mapped_argfunction $1 {.for 1 2 3 {
  .echo function name &name $nl
  .whence_function .argfunction {.for 1 2 3 {
  .echo function name f2 $nl
  .whence_function .argfunction {.mapped_argfunction $1 {.for 1 2 3 {
  .echo function name &&&&&&name $nl
  .whence_function .argfunction
  .echo $nl end of function body $nl}}}
  .echo $nl end of function body $nl}}
  .echo $nl end of function body $nl}}}

 end of function body 
function name f2 
{.mapped_argfunction $1 {.for 1 2 3 {
  .echo function name &name $nl
  .whence_function .argfunction {.for 1 2 3 {
  .echo function name f2 $nl
  .whence_function .argfunction {.mapped_argfunction $1 {.for 1 2 3 {
  .echo function name &&&&&&name $nl
  .whence_function .argfunction
  .echo $nl end of function body $nl}}}
  .echo $nl end of function body $nl}}
  .echo $nl end of function body $nl}}}

 end of function body 
function name f2 
{.mapped_argfunction $1 {.for 1 2 3 {
  .echo function name &name $nl
  .whence_function .argfunction {.for 1 2 3 {
  .echo function name f2 $nl
  .whence_function .argfunction {.mapped_argfunction $1 {.for 1 2 3 {
  .echo function name &&&&&&name $nl
  .whence_function .argfunction
  .echo $nl end of function body $nl}}}
  .echo $nl end of function body $nl}}
  .echo $nl end of function body $nl}}}

 end of function body 
f2 : command not found ( f2 .whence_function fw )
-1
$# mostly as wierd
-1
$fw {.mapped_argfunction .not_a_number {
  .echo function name &&name $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of function body $nl}}
.function_all_flags f1 name {.mapped_argfunction .not_a_number {
  .echo function name &name $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of function body $nl}}

function name f2 
{.mapped_argfunction .not_a_number {
  .echo function name &name $nl
  .whence_function .argfunction {
  .echo function name f2 $nl
  .whence_function .argfunction {.mapped_argfunction .not_a_number {
  .echo function name &&&&name $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of function body $nl}}
  .echo $nl end of function body $nl}
  .echo $nl end of function body $nl}}

 end of function body 
f2 : command not found ( f2 .whence_function fw )
-1
$# normal again
-1
$fw {.try_catch_recursive .not_a_number {
  .echo function name &&name $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of function body $nl}}
.function_all_flags f1 name {.try_catch_recursive .not_a_number {
  .echo function name &name $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of function body $nl}}

function name f2 
{.try_catch_recursive .not_a_number {
  .echo function name &name $nl
  .whence_function .argfunction
  .echo $nl end of function body $nl}}

 end of function body 
f2 : command not found ( f2 .whence_function fw )
-1
$fw {.for 1 2 3 {.try_catch_recursive .not_a_number {
  .echo function name &&name $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of function body $nl}}}
.function_all_flags f1 name {.for 1 2 3 {.try_catch_recursive .not_a_number {
  .echo function name &name $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of function body $nl}}}

function name f2 
{.for 1 2 3 {.try_catch_recursive .not_a_number {
  .echo function name &name $nl
  .whence_function .argfunction
  .echo $nl end of function body $nl}}}

 end of function body 
function name f2 
{.for 1 2 3 {.try_catch_recursive .not_a_number {
  .echo function name &name $nl
  .whence_function .argfunction
  .echo $nl end of function body $nl}}}

 end of function body 
function name f2 
{.for 1 2 3 {.try_catch_recursive .not_a_number {
  .echo function name &name $nl
  .whence_function .argfunction
  .echo $nl end of function body $nl}}}

 end of function body 
f2 : command not found ( f2 .whence_function fw )
-1
$fw {.try_catch_recursive .not_a_number {.for 1 2 3 {
  .echo function name &&name $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of function body $nl}}}
.function_all_flags f1 name {.try_catch_recursive .not_a_number {.for 1 2 3 {
  .echo function name &name $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of function body $nl}}}

function name f2 
{.try_catch_recursive .not_a_number {.for 1 2 3 {
  .echo function name &name $nl
  .whence_function .argfunction
  .echo $nl end of function body $nl}}}

 end of function body 
function name f2 
{.try_catch_recursive .not_a_number {.for 1 2 3 {
  .echo function name &name $nl
  .whence_function .argfunction
  .echo $nl end of function body $nl}}}

 end of function body 
function name f2 
{.try_catch_recursive .not_a_number {.for 1 2 3 {
  .echo function name &name $nl
  .whence_function .argfunction
  .echo $nl end of function body $nl}}}

 end of function body 
f2 : command not found ( f2 .whence_function fw )
-1
$# maybe weird?
-1
$fw {.mapped_argfunction $1 {
  .echo function name &&name $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of function body $nl}}
.function_all_flags f1 name {.mapped_argfunction $1 {
  .echo function name &name $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of function body $nl}}

function name f2 
{.mapped_argfunction $1 {
  .echo function name &name $nl
  .whence_function .argfunction {
  .echo function name f2 $nl
  .whence_function .argfunction {.mapped_argfunction $1 {
  .echo function name &&&&name $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of function body $nl}}
  .echo $nl end of function body $nl}
  .echo $nl end of function body $nl}}

 end of function body 
f2 : command not found ( f2 .whence_function fw )
-1
$# definitely weird
-1
$fw {.mapped_argfunction $name {.for a b {
  .echo function name &&name $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of function body $nl}}}
.function_all_flags f1 name {.mapped_argfunction $name {.for a b {
  .echo function name &name $nl
  .whence_function .argfunction {.argfunction}
  .echo $nl end of function body $nl}}}

function name f2 
{.mapped_argfunction $name {.for a b {
  .echo function name &name $nl
  .whence_function .argfunction {.for a b {
  .echo function name f2 $nl
  .whence_function .argfunction {.mapped_argfunction $name {.for a b {
  .echo function name &&&&&&name $nl
  .whence_function .argfunction
  .echo $nl end of function body $nl}}}
  .echo $nl end of function body $nl}}
  .echo $nl end of function body $nl}}}

 end of function body 
function name f2 
{.mapped_argfunction $name {.for a b {
  .echo function name &name $nl
  .whence_function .argfunction {.for a b {
  .echo function name f2 $nl
  .whence_function .argfunction {.mapped_argfunction $name {.for a b {
  .echo function name &&&&&&name $nl
  .whence_function .argfunction
  .echo $nl end of function body $nl}}}
  .echo $nl end of function body $nl}}
  .echo $nl end of function body $nl}}}

 end of function body 
f2 : command not found ( f2 .whence_function fw )
-1
$fw {.mapped_argfunction {.function_all_flags $name {.argfunction}}}
.function_all_flags f1 name {.mapped_argfunction {.function_all_flags $name {.argfunction}}}

.function_all_flags f2  {.mapped_argfunction {.function_all_flags $name {.function_all_flags $name {.mapped_argfunction {.function_all_flags $name {.argfunction}}}}}}

0
$.return 0
0
$.nop $A $FIGNORE
0
$.function_all_flags .shutdown -- args ... {
  .nop $args
  .combine $nl (now terminating normally) $nl}
0
$.exit
0

now terminating normally
