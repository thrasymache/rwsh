init file /non-existent/file/to/test/failure does not exist
call stack .source rwsh.mapped_argfunction
.for ${.echo rwsh.sigterm rwsh.multiple_argfunctions}$ {.nop
  .function_all_flags $1 {.echo signal triggered: $0 \( \); .combine $nl; .return -1}}
.global last_command_return -10
.global A \
.global N \
.nop $N

.nop .function_all_flags rwsh.run_logic -- cmd [args ...] {
  .return $last_command_return
  .signal_handler &{.internal_functions}$ {&&* {rwsh.argfunction}}
  rwsh.mapped_argfunction {&&* {rwsh.argfunction}}
  &&* {rwsh.argfunction}
  .set last_command_return $?
  .echo $nl
  .echo $last_command_return
  .echo $nl}
.function_all_flags rwsh.before_command -- args ... {
  .nop $args
  .return $last_command_return}
.function_all_flags rwsh.after_command -- args ... {
  .nop $args
  .set last_command_return $?
  .combine $nl $last_command_return $nl}
.function_all_flags rwsh.prompt {.echo \$}
.function_all_flags rwsh.vars {.internal_vars}
.source /etc/rwshrc-basic
.function_all_flags # -- [ignored ...] {.nop $ignored$}

# set up environment
.set_max_collectible_exceptions 10
.global nl (
)

# internal functions
.function_all_flags rwsh.ambiguous_prototype_dash_dash prototype stack ... {
  .echo $prototype is an ambiguous location for a prototype --
  .combine ( (it requests reading the user's mind) ) \( stack: $stack \) $nl}
.function_all_flags rwsh.arguments_for_argfunction name {
  echo cannot specify arguments for $name directly}
.function_all_flags rwsh.bad_argc required needed optional [stack ...] {
  .echo unacceptable argument count: received $required non-optional
  echo , but needed $needed \(with $optional optional\) for $stack$}
.function_all_flags rwsh.bad_argfunction_style style {
  echo $style is neither an argfunction nor a substitution}
.function_all_flags rwsh.bad_args -- proto assigned needed excess call_stack ... {
  .combine (unacceptable arguments: for prototype ) $proto , $nl
  if_only .test_not_empty $assigned {
    .combine ( assigned )
    .for $assigned$ {.combine $1$0 = ${paren_if_words $1$1} ( )}
    .combine , $nl ( but)}
  if_only .test_not_empty $needed {
    .combine ( needed \() $needed \), $nl
    if_only .test_not_empty $excess {.combine ( and)}}
  if_only .test_not_empty $excess {
    .combine ( found \() $excess (\) excess) $nl}
  echo \ call stack:  $call_stack}
.function_all_flags rwsh.bad_if_nest stack ... {
  echo nested .if without .else with call stack: $stack$}
.function_all_flags rwsh.binary_does_not_exist name [stack ...] {
  echo $name : binary does not exist
  if_only .var_exists stack {echo call stack: $stack}}
.function_all_flags rwsh.binary_not_found name path stack ... {
  echo $name : binary not found in $path
  echo call stack: $stack$}
.function_all_flags rwsh.dash_dash_argument args stack ... {
  echo optional -- parameter cannot take arguments \( $args \) with call stack: $stack$}
.function_all_flags rwsh.dash_star_argument args stack ... {
  echo optional -* parameter cannot take arguments \( $args \) with call stack: $stack$}
.function_all_flags rwsh.directory_not_found -- dir stack ... {
  .combine $dir ( directory does not exist) $nl
  echo call stack $stack}
.function_all_flags rwsh.divide_by_zero numerator stack ... {
  echo attempt to divide $numerator by 0 with call stack: $stack$}
.function_all_flags rwsh.double_redirection first second [stack ...] {
  echo double redirection is not supported at this time: $first and $second
  if_only .var_exists stack {echo call stack: $stack$}}
.function_all_flags rwsh.duplicate_parameter -- parameter stack ... {
  echo duplicated parameter in function definition: $parameter
  echo call stack: $stack$}
.function_all_flags rwsh.elipsis_first_arg -- elipsis stack ... {
  echo $elipsis elipsis cannot be the first argument in a prototype
  echo call stack: $stack$}
.function_all_flags rwsh.elipsis_out_of_option_group -- group stack ... {
  echo $group for elipsis to apply to option it must occur within the brackets
  echo call stack: $stack$}
.function_all_flags rwsh.else_without_if stack ... {
  echo else without if with call stack: $stack$}
.function_all_flags rwsh.excess_argfunction cmd [stack ...] {
  echo $cmd does not accept an argfunction with call stack: $cmd $stack$}
.function_all_flags rwsh.excessive_exceptions_collected max stack ... {
  echo exceeded maximum number of exceptions \( $max \) in collect_errors.
  echo call stack: $stack$}
.function_all_flags rwsh.excessive_exceptions_in_catch max stack ... {
  echo exceeded maximum number of exceptions \( $max \) in try_catch.
  echo call stack: $stack$}
.function_all_flags rwsh.excessive_nesting stack ... {
  echo function exceeded max nesting \( ${.get_max_nesting} \). call stack: $stack}
.function_all_flags rwsh.exec_failed binary errno stack ... {
  .combine (.exec failed for ) $binary ( with errno ) $errno $nl
  echo call stack $stack}
.function_all_flags rwsh.executable_already_exists -- binary stack ... {
  echo $binary is already an executable in the hash table $nl
  echo call stack $stack}
.function_all_flags rwsh.failed_substitution substitution [stack ...] {
  echo substitution $substitution failed
  echo call stack $stack$}
.function_all_flags rwsh.file_not_found -- file stack ... {
  echo could not find file $file
  echo call stack $stack}
.function_all_flags rwsh.file_open_failure -- file stack ... {
  echo could not open file $file
  echo call stack $stack}
.function_all_flags rwsh.flag_in_elipsis -- flag stack ... {
  echo found flag $flag while collecting arguments for elipsis
  echo call stack $stack$}
.function_all_flags rwsh.function_not_found -- cmd [stack ...] {
  echo $cmd : command not found \( $cmd $stack$ \)}
.function_all_flags rwsh.help [args ...] {
  .nop $args$
  .echo this is the default configuration for rwsh \(or something copied from it
  echo \), documentation should be available at rwsh.sf.net or rwsh.org}
.function_all_flags rwsh.if_before_else stack ... {
  echo two .if commands without a .else between them with call stack : $stack$}
.function_all_flags rwsh.illegal_function_name name stack ... {
  .combine \$ $name ( cannot be a function) $nl
  echo call stack $stack}
.function_all_flags rwsh.illegal_variable_name name stack ... {
  .combine \$ $name ( cannot be set) $nl
  echo call stack $stack}
.function_all_flags rwsh.input_range -- value stack ... {
  echo value $value is out of usable numeric range
  echo call stack $stack$}
.function_all_flags rwsh.internal_error -- [args ...] {
  echo internal error: $args$
  .return -1}
.function_all_flags rwsh.invalid_word_selection selection [stack ...] {
  echo $selection is not a valid word selection
  echo call stack $stack$}
.function_all_flags rwsh.mismatched_brace context [stack ...] {
  echo mismatched brace: $context $stack$}
.function_all_flags rwsh.mismatched_bracket context stack ... {
  echo mismatched bracket: $context
  echo call stack: $stack$}
.function rwsh.mismatched_parenthesis {
  .echo signal triggered: $0 \( $* \); .combine $nl
  echo mismatched parenthesis: $1
  echo call stack: $*2
  .return -1}
.function_all_flags rwsh.missing_argfunction cmd [add_stack ...] {
  echo $cmd requires an argfunction
  if_only .var_exists add_stack {echo stack $add_stack$}}
.function_all_flags rwsh.multiple_argfunctions {
  echo multiple argfunctions not supported at this time}
.function_all_flags rwsh.not_a_directory file stack ... {
  .combine $file ( is not a directory) $nl
  echo call stack $stack}
.function_all_flags rwsh.not_a_function executable stack ... {
  .combine $executable ( is not a function) $nl
  echo call stack $stack}
.function_all_flags rwsh.not_a_number -- nan stack ... {
  echo $nan is not a number
  echo call stack: $stack$}
.function_all_flags rwsh.not_executable file stack ... {
  echo $file is not executable
  echo call stack: $stack$}
.function_all_flags rwsh.not_soon_enough too_late [stack ...] {
  echo $too_late attempts to substitute after the command has been run
  if_only .var_exists stack {echo call stack $stack}}
.function_all_flags rwsh.post_elipsis_option -- flag stack ... {
  echo option $flag coming after an elipsis has no meaning
  echo call stack: $stack$}
.function_all_flags rwsh.post_dash_dash_flag -- flag stack ... {
  echo flag option $flag occurs after -- in the prototype
  echo call stack: $stack$}
.function_all_flags rwsh.result_range -- lhs rhs op [stack ...] {
  echo result of $op with arguments $lhs and $rhs is out of range
  echo call stack: $op $stack$}
.function_all_flags rwsh.return_code code cmd [add_stack ...] {
  echo $cmd returned $code : call stack $cmd $add_stack$}
.function_all_flags rwsh.selection_not_found not_found selection [stack ...] {
  .echo no file matching pattern $not_found
  if_only .test_string_unequal $not_found $selection {
    .echo () for selection $selection}
  .echo $nl
  if_only .var_exists stack {echo call stack: $stack$}
  .return -1}
.function_all_flags rwsh.sigcont [args ...] {
  echo received SIGCONT: $args$; .return -1}
.function_all_flags rwsh.sigchld [args ...] {
  echo received SIGCHLD: $args$; .return -1}
.function_all_flags rwsh.sighup [args ...] {
  echo received SIGHUP: $args$; .return -1}
.function_all_flags rwsh.sigint [args ...] {
  echo received SIGINT: $args$; .return -1}
.function_all_flags rwsh.sigquit [args ...] {
  echo received SIGQUIT: $args$; .return -1}
.function_all_flags rwsh.sigpipe [args ...] {
  echo received SIGPIPE: $args$; .return -1}
.function_all_flags rwsh.sigterm [args ...] {
  echo received SIGTERM: $args$; .return -1}
.function_all_flags rwsh.sigtstp [args ...] {
  echo received SIGTSTP: $args$; .return -1}
.function_all_flags rwsh.siginfo [args ...] {
  echo received SIGINFO: $args$; .return -1}
.function_all_flags rwsh.sigusr1 [args ...] {
  echo received SIGUSR1: $args$; .return -1}
.function_all_flags rwsh.sigusr2 [args ...] {
  echo received SIGUSR2: $args$; .return -1}
.function_all_flags rwsh.sigunknown [args ...] {
  echo received unknown unix signal: $args$; .return -1}
.function_all_flags rwsh.shutdown -- args ... {
  .nop $args
  .combine $nl (now terminating normally) $nl}
.function_all_flags rwsh.tardy_flag -- flag stack ... {
  echo $flag flag comes too late in command
  echo call stack: $stack$}
.function_all_flags rwsh.unchecked_variable -- var [stack ...] {
  echo $var was not checked with call stack $stack$}
.function_all_flags rwsh.undeclared_variable -- name [stack ...] {
  echo $name was not declared
  echo call stack: $stack$}
.function_all_flags rwsh.undefined_variable -- name [stack ...] {
  echo optional variable $name was not defined
  echo call stack: $stack$}
.function_all_flags rwsh.unreadable_dir dir errno [stack ...] {
  .combine (cannot read directory ) $dir \ \(errno\  $errno \) $nl
  echo call stack: $stack$
  .return -1}
.function_all_flags rwsh.unrecognized_flag -- flag cmd [add_stack ...] {
  echo $flag flag is unrecognized for $cmd
  echo call stack: $cmd $add_stack$}
.function_all_flags rwsh.unused_before_set -- var [stack ...] {
  echo attempt to set $var before making use of its initial value
  echo call stack $stack$}
.function_all_flags rwsh.unused_variable -- var [stack ...] {
  echo $var was unused with call stack $stack$}
.function_all_flags rwsh.version_incompatible version stack ... {
  echo this shell is not compatible with requested version $version
  echo call stack: $stack$}

# ability of functions to act as builtin wrappers
.function_all_flags ! args ... {.if $args$ {.return 1}; .else {.return 0}}
.function_all_flags af -- [argv ...] {rwsh.argfunction}
.function_all_flags c -- text ... {.combine $text$}
.function_all_flags e -- text ... {.echo $text}
.function_all_flags echo -- text ... {.echo $text; .combine $nl}
.function_all_flags echo-comments cmd ... {
  .stepwise $cmd$ {if_only .test_in $1 .nop # #! ## {echo &&&*}}}
.function_all_flags exec -- argv ... {.exec $argv$}
.function_all_flags elif command ... {.else_if $command$ {rwsh.argfunction}}
.function_all_flags else {.else {rwsh.argfunction}}
.function_all_flags fn -- prototype ... {
  .function_all_flags $prototype$ {rwsh.argfunction}}
.function_all_flags fni -- name args ... {
  .function_all_flags $name -- $args$ {rwsh.argfunction}}
.function_all_flags fns -- name args ... {
  .function_all_flags $name [-*] $args$ {rwsh.argfunction}}
.function_all_flags if_only -- args ... {
  .if $args$ {rwsh.argfunction}; .else {.nop}}
.function_all_flags if_only_not -- args ... {
  .if $args$ {.nop}; .else {rwsh.argfunction}}
fn ntimes n {
  .while test_var_greater n 0 {
    rwsh.mapped_argfunction {rwsh.argfunction}
    .var_subtract n 1}}
.function_all_flags setf var value {
  .if .var_exists $var {.set $var $value}
  .else {.global $var $value}}
fn single -- args ... {.scope ${$args$}$ result {echo $result}}
fn test_var_not_equal var value {.test_string_unequal $$var $value}
.function_all_flags test_var_greater -- var value {.test_greater $$var $value}
fn which command {
  .if .which_test $command {
    .combine ${.which_executable $command {rwsh.argfunction}} $nl}
  .else {echo no $command}}
fn whichp binary {.which_path $binary $PATH}
.function_all_flags var_exists -- var {.var_exists $var}
.function_all_flags var_val -- [var ...] {
  .if .var_exists var {.for $var$ {.combine $1 \( $$1 \) \ }}
  .else {.nop}}
.function_all_flags paren_if_words -- value {
  .if .test_number_equal ${.argc $value$} 1 {.combine $value}
  .else {.combine \( $value \)}}
fn polish -- operator builtin {
  fn &&operator -- lhs rhs ... {
    if_only .test_in $lhs + - / {
      .scope ${$lhs $rhs$}$ (-- l r ...) {
        .set lhs $l
        .set rhs $r}}
    .scope $rhs$ (rhs [extra ...]) {
      .if .test_in $rhs + - / {
        .scope ${$rhs $extra$}$ (rhs [extra ...]) {
          &&builtin lhs $rhs
          echo $lhs $extra$}}
      .else {
        &&builtin lhs $rhs
        echo $lhs $extra$}}}}
polish - .var_subtract
polish + .var_add
polish / .var_divide
.else_if .test_string_equal $2 -c {
  .for ${.list_environment}$ {
    .scope $1$ (-- var val) {
      .global $var $val
      .nop $$var}}
  .source /etc/rwshrc-basic
  .function_all_flags rwsh.if_before_else stack ... {.nop $stack}
  .function_all_flags rwsh.shutdown -- args ... {.nop $args; .return 0}
  .collect_errors_except .nop {
    rwsh.mapped_argfunction &3 {$1$}
    .exit}}
.else {
  .echo unexpected command line: &* (
)
  .source /etc/rwshrc-default}
$.echo $nl $nl $nl $nl

 
 
 

0
$.return 0

0
$.function_all_flags # [args ...] {.nop $args$}

0
$.function_all_flags fw {
  .function_all_flags f1 name {rwsh.argfunction}
  .which_executable f1; .echo $nl
  f1 f2 {rwsh.argfunction}
  .which_executable f2; .echo $nl
  .rm_executable f1; .rm_executable f2}

0
$fw {.echo hi $nl; .function_all_flags $name {rwsh.argfunction}}
.function_all_flags f1 name {.echo hi $nl; .function_all_flags $name {rwsh.argfunction}}
hi 
.function_all_flags f2  {.echo hi $nl; .function_all_flags $name {rwsh.argfunction}}

0
$fw {.while .return 1 {.function_all_flags &&name {rwsh.argfunction}}}
.function_all_flags f1 name {.while .return 1 {.function_all_flags &name {rwsh.argfunction}}}

f2 : command not found ( f2 .rm_executable fw )

-1
$.function_all_flags f1 name {
  .echo function name $name $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of function body $nl}

0
$f1 f2 {
  .echo noname $1 $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of nothing $nl}
function name f2 
{
  .echo noname $1 $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of nothing $nl}
 end of function body 

0
$fw {
  .echo function name $name $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of function body $nl}
.function_all_flags f1 name {
  .echo function name $name $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of function body $nl}
function name f2 
{
  .echo function name $name $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of function body $nl}
 end of function body 

f2 : command not found ( f2 .rm_executable fw )

-1
$fw {.for 1 2 3 {
  .echo function name $1 $name $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of function body $nl}}
.function_all_flags f1 name {.for 1 2 3 {
  .echo function name $1 $name $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of function body $nl}}
function name 1 f2 
{.for 1 2 3 {
  .echo function name $1 $name $nl
  .which_executable rwsh.argfunction
  .echo $nl end of function body $nl}}
 end of function body 
function name 2 f2 
{.for 1 2 3 {
  .echo function name $1 $name $nl
  .which_executable rwsh.argfunction
  .echo $nl end of function body $nl}}
 end of function body 
function name 3 f2 
{.for 1 2 3 {
  .echo function name $1 $name $nl
  .which_executable rwsh.argfunction
  .echo $nl end of function body $nl}}
 end of function body 

f2 : command not found ( f2 .rm_executable fw )

-1
$fw {.for 1 2 3 {rwsh.mapped_argfunction $1 {
  .echo function name &&name $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of function body $nl}}}
.function_all_flags f1 name {.for 1 2 3 {rwsh.mapped_argfunction $1 {
  .echo function name &name $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of function body $nl}}}
function name f2 
{.for 1 2 3 {rwsh.mapped_argfunction $1 {
  .echo function name &name $nl
  .which_executable rwsh.argfunction
  .echo $nl end of function body $nl}}}
 end of function body 
function name f2 
{.for 1 2 3 {rwsh.mapped_argfunction $1 {
  .echo function name &name $nl
  .which_executable rwsh.argfunction
  .echo $nl end of function body $nl}}}
 end of function body 
function name f2 
{.for 1 2 3 {rwsh.mapped_argfunction $1 {
  .echo function name &name $nl
  .which_executable rwsh.argfunction
  .echo $nl end of function body $nl}}}
 end of function body 

f2 : command not found ( f2 .rm_executable fw )

-1
$# all of the above make sense, and the next should be identical to the last

-1
$fw {rwsh.mapped_argfunction $1 {.for 1 2 3 {
  .echo function name &&name $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of function body $nl}}}
.function_all_flags f1 name {rwsh.mapped_argfunction $1 {.for 1 2 3 {
  .echo function name &name $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of function body $nl}}}
function name f2 
{rwsh.mapped_argfunction $1 {.for 1 2 3 {
  .echo function name &name $nl
  .which_executable rwsh.argfunction {.for 1 2 3 {
  .echo function name f2 $nl
  .which_executable rwsh.argfunction {rwsh.mapped_argfunction $1 {.for 1 2 3 {
  .echo function name &&&&&&name $nl
  .which_executable rwsh.argfunction
  .echo $nl end of function body $nl}}}
  .echo $nl end of function body $nl}}
  .echo $nl end of function body $nl}}}
 end of function body 
function name f2 
{rwsh.mapped_argfunction $1 {.for 1 2 3 {
  .echo function name &name $nl
  .which_executable rwsh.argfunction {.for 1 2 3 {
  .echo function name f2 $nl
  .which_executable rwsh.argfunction {rwsh.mapped_argfunction $1 {.for 1 2 3 {
  .echo function name &&&&&&name $nl
  .which_executable rwsh.argfunction
  .echo $nl end of function body $nl}}}
  .echo $nl end of function body $nl}}
  .echo $nl end of function body $nl}}}
 end of function body 
function name f2 
{rwsh.mapped_argfunction $1 {.for 1 2 3 {
  .echo function name &name $nl
  .which_executable rwsh.argfunction {.for 1 2 3 {
  .echo function name f2 $nl
  .which_executable rwsh.argfunction {rwsh.mapped_argfunction $1 {.for 1 2 3 {
  .echo function name &&&&&&name $nl
  .which_executable rwsh.argfunction
  .echo $nl end of function body $nl}}}
  .echo $nl end of function body $nl}}
  .echo $nl end of function body $nl}}}
 end of function body 

f2 : command not found ( f2 .rm_executable fw )

-1
$# mostly as wierd

-1
$fw {rwsh.mapped_argfunction rwsh.not_a_number {
  .echo function name &&name $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of function body $nl}}
.function_all_flags f1 name {rwsh.mapped_argfunction rwsh.not_a_number {
  .echo function name &name $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of function body $nl}}
function name f2 
{rwsh.mapped_argfunction rwsh.not_a_number {
  .echo function name &name $nl
  .which_executable rwsh.argfunction {
  .echo function name f2 $nl
  .which_executable rwsh.argfunction {rwsh.mapped_argfunction rwsh.not_a_number {
  .echo function name &&&&name $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of function body $nl}}
  .echo $nl end of function body $nl}
  .echo $nl end of function body $nl}}
 end of function body 

f2 : command not found ( f2 .rm_executable fw )

-1
$# normal again

-1
$fw {.try_catch_recursive rwsh.not_a_number {
  .echo function name &&name $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of function body $nl}}
.function_all_flags f1 name {.try_catch_recursive rwsh.not_a_number {
  .echo function name &name $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of function body $nl}}
function name f2 
{.try_catch_recursive rwsh.not_a_number {
  .echo function name &name $nl
  .which_executable rwsh.argfunction
  .echo $nl end of function body $nl}}
 end of function body 

f2 : command not found ( f2 .rm_executable fw )

-1
$fw {.for 1 2 3 {.try_catch_recursive rwsh.not_a_number {
  .echo function name &&name $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of function body $nl}}}
.function_all_flags f1 name {.for 1 2 3 {.try_catch_recursive rwsh.not_a_number {
  .echo function name &name $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of function body $nl}}}
function name f2 
{.for 1 2 3 {.try_catch_recursive rwsh.not_a_number {
  .echo function name &name $nl
  .which_executable rwsh.argfunction
  .echo $nl end of function body $nl}}}
 end of function body 
function name f2 
{.for 1 2 3 {.try_catch_recursive rwsh.not_a_number {
  .echo function name &name $nl
  .which_executable rwsh.argfunction
  .echo $nl end of function body $nl}}}
 end of function body 
function name f2 
{.for 1 2 3 {.try_catch_recursive rwsh.not_a_number {
  .echo function name &name $nl
  .which_executable rwsh.argfunction
  .echo $nl end of function body $nl}}}
 end of function body 

f2 : command not found ( f2 .rm_executable fw )

-1
$fw {.try_catch_recursive rwsh.not_a_number {.for 1 2 3 {
  .echo function name &&name $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of function body $nl}}}
.function_all_flags f1 name {.try_catch_recursive rwsh.not_a_number {.for 1 2 3 {
  .echo function name &name $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of function body $nl}}}
function name f2 
{.try_catch_recursive rwsh.not_a_number {.for 1 2 3 {
  .echo function name &name $nl
  .which_executable rwsh.argfunction
  .echo $nl end of function body $nl}}}
 end of function body 
function name f2 
{.try_catch_recursive rwsh.not_a_number {.for 1 2 3 {
  .echo function name &name $nl
  .which_executable rwsh.argfunction
  .echo $nl end of function body $nl}}}
 end of function body 
function name f2 
{.try_catch_recursive rwsh.not_a_number {.for 1 2 3 {
  .echo function name &name $nl
  .which_executable rwsh.argfunction
  .echo $nl end of function body $nl}}}
 end of function body 

f2 : command not found ( f2 .rm_executable fw )

-1
$# maybe weird?

-1
$fw {rwsh.mapped_argfunction $1 {
  .echo function name &&name $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of function body $nl}}
.function_all_flags f1 name {rwsh.mapped_argfunction $1 {
  .echo function name &name $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of function body $nl}}
function name f2 
{rwsh.mapped_argfunction $1 {
  .echo function name &name $nl
  .which_executable rwsh.argfunction {
  .echo function name f2 $nl
  .which_executable rwsh.argfunction {rwsh.mapped_argfunction $1 {
  .echo function name &&&&name $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of function body $nl}}
  .echo $nl end of function body $nl}
  .echo $nl end of function body $nl}}
 end of function body 

f2 : command not found ( f2 .rm_executable fw )

-1
$# definitely weird

-1
$fw {rwsh.mapped_argfunction $name {.for a b {
  .echo function name &&name $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of function body $nl}}}
.function_all_flags f1 name {rwsh.mapped_argfunction $name {.for a b {
  .echo function name &name $nl
  .which_executable rwsh.argfunction {rwsh.argfunction}
  .echo $nl end of function body $nl}}}
function name f2 
{rwsh.mapped_argfunction $name {.for a b {
  .echo function name &name $nl
  .which_executable rwsh.argfunction {.for a b {
  .echo function name f2 $nl
  .which_executable rwsh.argfunction {rwsh.mapped_argfunction $name {.for a b {
  .echo function name &&&&&&name $nl
  .which_executable rwsh.argfunction
  .echo $nl end of function body $nl}}}
  .echo $nl end of function body $nl}}
  .echo $nl end of function body $nl}}}
 end of function body 
function name f2 
{rwsh.mapped_argfunction $name {.for a b {
  .echo function name &name $nl
  .which_executable rwsh.argfunction {.for a b {
  .echo function name f2 $nl
  .which_executable rwsh.argfunction {rwsh.mapped_argfunction $name {.for a b {
  .echo function name &&&&&&name $nl
  .which_executable rwsh.argfunction
  .echo $nl end of function body $nl}}}
  .echo $nl end of function body $nl}}
  .echo $nl end of function body $nl}}}
 end of function body 

f2 : command not found ( f2 .rm_executable fw )

-1
$fw {rwsh.mapped_argfunction {.function_all_flags $name {rwsh.argfunction}}}
.function_all_flags f1 name {rwsh.mapped_argfunction {.function_all_flags $name {rwsh.argfunction}}}
.function_all_flags f2  {rwsh.mapped_argfunction {.function_all_flags $name {.function_all_flags $name {rwsh.mapped_argfunction {.function_all_flags $name {rwsh.argfunction}}}}}}

0
$.return 0

0
$.nop $A $FIGNORE

0
$.function_all_flags rwsh.shutdown -- args ... {
  .nop $args
  .combine $nl (now terminating normally) $nl}

0
$.exit

0

now terminating normally
