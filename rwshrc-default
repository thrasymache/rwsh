.for ${.list_environment}$ {
  .scope $1$ (-- var val) {.global $var $val; .nop $$var}}
.source /etc/rwshrc-basic

# only the last line is actually needed, but this is the only test of these
.toggle_readline
.toggle_readline
.disable_readline
.enable_readline

.try_catch_recursive .unused_variable {.collect_errors_except .nop {
  # set up environment
  .function_all_flags set_if_undefined -- var [value] {
    .if .var_exists $var {.nop $value$}
    .else_if .var_exists value {.global $var $value}
    .else {.global $var ()}}
  set_if_undefined BUILT_EXECUTABLE /bin/rwsh
  set_if_undefined REGEX ()
  set_if_undefined grep-sel ()
  set_if_undefined s ()
  set_if_undefined s2 ()
  set_if_undefined FIGNORE .*
}}

# selection commands
fn sfn command {
  .function_all_flags $command [-*] [file ...] {
    if_only .var_exists file {.selection_set s $file}
    &&{.which_path $command $PATH} $-*$ @$s}}
fn fn-subcommand system command {
  .function_all_flags &&{c $system - $command} -- [args ...] {
    .if .var_exists args {&&{whichp $system} &&command $args$}
    .else {&&{whichp $system} &&command}}}
fn sfn-subcommand system command {
  .function_all_flags &&{c $system - $command} [-*] [file ...] {
    if_only .var_exists file {.selection_set s $file}
    .if .test_not_empty $s {&&{whichp $system} &&command $-*$ @$s}
    .else {&&{whichp $system} &&command $-*$}}}
sfn cat 
fn cd [path] {
  if_only .var_exists path {.selection_set s $path}
  .cd @$s
  &{whichp pwd}
  .set s (); .set s2 ()}
fns chmod mode [file ...] {
  if_only .var_exists file {.selection_set s $file}
  &{whichp chmod} $-*$ $mode @$s}
fns cp dest {&{whichp cp} $-*$ @$s $dest}
fn create [file ...] {
  if_only .var_exists file {.selection_set s $file}
  &{whichp touch} $s$}
fns cvs command [file ...] {
  if_only .var_exists file {.selection_set s $file}
  .if .test_not_empty $s {&{whichp cvs} $-*$ $command @$s}
  .else {&{whichp cvs} $-*$ $command}}
fns darcs command [file ...] {
  if_only .var_exists file {.selection_set s $file}
  .if .test_not_empty $s {&{whichp darcs} $-*$ $command @$s}
  .else {&{whichp darcs} $-*$ $command}}
fns diff [one] [two] {
  # primary selection is _second_ operand, secondary selection is first
  if_only .var_exists two {.selection_set s $two}
  if_only .var_exists one {.selection_set s2 $one}
  &{whichp diff} $-*$ @$s2 @$s}
sfn du
fns ed [-p prompt] [file] {
  if_only .var_exists file {.selection_set s $file}
  &&{whichp ed} $-*$ @$s}
fns gdb-bash [binary] {
  if_only .var_exists binary {.set BUILT_EXECUTABLE $binary}
  echo debugging $BUILT_EXECUTABLE
  .scope /bin/bash SHELL {
    .nop $SHELL is for the environment
    &{whichp gdb} $-*$ $BUILT_EXECUTABLE}}
fns gdb [binary] {
  if_only .var_exists binary {.set BUILT_EXECUTABLE $binary}
  echo debugging $BUILT_EXECUTABLE
  &{whichp gdb} $-*$ $BUILT_EXECUTABLE}
.function_all_flags git-git -- args ... {&{whichp git} $args$}
fns git command [file ...] {
  if_only .var_exists file {.selection_set s $file$}
  .if .test_not_empty $s {&{whichp git} $-*$ $command @$s}
  .else {&{whichp git} $-*$ $command}}
sfn-subcommand git add
fn-subcommand git branch
fn-subcommand git clone
fn-subcommand git config
sfn-subcommand git commit
sfn-subcommand git diff
fn-subcommand git fetch
fn-subcommand git help
fn-subcommand git log
fn-subcommand git remote
fn-subcommand git push
sfn-subcommand git rm
sfn-subcommand git status
fns grep [-l] [regex] [file ...] {
  if_only .var_exists regex {.set REGEX $regex}
  if_only .var_exists file {.selection_set s $file}
  .try_catch_recursive .return_code {
    .if var_exists -l {
      .local result ()
      .nop $result
      .store_output result {&{whichp grep} $-*$ $REGEX @$s}
      .echo $result
      .set grep-sel $result$}
    .else {&{whichp grep} $-*$ $REGEX @$s}}}
fn grep-sel {.set s $grep-sel}
sfn gzip
sfn gunzip
fn home {cd $HOME}
fns head [-n lines] [-c bytes] [file ...] {
  if_only .var_exists file {.selection_set s $file}
  &&{whichp head} $-*$ @$s}
.function_all_flags ignore args ... {.set FIGNORE $args$}
fns ll [file ...] {
  if_only .var_exists file {.selection_set s $file}
  &&{whichp ls} -ld $-*$ @$s}
fns ls [file ...] {
  if_only .var_exists file {.selection_set s $file}
  .if .test_not_empty $-* {&&{whichp ls} $-*$ @$s}
  .else {.ls @$s}}
sfn less 
sfn md5sum
fns mv dest {
  &{whichp mv} $-*$ @$s $dest
  .set s $dest}
fns regrep [file ...] {
  # wrap grep function to keep REGEX but change file
  .if .var_exists file {grep $-*$ $REGEX $file$}
  .else {grep $-*$}}
sfn rm 
sfn sum
fns tail [-b blocks] [-c bytes] [-n lines] [file ...] {
  if_only .var_exists file {.selection_set s $file}
  &&{whichp tail} $-*$ @$s}
fn tar bundled-flags [file ...] {
  if_only .var_exists file {.selection_set s $file}
  &{whichp tar} $bundled-flags @$s}
sfn touch
sfn vi 
sfn view
fns vim [file ...] {
  if_only .var_exists file {.selection_set s $file}
  .local old_shell $SHELL
  .set SHELL /bin/bash
  &{whichp vim} $-*$ @$s
  .set SHELL $old_shell}
sfn wc 
fn unselect {.set s ()}

# internal functions
.function_all_flags .run_logic -- cmd [args ...] {
   .try_catch_recursive &{.internal_functions}$ {$cmd $args$ {.argfunction}}
  # $* {.argfunction}
  .local ret $?
  if_only_not .test_number_equal $ret 0 {echo $cmd returned $ret}}
.function_all_flags .prompt {.echo $s; .echo \$}
.function_all_flags .vars {
  .internal_vars
  echo $nl HOME $HOME
  echo REGEX $REGEX
  echo s $s}

# misc
.function_all_flags . -- command ... {.source $command$}
.function_all_flags ex_count -- cmd {.execution_count $cmd; c $nl}
.function_all_flags exec -- command ... {.exec $command$ }
.function_all_flags exit {.exit}
.function_all_flags last_time cmd {.last_execution_time $cmd; c $nl}
fn local {. &{c $HOME /.rwshrc}}
fn mark {ntimes 4 {.echo ####################}; c $nl}
fn ret {.return $*}
.function_all_flags timings cmd {
  .echo last time (); .last_execution_time $cmd; c $nl
  .echo total time (); .total_execution_time $cmd; c $nl
  .echo execution count (); .execution_count $cmd; c $nl}
.function_all_flags total_time cmd {.total_execution_time $cmd; c $nl}
.function_all_flags user_shell_ratio {
  .local time &&{.waiting_for_user}
  .var_divide time &&{.waiting_for_shell}
  .combine $time $nl}
.function_all_flags waiting {
  echo for user ${.waiting_for_user}
  echo for binary ${.waiting_for_binary}
  echo for shell ${.waiting_for_shell}}
fn ist [-?] [-nc] {
  if_only .var_exists -nc {.set -? $-?$ --suppress-common-lines}
  .collect_errors_except .nop {
    /bin/rwsh -to <test_main.sh >last.test.result
    .if .test_not_empty $-? {
      &{whichp diff} $-?$ test.result last.test.result}
    .else {&{whichp diff} -c test.result last.test.result}}}
fn st [-?] [-nc] {
  if_only .var_exists -nc {.set -? $-?$ --suppress-common-lines}
  .collect_errors_except .nop {
    to <test_main.sh >last.test.result
    .if .test_not_empty $-? {
      &{whichp diff} $-?$ test.result last.test.result}
    .else {&{whichp diff} -c test.result last.test.result}}}
fn bless-t {&{whichp cp} last.test.result test.result}
fn to {./rwsh -to}
fn mst [-?] {make; st $-*$}
fn ti [-?] [-nc] {
  if_only .var_exists -nc {.set -? $-?$ --suppress-common-lines}
  .collect_errors_except .nop {
    to <test_inconsistent.sh >last.test_inconsistent.result
    &{whichp diff} $-?$ test_inconsistent.result last.test_inconsistent.result}}
fn ti-bless {/bin/cp last.test_inconsistent.result test_inconsistent.result}
fn mqt [-?] {make; qt $-*$}
fn qt [-?] [-nc] {
  if_only .var_exists -nc {.set -? $-?$ --suppress-common-lines}
  .collect_errors_except .nop {
    to <test_quick.sh >last.test_quick.result
    .if .test_not_empty $-? {
      &{whichp diff} $-?$ test_quick.result last.test_quick.result}
    .else {&{whichp diff} -c test_quick.result last.test_quick.result}}}
fn bless-qt {&{whichp cp} last.test_quick.result test_quick.result}
fn arg-out {./rwsh -to <argfunction.sh}
fn arg-diff [-?] {
  arg-out >argfunction.result.last
  .if .test_not_empty $-? {
    &{whichp diff} $-?$ argfunction.basic-result argfunction.result.last}
  .else {&{whichp diff} -c argfunction.basic-result argfunction.result.last}}
fn bless-arg {&{whichp cp} argfunction.result.last argfunction.basic-result}

# final setup and individual configuration
.source &{c $HOME /.rwshrc}
.if .var_exists already-initialized {.nop}
.else {
  .combine rwsh\ v &{.version} $nl
  .global already-initialized true}
